const nr = {
  basemaps: {
    defaults: {
      crs: "EPSG:3857",
      attribution: "Kaartgegevens &copy; <a href='https://www.kadaster.nl'>Kadaster</a> |             <a href='https://www.verbeterdekaart.nl'>Verbeter de kaart</a>",
      minZoom: 6,
      maxZoom: 19,
      type: "wmts",
      format: "png",
      url: "https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0"
    },
    layers: [
      {
        url: "https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0",
        crs: "EPSG:3857",
        format: "png",
        name: "standaard",
        layerName: "standaard"
      },
      {
        url: "https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0",
        crs: "EPSG:3857",
        format: "png",
        name: "grijs",
        layerName: "grijs"
      },
      {
        url: "https://service.pdok.nl/brt/achtergrondkaart/wmts/v2_0",
        crs: "EPSG:3857",
        format: "png",
        name: "pastel",
        layerName: "pastel"
      },
      {
        name: "luchtfoto",
        crs: "EPSG:3857",
        layerName: "Actueel_ortho25",
        url: "https://service.pdok.nl/hwh/luchtfotorgb/wmts/v1_0",
        format: "jpeg"
      }
    ]
  },
  wms: {
    defaults: {
      url: "https://service.pdok.nl/{workSpaceName}?",
      version: "1.1.1",
      transparent: !0,
      format: "image/png",
      minZoom: 0,
      maxZoom: 24
    },
    layers: [
      {
        name: "adressen",
        url: "https://service.pdok.nl/kadaster/adressen/wms/v1_0?",
        layerName: "adressen"
      },
      {
        name: "percelen",
        url: "https://service.pdok.nl/kadaster/kadastralekaart/wms/v5_0?",
        layerName: "Kadastralekaart"
      },
      {
        name: "gebouwen",
        url: "https://service.pdok.nl/lv/bag/wms/v2_0?",
        layerName: "pand"
      },
      {
        name: "drone-no-fly-zones",
        url: "https://service.pdok.nl/lvnl/drone-no-flyzones/wms/v1_0?",
        layerName: "luchtvaartgebieden,landingsite"
      },
      {
        name: "hoogte",
        url: "https://service.pdok.nl/rws/ahn/wms/v1_0?",
        layerName: "dsm_05m"
      },
      {
        name: "gemeenten",
        url: "https://service.pdok.nl/kadaster/bestuurlijkegebieden/wms/v1_0?",
        layerName: "Gemeentegebied",
        styleName: "Gemeentegebied"
      },
      {
        name: "provincies",
        url: "https://service.pdok.nl/kadaster/bestuurlijkegebieden/wms/v1_0?",
        layerName: "Provinciegebied",
        styleName: "Provinciegebied"
      },
      {
        name: "land",
        url: "https://service.pdok.nl/kadaster/bestuurlijkegebieden/wms/v1_0?",
        layerName: "Landgebied",
        styleName: "Landgebied"
      }
    ]
  },
  geocoder: {
    suggestUrl: "https://api.pdok.nl/bzk/locatieserver/search/v3_1/suggest?",
    lookupUrl: "https://api.pdok.nl/bzk/locatieserver/search/v3_1/lookup?",
    placeholder: "Zoomen naar adres ..."
  },
  map: {
    style: "standaard",
    center: {
      latitude: 52.093249,
      longitude: 5.111994
    },
    zoom: 8,
    attribution: !0,
    extent: [-180, -90, 180, 90],
    zoomposition: "topleft"
  },
  marker: {
    url: "https://rawgit.com/geo-frontend/nlmaps/master/dist/assets/img/marker_icon.svg",
    iconSize: [64, 64],
    iconAnchor: [32, 64]
  },
  classnames: {
    geocoderContainer: ["nlmaps-geocoder-control-container"],
    geocoderSearch: ["nlmaps-geocoder-control-search"],
    geocoderButton: ["nlmaps-geocoder-control-button"],
    geocoderResultList: ["nlmaps-geocoder-result-list"],
    geocoderResultItem: ["nlmaps-geocoder-result-item"],
    geocoderResultSelected: ["nlmaps-geocoder-result-selected"]
  }
}, tt = {};
tt.BASE_DEFAULTS = {
  crs: "EPSG:3857",
  attr: "",
  minZoom: 0,
  maxZoom: 19,
  type: "wmts",
  format: "png",
  url: ""
};
tt.WMS_DEFAULTS = {
  url: "",
  version: "1.1.1",
  transparent: !0,
  format: "image/png",
  minZoom: 0,
  maxZoom: 24,
  styleName: ""
};
tt.BASEMAP_PROVIDERS = {};
tt.WMS_PROVIDERS = {};
tt.GEOCODER = {};
tt.MAP = {
  zoomposition: "bottomleft"
};
tt.MARKER = {};
tt.CLASSNAMES = {
  geocoderContainer: ["nlmaps-geocoder-control-container"],
  geocoderSearch: ["nlmaps-geocoder-control-search"],
  geocoderButton: ["nlmaps-geocoder-control-button"],
  geocoderResultList: ["nlmaps-geocoder-result-list"],
  geocoderResultItem: ["nlmaps-geocoder-result-item"]
};
function Sc(Me) {
  throw Me;
}
function Ua(Me, Ee) {
  return Object.assign({}, Me, Ee);
}
function of(Me) {
  let Ee = Ua(tt.BASE_DEFAULTS, Me.defaults);
  (!Me.layers || Me.layers.length < 0) && Sc("no basemap defined, please define a basemap in the configuration"), Me.layers.forEach((Ne) => {
    (!Ne.name || tt.BASEMAP_PROVIDERS[Ne.name] !== void 0) && Sc("basemap names need to be defined and unique: " + Ne.name), tt.BASEMAP_PROVIDERS[Ne.name] = uf(
      Ua(Ee, Ne)
    );
  });
}
function lf(Me) {
  let Ee = Ua(tt.WMS_DEFAULTS, Me.defaults);
  Me.layers && Me.layers.forEach((Ne) => {
    (!Ne.name || tt.WMS_PROVIDERS[Ne.name] !== void 0) && Sc("wms names need to be defined and unique: " + Ne.name), tt.WMS_PROVIDERS[Ne.name] = df(
      Ua(Ee, Ne)
    );
  });
}
function cf(Me) {
  tt.GEOCODER.lookupUrl = Me.lookupUrl, tt.GEOCODER.suggestUrl = Me.suggestUrl, tt.GEOCODER.placeholder = Me.placeholder;
}
function hf(Me) {
  tt.MAP = Ua(tt.MAP, Me);
}
function uf(Me) {
  switch (Me.type) {
    case "wmts":
      Me.url = `${Me.url}/${Me.layerName}/${Me.crs}/{z}/{x}/{y}.${Me.format}`;
      break;
    case "tms":
      Me.url = `${Me.url}/${Me.layerName}/{z}/{x}/{y}.${Me.format}`;
      break;
    default:
      Me.url = `${Me.url}/${Me.type}/${Me.layerName}/${Me.crs}/{z}/{x}/{y}.${Me.format}`;
  }
  return Me;
}
function df(Me) {
  let Ee = Me.url.indexOf("{");
  if (Ee > -1) {
    let Ne = Me.url.indexOf("}");
    Me.url.slice(Ee + 1, Ne).toLowerCase() === "workspacename" ? Me.url = Me.url.slice(0, Ee) + Me.workSpaceName + Me.url.slice(Ne + 1, -1) : Sc("only workspacename templates are supported for now");
  }
  return Me;
}
function pf(Me) {
  tt.FEATUREQUERYBASEURL = Me;
}
function ff(Me) {
  tt.CLASSNAMES = Ua(tt.CLASSNAMES, Me);
}
function mf(Me) {
  tt.MARKER = Me;
}
nr.featureQuery !== void 0 && pf(nr.featureQuery.baseUrl);
nr.map !== void 0 && hf(nr.map);
of(nr.basemaps);
nr.wms !== void 0 && lf(nr.wms);
nr.geocoder !== void 0 && cf(nr.geocoder);
nr.marker !== void 0 && mf(nr.marker);
nr.classnames !== void 0 && ff(nr.classnames);
const $i = tt.GEOCODER;
function wd(Me) {
  return new Promise((Ee, Ne) => {
    var et = new XMLHttpRequest();
    et.onreadystatechange = function() {
      et.readyState == 4 && et.status == 200 && Ee(JSON.parse(et.responseText));
    }, et.open("GET", Me, !0), et.send(null);
  });
}
function vd(Me) {
  if (!Me.includes("POINT"))
    throw TypeError("Provided WKT geometry is not a point.");
  const Ee = Me.split("(")[1].split(")")[0], Ne = parseFloat(Ee.split(" ")[0]), et = parseFloat(Ee.split(" ")[1]);
  return {
    type: "Point",
    coordinates: [Ne, et]
  };
}
$i.resultList = [];
$i.selectedResult = -1;
$i.doSuggestRequest = function(Me) {
  return wd(`${this.suggestUrl}q=${encodeURIComponent(Me)}`);
};
$i.doLookupRequest = function(Me) {
  return wd(`${this.lookupUrl}id=${encodeURIComponent(Me)}`).then((Ee) => {
    const Ne = Ee.response.docs[0];
    return Ne.centroide_ll = vd(Ne.centroide_ll), Ne.centroide_rd = vd(Ne.centroide_rd), Ne;
  });
};
$i.createControl = function(Me, Ee) {
  this.zoomTo = Me, this.map = Ee;
  const Ne = document.createElement("div"), et = document.createElement("form"), mt = document.createElement("input"), qr = document.createElement("button"), z = document.createElement("div");
  return ul(Ne, tt.CLASSNAMES.geocoderContainer), ul(et, tt.CLASSNAMES.geocoderSearch), Ne.addEventListener("click", (c) => c.stopPropagation()), Ne.addEventListener("dblclick", (c) => c.stopPropagation()), mt.id = "nlmaps-geocoder-control-input", mt.placeholder = $i.placeholder, mt.setAttribute("aria-label", $i.placeholder), mt.setAttribute("type", "text"), mt.setAttribute("autocapitalize", "off"), mt.setAttribute("autocomplete", "off"), mt.setAttribute("autocorrect", "off"), mt.setAttribute("spellcheck", "false"), mt.addEventListener("keydown", (c) => {
    let fi = this.resultList;
    this.resultList.length > 0 && ((c.code === "ArrowDown" || c.keyCode === 40) && (this.selectedResult < this.resultList.length - 1 && this.selectedResult++, this.showLookupResult(fi[this.selectedResult])), (c.code === "ArrowUp" || c.keyCode === 38) && (this.selectedResult > 0 && this.selectedResult--, this.showLookupResult(fi[this.selectedResult])), c.code === "Escape" && this.clearSuggestResults(!0));
  }), mt.addEventListener("input", (c) => {
    this.suggest(c.target.value);
  }), mt.addEventListener("focus", (c) => {
    this.suggest(c.target.value);
  }), qr.setAttribute("type", "submit"), et.addEventListener("submit", (c) => {
    c.preventDefault(), this.resultList.length > 0 && this.lookup(this.resultList[this.selectedResult < 0 ? 0 : this.selectedResult].id);
  }), qr.setAttribute("aria-label", $i.placeholder), ul(qr, tt.CLASSNAMES.geocoderButton), z.id = "nlmaps-geocoder-control-results", ul(z, tt.CLASSNAMES.geocoderResultList), z.classList.add("nlmaps-hidden"), Ne.appendChild(et), et.appendChild(mt), et.appendChild(qr), Ne.appendChild(z), Ne;
};
$i.suggest = function(Me) {
  if (Me.length < 3) {
    this.clearSuggestResults();
    return;
  }
  this.doSuggestRequest(Me).then((Ee) => {
    this.resultList = Ee.response.docs, this.showSuggestResults(this.resultList);
  });
};
$i.lookup = function(Me) {
  this.doLookupRequest(Me).then((Ee) => {
    this.zoomTo(Ee.centroide_ll, this.map), this.showLookupResult(Ee), this.clearSuggestResults();
  });
};
$i.clearSuggestResults = function(Me) {
  this.selectedResult = -1, Me && (document.getElementById("nlmaps-geocoder-control-input").value = ""), document.getElementById("nlmaps-geocoder-control-results").innerHTML = "", document.getElementById("nlmaps-geocoder-control-results").classList.add("nlmaps-hidden");
};
$i.showLookupResult = function(Me) {
  let Ee = document.getElementsByClassName(tt.CLASSNAMES.geocoderResultItem);
  Array.prototype.map.call(Ee, (et) => et.classList.remove(tt.CLASSNAMES.geocoderResultSelected));
  let Ne = document.getElementById(Me.id);
  Ne && Ne.classList.add(tt.CLASSNAMES.geocoderResultSelected), document.getElementById("nlmaps-geocoder-control-input").value = Me.weergavenaam;
};
function ul(Me, Ee) {
  Ee.forEach((Ne) => {
    Me.classList.add(Ne);
  });
}
$i.showSuggestResults = function(Me) {
  if (this.clearSuggestResults(), Me.length > 0) {
    const Ee = document.createElement("ul");
    Me.forEach((Ne) => {
      const et = document.createElement("li"), mt = document.createElement("a");
      mt.innerHTML = Ne.weergavenaam, mt.id = Ne.id, ul(mt, tt.CLASSNAMES.geocoderResultItem), mt.setAttribute("href", "#"), mt.addEventListener("click", (qr) => {
        qr.preventDefault(), this.lookup(qr.target.id);
      }), et.appendChild(mt), Ee.appendChild(et);
    }), document.getElementById("nlmaps-geocoder-control-results").classList.remove("nlmaps-hidden"), document.getElementById("nlmaps-geocoder-control-results").appendChild(Ee);
  }
};
function _f() {
  return tt.MARKER;
}
function gf(Me) {
  if (Me in tt.BASEMAP_PROVIDERS) {
    var Ee = tt.BASEMAP_PROVIDERS[Me];
    return Ee.deprecated && console && console.warn && console.warn(Me + " is a deprecated style; it will be redirected to its replacement. For performance improvements, please change your reference."), Ee;
  } else
    console.error("NL Maps error: You asked for a style which does not exist! Available styles: " + Object.keys(tt.BASEMAP_PROVIDERS).join(", "));
}
function yf(Me, Ee) {
  let Ne;
  return Me in tt.WMS_PROVIDERS ? (Ne = tt.WMS_PROVIDERS[Me], Ne.deprecated && console && console.warn && console.warn(Me + " is a deprecated wms; it will be redirected to its replacement. For performance improvements, please change your reference.")) : (Ne = Object.assign({}, tt.WMS_DEFAULTS, Ee), console.log(
    "NL Maps: You asked for a wms which does not exist! Available wmses: " + Object.keys(tt.WMS_PROVIDERS).join(", ") + ". Provide an options object to make your own WMS."
  )), Ne;
}
var Pc = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.2.0/LICENSE.txt
 */
var xf = Pc.exports, bd;
function vf() {
  return bd || (bd = 1, function(Me, Ee) {
    (function(Ne, et) {
      Me.exports = et();
    })(xf, function() {
      var Ne = {}, et = {};
      function mt(z, c, fi) {
        if (et[z] = fi, z === "index") {
          var Mr = "var sharedModule = {}; (" + et.shared + ")(sharedModule); (" + et.worker + ")(sharedModule);", ki = {};
          return et.shared(ki), et.index(Ne, ki), typeof window < "u" && Ne.setWorkerUrl(window.URL.createObjectURL(new Blob([Mr], { type: "text/javascript" }))), Ne;
        }
      }
      mt("shared", ["exports"], function(z) {
        function c(r, t, n, s) {
          return new (n || (n = Promise))(function(l, d) {
            function p(x) {
              try {
                g(s.next(x));
              } catch (b) {
                d(b);
              }
            }
            function m(x) {
              try {
                g(s.throw(x));
              } catch (b) {
                d(b);
              }
            }
            function g(x) {
              var b;
              x.done ? l(x.value) : (b = x.value, b instanceof n ? b : new n(function(w) {
                w(b);
              })).then(p, m);
            }
            g((s = s.apply(r, t || [])).next());
          });
        }
        function fi(r) {
          return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
        }
        var Mr, ki;
        function Ir() {
          if (ki) return Mr;
          function r(t, n) {
            this.x = t, this.y = n;
          }
          return ki = 1, Mr = r, r.prototype = { clone: function() {
            return new r(this.x, this.y);
          }, add: function(t) {
            return this.clone()._add(t);
          }, sub: function(t) {
            return this.clone()._sub(t);
          }, multByPoint: function(t) {
            return this.clone()._multByPoint(t);
          }, divByPoint: function(t) {
            return this.clone()._divByPoint(t);
          }, mult: function(t) {
            return this.clone()._mult(t);
          }, div: function(t) {
            return this.clone()._div(t);
          }, rotate: function(t) {
            return this.clone()._rotate(t);
          }, rotateAround: function(t, n) {
            return this.clone()._rotateAround(t, n);
          }, matMult: function(t) {
            return this.clone()._matMult(t);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t) {
            return this.x === t.x && this.y === t.y;
          }, dist: function(t) {
            return Math.sqrt(this.distSqr(t));
          }, distSqr: function(t) {
            var n = t.x - this.x, s = t.y - this.y;
            return n * n + s * s;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t) {
            return Math.atan2(this.y - t.y, this.x - t.x);
          }, angleWith: function(t) {
            return this.angleWithSep(t.x, t.y);
          }, angleWithSep: function(t, n) {
            return Math.atan2(this.x * n - this.y * t, this.x * t + this.y * n);
          }, _matMult: function(t) {
            var n = t[2] * this.x + t[3] * this.y;
            return this.x = t[0] * this.x + t[1] * this.y, this.y = n, this;
          }, _add: function(t) {
            return this.x += t.x, this.y += t.y, this;
          }, _sub: function(t) {
            return this.x -= t.x, this.y -= t.y, this;
          }, _mult: function(t) {
            return this.x *= t, this.y *= t, this;
          }, _div: function(t) {
            return this.x /= t, this.y /= t, this;
          }, _multByPoint: function(t) {
            return this.x *= t.x, this.y *= t.y, this;
          }, _divByPoint: function(t) {
            return this.x /= t.x, this.y /= t.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t = this.y;
            return this.y = this.x, this.x = -t, this;
          }, _rotate: function(t) {
            var n = Math.cos(t), s = Math.sin(t), l = s * this.x + n * this.y;
            return this.x = n * this.x - s * this.y, this.y = l, this;
          }, _rotateAround: function(t, n) {
            var s = Math.cos(t), l = Math.sin(t), d = n.y + l * (this.x - n.x) + s * (this.y - n.y);
            return this.x = n.x + s * (this.x - n.x) - l * (this.y - n.y), this.y = d, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, r.convert = function(t) {
            return t instanceof r ? t : Array.isArray(t) ? new r(t[0], t[1]) : t;
          }, Mr;
        }
        typeof SuppressedError == "function" && SuppressedError;
        var He, ue, Ue = fi(Ir()), Wr = function() {
          if (ue) return He;
          function r(t, n, s, l) {
            this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (l - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = s, this.p2y = l;
          }
          return ue = 1, He = r, r.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var s = t, l = 0; l < 8; l++) {
              var d = this.sampleCurveX(s) - t;
              if (Math.abs(d) < n) return s;
              var p = this.sampleCurveDerivativeX(s);
              if (Math.abs(p) < 1e-6) break;
              s -= d / p;
            }
            var m = 0, g = 1;
            for (s = t, l = 0; l < 20 && (d = this.sampleCurveX(s), !(Math.abs(d - t) < n)); l++) t > d ? m = s : g = s, s = 0.5 * (g - m) + m;
            return s;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, He;
        }(), Cr = fi(Wr);
        let Hr, Xr;
        function ns() {
          return Hr == null && (Hr = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), Hr;
        }
        function mi() {
          if (Xr == null && (Xr = !1, ns())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (t) {
              for (let s = 0; s < 5 * 5; s++) {
                const l = 4 * s;
                t.fillStyle = `rgb(${l},${l + 1},${l + 2})`, t.fillRect(s % 5, Math.floor(s / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let s = 0; s < 5 * 5 * 4; s++) if (s % 4 != 3 && n[s] !== s) {
                Xr = !0;
                break;
              }
            }
          }
          return Xr || !1;
        }
        var Er, Mt = 1e-6, bt = typeof Float32Array < "u" ? Float32Array : Array;
        function zt() {
          var r = new bt(9);
          return bt != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
        }
        function ss(r) {
          return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
        }
        function Bs() {
          var r = new bt(3);
          return bt != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
        }
        function Ar(r, t, n) {
          var s = new bt(3);
          return s[0] = r, s[1] = t, s[2] = n, s;
        }
        function fr(r, t, n) {
          var s = t[0], l = t[1], d = t[2], p = t[3];
          return r[0] = n[0] * s + n[4] * l + n[8] * d + n[12] * p, r[1] = n[1] * s + n[5] * l + n[9] * d + n[13] * p, r[2] = n[2] * s + n[6] * l + n[10] * d + n[14] * p, r[3] = n[3] * s + n[7] * l + n[11] * d + n[15] * p, r;
        }
        function Di() {
          var r = new bt(4);
          return bt != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
        }
        function li() {
          var r = new bt(2);
          return bt != Float32Array && (r[0] = 0, r[1] = 0), r;
        }
        function as(r, t) {
          var n = new bt(2);
          return n[0] = r, n[1] = t, n;
        }
        Math.hypot || (Math.hypot = function() {
          for (var r = 0, t = arguments.length; t--; ) r += arguments[t] * arguments[t];
          return Math.sqrt(r);
        }), Bs(), Er = new bt(4), bt != Float32Array && (Er[0] = 0, Er[1] = 0, Er[2] = 0, Er[3] = 0), Bs(), Ar(1, 0, 0), Ar(0, 1, 0), Di(), Di(), zt(), li();
        const ht = 8192;
        function Cn(r, t, n) {
          return t * (ht / (r.tileSize * Math.pow(2, n - r.tileID.overscaledZ)));
        }
        function zr(r, t) {
          return (r % t + t) % t;
        }
        function Kr(r, t, n) {
          return r * (1 - n) + t * n;
        }
        function Jr(r) {
          if (r <= 0) return 0;
          if (r >= 1) return 1;
          const t = r * r, n = t * r;
          return 4 * (r < 0.5 ? n : 3 * (r - t) + n - 0.75);
        }
        function En(r, t, n, s) {
          const l = new Cr(r, t, n, s);
          return (d) => l.solve(d);
        }
        const sr = En(0.25, 0.1, 0.25, 1);
        function qi(r, t, n) {
          return Math.min(n, Math.max(t, r));
        }
        function Ri(r, t, n) {
          const s = n - t, l = ((r - t) % s + s) % s + t;
          return l === t ? n : l;
        }
        function ii(r, ...t) {
          for (const n of t) for (const s in n) r[s] = n[s];
          return r;
        }
        let Yr = 1;
        function Qr(r, t, n) {
          const s = {};
          for (const l in r) s[l] = t.call(this, r[l], l, r);
          return s;
        }
        function en(r, t, n) {
          const s = {};
          for (const l in r) t.call(this, r[l], l, r) && (s[l] = r[l]);
          return s;
        }
        function Pi(r) {
          return Array.isArray(r) ? r.map(Pi) : typeof r == "object" && r ? Qr(r, Pi) : r;
        }
        const os = {};
        function ci(r) {
          os[r] || (typeof console < "u" && console.warn(r), os[r] = !0);
        }
        function Vt(r, t, n) {
          return (n.y - r.y) * (t.x - r.x) > (t.y - r.y) * (n.x - r.x);
        }
        function mr(r) {
          return typeof WorkerGlobalScope < "u" && r !== void 0 && r instanceof WorkerGlobalScope;
        }
        let Dt = null;
        function tn(r) {
          return typeof ImageBitmap < "u" && r instanceof ImageBitmap;
        }
        const rn = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Wi(r, t, n, s, l) {
          return c(this, void 0, void 0, function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const d = new VideoFrame(r, { timestamp: 0 });
            try {
              const p = d == null ? void 0 : d.format;
              if (!p || !p.startsWith("BGR") && !p.startsWith("RGB")) throw new Error(`Unrecognized format ${p}`);
              const m = p.startsWith("BGR"), g = new Uint8ClampedArray(s * l * 4);
              if (yield d.copyTo(g, function(x, b, w, I, E) {
                const A = 4 * Math.max(1, 0), D = (Math.max(0, w) - w) * I * 4 + A, F = 4 * I, Z = Math.max(0, b), Y = Math.max(0, w);
                return { rect: { x: Z, y: Y, width: Math.min(x.width, b + I) - Z, height: Math.min(x.height, w + E) - Y }, layout: [{ offset: D, stride: F }] };
              }(r, t, n, s, l)), m) for (let x = 0; x < g.length; x += 4) {
                const b = g[x];
                g[x] = g[x + 2], g[x + 2] = b;
              }
              return g;
            } finally {
              d.close();
            }
          });
        }
        let kr, Dr;
        function ar(r, t, n, s) {
          return r.addEventListener(t, n, s), { unsubscribe: () => {
            r.removeEventListener(t, n, s);
          } };
        }
        function Hi(r) {
          return r / Math.PI * 180;
        }
        const An = "AbortError";
        function nn() {
          return new Error(An);
        }
        const sn = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function zn(r) {
          return sn.REGISTERED_PROTOCOLS[r.substring(0, r.indexOf("://"))];
        }
        const an = "global-dispatcher";
        class _r extends Error {
          constructor(t, n, s, l) {
            super(`AJAXError: ${n} (${t}): ${s}`), this.status = t, this.statusText = n, this.url = s, this.body = l;
          }
        }
        const gr = () => mr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Rr = function(r, t) {
          if (/:\/\//.test(r.url) && !/^https?:|^file:/.test(r.url)) {
            const s = zn(r.url);
            if (s) return s(r, t);
            if (mr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, targetMapId: an }, t);
          }
          if (!(/^file:/.test(n = r.url) || /^file:/.test(gr()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(s, l) {
              return c(this, void 0, void 0, function* () {
                const d = new Request(s.url, { method: s.method || "GET", body: s.body, credentials: s.credentials, headers: s.headers, cache: s.cache, referrer: gr(), signal: l.signal });
                let p, m;
                s.type !== "json" || d.headers.has("Accept") || d.headers.set("Accept", "application/json");
                try {
                  p = yield fetch(d);
                } catch (x) {
                  throw new _r(0, x.message, s.url, new Blob());
                }
                if (!p.ok) {
                  const x = yield p.blob();
                  throw new _r(p.status, p.statusText, s.url, x);
                }
                m = s.type === "arrayBuffer" || s.type === "image" ? p.arrayBuffer() : s.type === "json" ? p.json() : p.text();
                const g = yield m;
                if (l.signal.aborted) throw nn();
                return { data: g, cacheControl: p.headers.get("Cache-Control"), expires: p.headers.get("Expires") };
              });
            }(r, t);
            if (mr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, mustQueue: !0, targetMapId: an }, t);
          }
          var n;
          return function(s, l) {
            return new Promise((d, p) => {
              var m;
              const g = new XMLHttpRequest();
              g.open(s.method || "GET", s.url, !0), s.type !== "arrayBuffer" && s.type !== "image" || (g.responseType = "arraybuffer");
              for (const x in s.headers) g.setRequestHeader(x, s.headers[x]);
              s.type === "json" && (g.responseType = "text", !((m = s.headers) === null || m === void 0) && m.Accept || g.setRequestHeader("Accept", "application/json")), g.withCredentials = s.credentials === "include", g.onerror = () => {
                p(new Error(g.statusText));
              }, g.onload = () => {
                if (!l.signal.aborted) if ((g.status >= 200 && g.status < 300 || g.status === 0) && g.response !== null) {
                  let x = g.response;
                  if (s.type === "json") try {
                    x = JSON.parse(g.response);
                  } catch (b) {
                    return void p(b);
                  }
                  d({ data: x, cacheControl: g.getResponseHeader("Cache-Control"), expires: g.getResponseHeader("Expires") });
                } else {
                  const x = new Blob([g.response], { type: g.getResponseHeader("Content-Type") });
                  p(new _r(g.status, g.statusText, s.url, x));
                }
              }, l.signal.addEventListener("abort", () => {
                g.abort(), p(nn());
              }), g.send(s.body);
            });
          }(r, t);
        };
        function Lr(r) {
          if (!r || r.indexOf("://") <= 0 || r.indexOf("data:image/") === 0 || r.indexOf("blob:") === 0) return !0;
          const t = new URL(r), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function ls(r, t, n) {
          n[r] && n[r].indexOf(t) !== -1 || (n[r] = n[r] || [], n[r].push(t));
        }
        function kn(r, t, n) {
          if (n && n[r]) {
            const s = n[r].indexOf(t);
            s !== -1 && n[r].splice(s, 1);
          }
        }
        class cs {
          constructor(t, n = {}) {
            ii(this, n), this.type = t;
          }
        }
        class yr extends cs {
          constructor(t, n = {}) {
            super("error", ii({ error: t }, n));
          }
        }
        class ie {
          on(t, n) {
            return this._listeners = this._listeners || {}, ls(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return kn(t, n, this._listeners), kn(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ls(t, n, this._oneTimeListeners), this) : new Promise((s) => this.once(t, s));
          }
          fire(t, n) {
            typeof t == "string" && (t = new cs(t, n || {}));
            const s = t.type;
            if (this.listens(s)) {
              t.target = this;
              const l = this._listeners && this._listeners[s] ? this._listeners[s].slice() : [];
              for (const m of l) m.call(this, t);
              const d = this._oneTimeListeners && this._oneTimeListeners[s] ? this._oneTimeListeners[s].slice() : [];
              for (const m of d) kn(s, m, this._oneTimeListeners), m.call(this, t);
              const p = this._eventedParent;
              p && (ii(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), p.fire(t));
            } else t instanceof yr && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var P = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const L = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function O(r, t) {
          const n = {};
          for (const s in r) s !== "ref" && (n[s] = r[s]);
          return L.forEach((s) => {
            s in t && (n[s] = t[s]);
          }), n;
        }
        function U(r, t) {
          if (Array.isArray(r)) {
            if (!Array.isArray(t) || r.length !== t.length) return !1;
            for (let n = 0; n < r.length; n++) if (!U(r[n], t[n])) return !1;
            return !0;
          }
          if (typeof r == "object" && r !== null && t !== null) {
            if (typeof t != "object" || Object.keys(r).length !== Object.keys(t).length) return !1;
            for (const n in r) if (!U(r[n], t[n])) return !1;
            return !0;
          }
          return r === t;
        }
        function X(r, t) {
          r.push(t);
        }
        function te(r, t, n) {
          X(n, { command: "addSource", args: [r, t[r]] });
        }
        function le(r, t, n) {
          X(t, { command: "removeSource", args: [r] }), n[r] = !0;
        }
        function ee(r, t, n, s) {
          le(r, n, s), te(r, t, n);
        }
        function me(r, t, n) {
          let s;
          for (s in r[n]) if (Object.prototype.hasOwnProperty.call(r[n], s) && s !== "data" && !U(r[n][s], t[n][s])) return !1;
          for (s in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], s) && s !== "data" && !U(r[n][s], t[n][s])) return !1;
          return !0;
        }
        function he(r, t, n, s, l, d) {
          r = r || {}, t = t || {};
          for (const p in r) Object.prototype.hasOwnProperty.call(r, p) && (U(r[p], t[p]) || n.push({ command: d, args: [s, p, t[p], l] }));
          for (const p in t) Object.prototype.hasOwnProperty.call(t, p) && !Object.prototype.hasOwnProperty.call(r, p) && (U(r[p], t[p]) || n.push({ command: d, args: [s, p, t[p], l] }));
        }
        function re(r) {
          return r.id;
        }
        function xe(r, t) {
          return r[t.id] = t, r;
        }
        class ne {
          constructor(t, n, s, l) {
            this.message = (t ? `${t}: ` : "") + s, l && (this.identifier = l), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function Ce(r, ...t) {
          for (const n of t) for (const s in n) r[s] = n[s];
          return r;
        }
        class Be extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class We {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [s, l] of n) this.bindings[s] = l;
          }
          concat(t) {
            return new We(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const $e = { kind: "null" }, ye = { kind: "number" }, De = { kind: "string" }, ke = { kind: "boolean" }, Ke = { kind: "color" }, qe = { kind: "projectionDefinition" }, Je = { kind: "object" }, je = { kind: "value" }, on = { kind: "collator" }, Ft = { kind: "formatted" }, Nt = { kind: "padding" }, yt = { kind: "resolvedImage" }, Fs = { kind: "variableAnchorOffsetCollection" };
        function yi(r, t) {
          return { kind: "array", itemType: r, N: t };
        }
        function pt(r) {
          if (r.kind === "array") {
            const t = pt(r.itemType);
            return typeof r.N == "number" ? `array<${t}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return r.kind;
        }
        const dl = [$e, ye, De, ke, Ke, qe, Ft, Je, yi(je), Nt, yt, Fs];
        function hs(r, t) {
          if (t.kind === "error") return null;
          if (r.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !hs(r.itemType, t.itemType)) && (typeof r.N != "number" || r.N === t.N)) return null;
          } else {
            if (r.kind === t.kind) return null;
            if (r.kind === "value") {
              for (const n of dl) if (!hs(n, t)) return null;
            }
          }
          return `Expected ${pt(r)} but found ${pt(t)} instead.`;
        }
        function Ga(r, t) {
          return t.some((n) => n.kind === r.kind);
        }
        function Br(r, t) {
          return t.some((n) => n === "null" ? r === null : n === "array" ? Array.isArray(r) : n === "object" ? r && !Array.isArray(r) && typeof r == "object" : n === typeof r);
        }
        function Dn(r, t) {
          return r.kind === "array" && t.kind === "array" ? r.itemType.kind === t.itemType.kind && typeof r.N == "number" : r.kind === t.kind;
        }
        const $a = 0.96422, pl = 0.82521, fl = 4 / 29, Rn = 6 / 29, ml = 3 * Rn * Rn, Mc = Rn * Rn * Rn, Ic = Math.PI / 180, Cc = 180 / Math.PI;
        function qa(r) {
          return (r %= 360) < 0 && (r += 360), r;
        }
        function Ln([r, t, n, s]) {
          let l, d;
          const p = Ha((0.2225045 * (r = Wa(r)) + 0.7168786 * (t = Wa(t)) + 0.0606169 * (n = Wa(n))) / 1);
          r === t && t === n ? l = d = p : (l = Ha((0.4360747 * r + 0.3850649 * t + 0.1430804 * n) / $a), d = Ha((0.0139322 * r + 0.0971045 * t + 0.7141733 * n) / pl));
          const m = 116 * p - 16;
          return [m < 0 ? 0 : m, 500 * (l - p), 200 * (p - d), s];
        }
        function Wa(r) {
          return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        }
        function Ha(r) {
          return r > Mc ? Math.pow(r, 1 / 3) : r / ml + fl;
        }
        function Bn([r, t, n, s]) {
          let l = (r + 16) / 116, d = isNaN(t) ? l : l + t / 500, p = isNaN(n) ? l : l - n / 200;
          return l = 1 * Ka(l), d = $a * Ka(d), p = pl * Ka(p), [Xa(3.1338561 * d - 1.6168667 * l - 0.4906146 * p), Xa(-0.9787684 * d + 1.9161415 * l + 0.033454 * p), Xa(0.0719453 * d - 0.2289914 * l + 1.4052427 * p), s];
        }
        function Xa(r) {
          return (r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055) < 0 ? 0 : r > 1 ? 1 : r;
        }
        function Ka(r) {
          return r > Rn ? r * r * r : ml * (r - fl);
        }
        function Os(r) {
          return parseInt(r.padEnd(2, r), 16) / 255;
        }
        function Ja(r, t) {
          return ln(t ? r / 100 : r, 0, 1);
        }
        function ln(r, t, n) {
          return Math.min(Math.max(t, r), n);
        }
        function Xi(r) {
          return !r.some(Number.isNaN);
        }
        const nt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Si(r, t, n) {
          return r + n * (t - r);
        }
        function Li(r, t, n) {
          return r.map((s, l) => Si(s, t[l], n));
        }
        class st {
          constructor(t, n, s, l = 1, d = !0) {
            this.r = t, this.g = n, this.b = s, this.a = l, d || (this.r *= l, this.g *= l, this.b *= l, l || this.overwriteGetter("rgb", [t, n, s, l]));
          }
          static parse(t) {
            if (t instanceof st) return t;
            if (typeof t != "string") return;
            const n = function(s) {
              if ((s = s.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const l = nt[s];
              if (l) {
                const [p, m, g] = l;
                return [p / 255, m / 255, g / 255, 1];
              }
              if (s.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(s)) {
                const p = s.length < 6 ? 1 : 2;
                let m = 1;
                return [Os(s.slice(m, m += p)), Os(s.slice(m, m += p)), Os(s.slice(m, m += p)), Os(s.slice(m, m + p) || "ff")];
              }
              if (s.startsWith("rgb")) {
                const p = s.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (p) {
                  const [m, g, x, b, w, I, E, A, D, F, Z, Y] = p, $ = [b || " ", E || " ", F].join("");
                  if ($ === "  " || $ === "  /" || $ === ",," || $ === ",,,") {
                    const C = [x, I, D].join(""), B = C === "%%%" ? 100 : C === "" ? 255 : 0;
                    if (B) {
                      const q = [ln(+g / B, 0, 1), ln(+w / B, 0, 1), ln(+A / B, 0, 1), Z ? Ja(+Z, Y) : 1];
                      if (Xi(q)) return q;
                    }
                  }
                  return;
                }
              }
              const d = s.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (d) {
                const [p, m, g, x, b, w, I, E, A] = d, D = [g || " ", b || " ", I].join("");
                if (D === "  " || D === "  /" || D === ",," || D === ",,,") {
                  const F = [+m, ln(+x, 0, 100), ln(+w, 0, 100), E ? Ja(+E, A) : 1];
                  if (Xi(F)) return function([Z, Y, $, C]) {
                    function B(q) {
                      const ae = (q + Z / 30) % 12, ve = Y * Math.min($, 1 - $);
                      return $ - ve * Math.max(-1, Math.min(ae - 3, 9 - ae, 1));
                    }
                    return Z = qa(Z), Y /= 100, $ /= 100, [B(0), B(8), B(4), C];
                  }(F);
                }
              }
            }(t);
            return n ? new st(...n, !1) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: s, a: l } = this, d = l || 1 / 0;
            return this.overwriteGetter("rgb", [t / d, n / d, s / d, l]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t) {
              const [n, s, l, d] = Ln(t), p = Math.sqrt(s * s + l * l);
              return [Math.round(1e4 * p) ? qa(Math.atan2(l, s) * Cc) : NaN, p, n, d];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Ln(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, s, l] = this.rgb;
            return `rgba(${[t, n, s].map((d) => Math.round(255 * d)).join(",")},${l})`;
          }
          static interpolate(t, n, s, l = "rgb") {
            switch (l) {
              case "rgb": {
                const [d, p, m, g] = Li(t.rgb, n.rgb, s);
                return new st(d, p, m, g, !1);
              }
              case "hcl": {
                const [d, p, m, g] = t.hcl, [x, b, w, I] = n.hcl;
                let E, A;
                if (isNaN(d) || isNaN(x)) isNaN(d) ? isNaN(x) ? E = NaN : (E = x, m !== 1 && m !== 0 || (A = b)) : (E = d, w !== 1 && w !== 0 || (A = p));
                else {
                  let $ = x - d;
                  x > d && $ > 180 ? $ -= 360 : x < d && d - x > 180 && ($ += 360), E = d + s * $;
                }
                const [D, F, Z, Y] = function([$, C, B, q]) {
                  return $ = isNaN($) ? 0 : $ * Ic, Bn([B, Math.cos($) * C, Math.sin($) * C, q]);
                }([E, A ?? Si(p, b, s), Si(m, w, s), Si(g, I, s)]);
                return new st(D, F, Z, Y, !1);
              }
              case "lab": {
                const [d, p, m, g] = Bn(Li(t.lab, n.lab, s));
                return new st(d, p, m, g, !1);
              }
            }
          }
        }
        st.black = new st(0, 0, 0, 1), st.white = new st(1, 1, 1, 1), st.transparent = new st(0, 0, 0, 0), st.red = new st(1, 0, 0, 1);
        class js {
          constructor(t, n, s) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Ya = ["bottom", "center", "top"];
        class Bi {
          constructor(t, n, s, l, d, p) {
            this.text = t, this.image = n, this.scale = s, this.fontStack = l, this.textColor = d, this.verticalAlign = p;
          }
        }
        class ri {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new ri([new Bi(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
          }
          static factory(t) {
            return t instanceof ri ? t : ri.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
          }
        }
        class Ht {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Ht) return t;
            if (typeof t == "number") return new Ht([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new Ht(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, s) {
            return new Ht(Li(t.values, n.values, s));
          }
        }
        class It {
          constructor(t) {
            this.name = "ExpressionEvaluationError", this.message = t;
          }
          toJSON() {
            return this.message;
          }
        }
        const Qa = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Xt {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Xt) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const s = t[n], l = t[n + 1];
                if (typeof s != "string" || !Qa.has(s) || !Array.isArray(l) || l.length !== 2 || typeof l[0] != "number" || typeof l[1] != "number") return;
              }
              return new Xt(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, s) {
            const l = t.values, d = n.values;
            if (l.length !== d.length) throw new It(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const p = [];
            for (let m = 0; m < l.length; m += 2) {
              if (l[m] !== d[m]) throw new It(`Cannot interpolate values containing mismatched anchors. from[${m}]: ${l[m]}, to[${m}]: ${d[m]}`);
              p.push(l[m]);
              const [g, x] = l[m + 1], [b, w] = d[m + 1];
              p.push([Si(g, b, s), Si(x, w, s)]);
            }
            return new Xt(p);
          }
        }
        class _i {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new _i({ name: t, available: !1 }) : null;
          }
        }
        class xi {
          constructor(t, n, s) {
            this.from = t, this.to = n, this.transition = s;
          }
          static interpolate(t, n, s) {
            return new xi(t, n, s);
          }
          static parse(t) {
            return t instanceof xi ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new xi(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new xi(t.from, t.to, t.transition) : typeof t == "string" ? new xi(t, t, 1) : void 0;
          }
        }
        function Vs(r, t, n, s) {
          return typeof r == "number" && r >= 0 && r <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? s === void 0 || typeof s == "number" && s >= 0 && s <= 1 ? null : `Invalid rgba value [${[r, t, n, s].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof s == "number" ? [r, t, n, s] : [r, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ki(r) {
          if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof xi || r instanceof st || r instanceof js || r instanceof ri || r instanceof Ht || r instanceof Xt || r instanceof _i) return !0;
          if (Array.isArray(r)) {
            for (const t of r) if (!Ki(t)) return !1;
            return !0;
          }
          if (typeof r == "object") {
            for (const t in r) if (!Ki(r[t])) return !1;
            return !0;
          }
          return !1;
        }
        function Ot(r) {
          if (r === null) return $e;
          if (typeof r == "string") return De;
          if (typeof r == "boolean") return ke;
          if (typeof r == "number") return ye;
          if (r instanceof st) return Ke;
          if (r instanceof xi) return qe;
          if (r instanceof js) return on;
          if (r instanceof ri) return Ft;
          if (r instanceof Ht) return Nt;
          if (r instanceof Xt) return Fs;
          if (r instanceof _i) return yt;
          if (Array.isArray(r)) {
            const t = r.length;
            let n;
            for (const s of r) {
              const l = Ot(s);
              if (n) {
                if (n === l) continue;
                n = je;
                break;
              }
              n = l;
            }
            return yi(n || je, t);
          }
          return Je;
        }
        function Fr(r) {
          const t = typeof r;
          return r === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(r) : r instanceof st || r instanceof xi || r instanceof ri || r instanceof Ht || r instanceof Xt || r instanceof _i ? r.toString() : JSON.stringify(r);
        }
        class Fi {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!Ki(t[1])) return n.error("invalid value");
            const s = t[1];
            let l = Ot(s);
            const d = n.expectedType;
            return l.kind !== "array" || l.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (l = d), new Fi(l, s);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const us = { string: De, number: ye, boolean: ke, object: Je };
        class Oi {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let s, l = 1;
            const d = t[0];
            if (d === "array") {
              let m, g;
              if (t.length > 2) {
                const x = t[1];
                if (typeof x != "string" || !(x in us) || x === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                m = us[x], l++;
              } else m = je;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                g = t[2], l++;
              }
              s = yi(m, g);
            } else {
              if (!us[d]) throw new Error(`Types doesn't contain name = ${d}`);
              s = us[d];
            }
            const p = [];
            for (; l < t.length; l++) {
              const m = n.parse(t[l], l, je);
              if (!m) return null;
              p.push(m);
            }
            return new Oi(s, p);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const s = this.args[n].evaluate(t);
              if (!hs(this.type, Ot(s))) return s;
              if (n === this.args.length - 1) throw new It(`Expected value to be of type ${pt(this.type)}, but found ${pt(Ot(s))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        const eo = { "to-boolean": ke, "to-color": Ke, "to-number": ye, "to-string": De };
        class Ji {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const s = t[0];
            if (!eo[s]) throw new Error(`Can't parse ${s} as it is not part of the known types`);
            if ((s === "to-boolean" || s === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const l = eo[s], d = [];
            for (let p = 1; p < t.length; p++) {
              const m = n.parse(t[p], p, je);
              if (!m) return null;
              d.push(m);
            }
            return new Ji(l, d);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, s;
                for (const l of this.args) {
                  if (n = l.evaluate(t), s = null, n instanceof st) return n;
                  if (typeof n == "string") {
                    const d = t.parseColor(n);
                    if (d) return d;
                  } else if (Array.isArray(n) && (s = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Vs(n[0], n[1], n[2], n[3]), !s)) return new st(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new It(s || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const s of this.args) {
                  n = s.evaluate(t);
                  const l = Ht.parse(n);
                  if (l) return l;
                }
                throw new It(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const s of this.args) {
                  n = s.evaluate(t);
                  const l = Xt.parse(n);
                  if (l) return l;
                }
                throw new It(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const s of this.args) {
                  if (n = s.evaluate(t), n === null) return 0;
                  const l = Number(n);
                  if (!isNaN(l)) return l;
                }
                throw new It(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return ri.fromString(Fr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return _i.fromString(Fr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return Fr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        const wt = ["Unknown", "Point", "LineString", "Polygon"];
        class Ns {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? wt[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache[t];
            return n || (n = this._parseColorCache[t] = st.parse(t)), n;
          }
        }
        class it {
          constructor(t, n, s = [], l, d = new We(), p = []) {
            this.registry = t, this.path = s, this.key = s.map((m) => `[${m}]`).join(""), this.scope = d, this.errors = p, this.expectedType = l, this._isConstant = n;
          }
          parse(t, n, s, l, d = {}) {
            return n ? this.concat(n, s, l)._parse(t, d) : this._parse(t, d);
          }
          _parse(t, n) {
            function s(l, d, p) {
              return p === "assert" ? new Oi(d, [l]) : p === "coerce" ? new Ji(d, [l]) : l;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const l = t[0];
              if (typeof l != "string") return this.error(`Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const d = this.registry[l];
              if (d) {
                let p = d.parse(t, this);
                if (!p) return null;
                if (this.expectedType) {
                  const m = this.expectedType, g = p.type;
                  if (m.kind !== "string" && m.kind !== "number" && m.kind !== "boolean" && m.kind !== "object" && m.kind !== "array" || g.kind !== "value") if (m.kind !== "projectionDefinition" || g.kind !== "string" && g.kind !== "array") if (m.kind !== "color" && m.kind !== "formatted" && m.kind !== "resolvedImage" || g.kind !== "value" && g.kind !== "string") if (m.kind !== "padding" || g.kind !== "value" && g.kind !== "number" && g.kind !== "array") if (m.kind !== "variableAnchorOffsetCollection" || g.kind !== "value" && g.kind !== "array") {
                    if (this.checkSubtype(m, g)) return null;
                  } else p = s(p, m, n.typeAnnotation || "coerce");
                  else p = s(p, m, n.typeAnnotation || "coerce");
                  else p = s(p, m, n.typeAnnotation || "coerce");
                  else p = s(p, m, n.typeAnnotation || "coerce");
                  else p = s(p, m, n.typeAnnotation || "assert");
                }
                if (!(p instanceof Fi) && p.type.kind !== "resolvedImage" && this._isConstant(p)) {
                  const m = new Ns();
                  try {
                    p = new Fi(p.type, p.evaluate(m));
                  } catch (g) {
                    return this.error(g.message), null;
                  }
                }
                return p;
              }
              return this.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, s) {
            const l = typeof t == "number" ? this.path.concat(t) : this.path, d = s ? this.scope.concat(s) : this.scope;
            return new it(this.registry, this._isConstant, l, n || null, d, this.errors);
          }
          error(t, ...n) {
            const s = `${this.key}${n.map((l) => `[${l}]`).join("")}`;
            this.errors.push(new Be(s, t));
          }
          checkSubtype(t, n) {
            const s = hs(t, n);
            return s && this.error(s), s;
          }
        }
        class Xe {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const s = [];
            for (let d = 1; d < t.length - 1; d += 2) {
              const p = t[d];
              if (typeof p != "string") return n.error(`Expected string, but found ${typeof p} instead.`, d);
              if (/[^a-zA-Z0-9_]/.test(p)) return n.error("Variable names must contain only alphanumeric characters or '_'.", d);
              const m = n.parse(t[d + 1], d + 1);
              if (!m) return null;
              s.push([p, m]);
            }
            const l = n.parse(t[t.length - 1], t.length - 1, n.expectedType, s);
            return l ? new Xe(s, l) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Fn {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const s = t[1];
            return n.scope.has(s) ? new Fn(s, n.scope.get(s)) : n.error(`Unknown variable "${s}". Make sure "${s}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class rt {
          constructor(t, n, s) {
            this.type = t, this.index = n, this.input = s;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const s = n.parse(t[1], 1, ye), l = n.parse(t[2], 2, yi(n.expectedType || je));
            return s && l ? new rt(l.type.itemType, s, l) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), s = this.input.evaluate(t);
            if (n < 0) throw new It(`Array index out of bounds: ${n} < 0.`);
            if (n >= s.length) throw new It(`Array index out of bounds: ${n} > ${s.length - 1}.`);
            if (n !== Math.floor(n)) throw new It(`Array index must be an integer, but found ${n} instead.`);
            return s[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class ds {
          constructor(t, n) {
            this.type = ke, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const s = n.parse(t[1], 1, je), l = n.parse(t[2], 2, je);
            return s && l ? Ga(s.type, [ke, De, ye, $e, je]) ? new ds(s, l) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${pt(s.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
            if (!s) return !1;
            if (!Br(n, ["boolean", "string", "number", "null"])) throw new It(`Expected first argument to be of type boolean, string, number or null, but found ${pt(Ot(n))} instead.`);
            if (!Br(s, ["string", "array"])) throw new It(`Expected second argument to be of type array or string, but found ${pt(Ot(s))} instead.`);
            return s.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class ji {
          constructor(t, n, s) {
            this.type = ye, this.needle = t, this.haystack = n, this.fromIndex = s;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const s = n.parse(t[1], 1, je), l = n.parse(t[2], 2, je);
            if (!s || !l) return null;
            if (!Ga(s.type, [ke, De, ye, $e, je])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${pt(s.type)} instead`);
            if (t.length === 4) {
              const d = n.parse(t[3], 3, ye);
              return d ? new ji(s, l, d) : null;
            }
            return new ji(s, l);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
            if (!Br(n, ["boolean", "string", "number", "null"])) throw new It(`Expected first argument to be of type boolean, string, number or null, but found ${pt(Ot(n))} instead.`);
            let l;
            if (this.fromIndex && (l = this.fromIndex.evaluate(t)), Br(s, ["string"])) {
              const d = s.indexOf(n, l);
              return d === -1 ? -1 : [...s.slice(0, d)].length;
            }
            if (Br(s, ["array"])) return s.indexOf(n, l);
            throw new It(`Expected second argument to be of type array or string, but found ${pt(Ot(s))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class ps {
          constructor(t, n, s, l, d, p) {
            this.inputType = t, this.type = n, this.input = s, this.cases = l, this.outputs = d, this.otherwise = p;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let s, l;
            n.expectedType && n.expectedType.kind !== "value" && (l = n.expectedType);
            const d = {}, p = [];
            for (let x = 2; x < t.length - 1; x += 2) {
              let b = t[x];
              const w = t[x + 1];
              Array.isArray(b) || (b = [b]);
              const I = n.concat(x);
              if (b.length === 0) return I.error("Expected at least one branch label.");
              for (const A of b) {
                if (typeof A != "number" && typeof A != "string") return I.error("Branch labels must be numbers or strings.");
                if (typeof A == "number" && Math.abs(A) > Number.MAX_SAFE_INTEGER) return I.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof A == "number" && Math.floor(A) !== A) return I.error("Numeric branch labels must be integer values.");
                if (s) {
                  if (I.checkSubtype(s, Ot(A))) return null;
                } else s = Ot(A);
                if (d[String(A)] !== void 0) return I.error("Branch labels must be unique.");
                d[String(A)] = p.length;
              }
              const E = n.parse(w, x, l);
              if (!E) return null;
              l = l || E.type, p.push(E);
            }
            const m = n.parse(t[1], 1, je);
            if (!m) return null;
            const g = n.parse(t[t.length - 1], t.length - 1, l);
            return g ? m.type.kind !== "value" && n.concat(1).checkSubtype(s, m.type) ? null : new ps(s, l, m, d, p, g) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (Ot(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Zs {
          constructor(t, n, s) {
            this.type = t, this.branches = n, this.otherwise = s;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let s;
            n.expectedType && n.expectedType.kind !== "value" && (s = n.expectedType);
            const l = [];
            for (let p = 1; p < t.length - 1; p += 2) {
              const m = n.parse(t[p], p, ke);
              if (!m) return null;
              const g = n.parse(t[p + 1], p + 1, s);
              if (!g) return null;
              l.push([m, g]), s = s || g.type;
            }
            const d = n.parse(t[t.length - 1], t.length - 1, s);
            if (!d) return null;
            if (!s) throw new Error("Can't infer output type");
            return new Zs(s, l, d);
          }
          evaluate(t) {
            for (const [n, s] of this.branches) if (n.evaluate(t)) return s.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, s] of this.branches) t(n), t(s);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t, n]) => n.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class fs {
          constructor(t, n, s, l) {
            this.type = t, this.input = n, this.beginIndex = s, this.endIndex = l;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
            const s = n.parse(t[1], 1, je), l = n.parse(t[2], 2, ye);
            if (!s || !l) return null;
            if (!Ga(s.type, [yi(je), De, je])) return n.error(`Expected first argument to be of type array or string, but found ${pt(s.type)} instead`);
            if (t.length === 4) {
              const d = n.parse(t[3], 3, ye);
              return d ? new fs(s.type, s, l, d) : null;
            }
            return new fs(s.type, s, l);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), s = this.beginIndex.evaluate(t);
            let l;
            if (this.endIndex && (l = this.endIndex.evaluate(t)), Br(n, ["string"])) return [...n].slice(s, l).join("");
            if (Br(n, ["array"])) return n.slice(s, l);
            throw new It(`Expected first argument to be of type array or string, but found ${pt(Ot(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function On(r, t) {
          const n = r.length - 1;
          let s, l, d = 0, p = n, m = 0;
          for (; d <= p; ) if (m = Math.floor((d + p) / 2), s = r[m], l = r[m + 1], s <= t) {
            if (m === n || t < l) return m;
            d = m + 1;
          } else {
            if (!(s > t)) throw new It("Input is not a number.");
            p = m - 1;
          }
          return 0;
        }
        class jn {
          constructor(t, n, s) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [l, d] of s) this.labels.push(l), this.outputs.push(d);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const s = n.parse(t[1], 1, ye);
            if (!s) return null;
            const l = [];
            let d = null;
            n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType);
            for (let p = 1; p < t.length; p += 2) {
              const m = p === 1 ? -1 / 0 : t[p], g = t[p + 1], x = p, b = p + 1;
              if (typeof m != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', x);
              if (l.length && l[l.length - 1][0] >= m) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', x);
              const w = n.parse(g, b, d);
              if (!w) return null;
              d = d || w.type, l.push([m, w]);
            }
            return new jn(d, s, l);
          }
          evaluate(t) {
            const n = this.labels, s = this.outputs;
            if (n.length === 1) return s[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= n[0]) return s[0].evaluate(t);
            const d = n.length;
            return l >= n[d - 1] ? s[d - 1].evaluate(t) : s[On(n, l)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined());
          }
        }
        function Ec(r) {
          return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
        }
        var Us, to, ms = function() {
          if (to) return Us;
          function r(t, n, s, l) {
            this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (l - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = s, this.p2y = l;
          }
          return to = 1, Us = r, r.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var s = t, l = 0; l < 8; l++) {
              var d = this.sampleCurveX(s) - t;
              if (Math.abs(d) < n) return s;
              var p = this.sampleCurveDerivativeX(s);
              if (Math.abs(p) < 1e-6) break;
              s -= d / p;
            }
            var m = 0, g = 1;
            for (s = t, l = 0; l < 20 && (d = this.sampleCurveX(s), !(Math.abs(d - t) < n)); l++) t > d ? m = s : g = s, s = 0.5 * (g - m) + m;
            return s;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, Us;
        }(), hi = Ec(ms);
        class ui {
          constructor(t, n, s, l, d) {
            this.type = t, this.operator = n, this.interpolation = s, this.input = l, this.labels = [], this.outputs = [];
            for (const [p, m] of d) this.labels.push(p), this.outputs.push(m);
          }
          static interpolationFactor(t, n, s, l) {
            let d = 0;
            if (t.name === "exponential") d = Gs(n, t.base, s, l);
            else if (t.name === "linear") d = Gs(n, 1, s, l);
            else if (t.name === "cubic-bezier") {
              const p = t.controlPoints;
              d = new hi(p[0], p[1], p[2], p[3]).solve(Gs(n, 1, s, l));
            }
            return d;
          }
          static parse(t, n) {
            let [s, l, d, ...p] = t;
            if (!Array.isArray(l) || l.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (l[0] === "linear") l = { name: "linear" };
            else if (l[0] === "exponential") {
              const x = l[1];
              if (typeof x != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              l = { name: "exponential", base: x };
            } else {
              if (l[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(l[0])}`, 1, 0);
              {
                const x = l.slice(1);
                if (x.length !== 4 || x.some((b) => typeof b != "number" || b < 0 || b > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                l = { name: "cubic-bezier", controlPoints: x };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (d = n.parse(d, 2, ye), !d) return null;
            const m = [];
            let g = null;
            s === "interpolate-hcl" || s === "interpolate-lab" ? g = Ke : n.expectedType && n.expectedType.kind !== "value" && (g = n.expectedType);
            for (let x = 0; x < p.length; x += 2) {
              const b = p[x], w = p[x + 1], I = x + 3, E = x + 4;
              if (typeof b != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (m.length && m[m.length - 1][0] >= b) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', I);
              const A = n.parse(w, E, g);
              if (!A) return null;
              g = g || A.type, m.push([b, A]);
            }
            return Dn(g, ye) || Dn(g, qe) || Dn(g, Ke) || Dn(g, Nt) || Dn(g, Fs) || Dn(g, yi(ye)) ? new ui(g, s, l, d, m) : n.error(`Type ${pt(g)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, s = this.outputs;
            if (n.length === 1) return s[0].evaluate(t);
            const l = this.input.evaluate(t);
            if (l <= n[0]) return s[0].evaluate(t);
            const d = n.length;
            if (l >= n[d - 1]) return s[d - 1].evaluate(t);
            const p = On(n, l), m = ui.interpolationFactor(this.interpolation, l, n[p], n[p + 1]), g = s[p].evaluate(t), x = s[p + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Si(g, x, m);
                  case "color":
                    return st.interpolate(g, x, m);
                  case "padding":
                    return Ht.interpolate(g, x, m);
                  case "variableAnchorOffsetCollection":
                    return Xt.interpolate(g, x, m);
                  case "array":
                    return Li(g, x, m);
                  case "projectionDefinition":
                    return xi.interpolate(g, x, m);
                }
              case "interpolate-hcl":
                return st.interpolate(g, x, m, "hcl");
              case "interpolate-lab":
                return st.interpolate(g, x, m, "lab");
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every((t) => t.outputDefined());
          }
        }
        function Gs(r, t, n, s) {
          const l = s - n, d = r - n;
          return l === 0 ? 0 : t === 1 ? d / l : (Math.pow(t, d) - 1) / (Math.pow(t, l) - 1);
        }
        const Mi = { color: st.interpolate, number: Si, padding: Ht.interpolate, variableAnchorOffsetCollection: Xt.interpolate, array: Li };
        class Rt {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let s = null;
            const l = n.expectedType;
            l && l.kind !== "value" && (s = l);
            const d = [];
            for (const m of t.slice(1)) {
              const g = n.parse(m, 1 + d.length, s, void 0, { typeAnnotation: "omit" });
              if (!g) return null;
              s = s || g.type, d.push(g);
            }
            if (!s) throw new Error("No output type");
            const p = l && d.some((m) => hs(l, m.type));
            return new Rt(p ? je : s, d);
          }
          evaluate(t) {
            let n, s = null, l = 0;
            for (const d of this.args) if (l++, s = d.evaluate(t), s && s instanceof _i && !s.available && (n || (n = s.name), s = null, l === this.args.length && (s = n)), s !== null) break;
            return s;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every((t) => t.outputDefined());
          }
        }
        function io(r, t) {
          return r === "==" || r === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function $s(r, t, n, s) {
          return s.compare(t, n) === 0;
        }
        function cn(r, t, n) {
          const s = r !== "==" && r !== "!=";
          return class Td {
            constructor(d, p, m) {
              this.type = ke, this.lhs = d, this.rhs = p, this.collator = m, this.hasUntypedArgument = d.type.kind === "value" || p.type.kind === "value";
            }
            static parse(d, p) {
              if (d.length !== 3 && d.length !== 4) return p.error("Expected two or three arguments.");
              const m = d[0];
              let g = p.parse(d[1], 1, je);
              if (!g) return null;
              if (!io(m, g.type)) return p.concat(1).error(`"${m}" comparisons are not supported for type '${pt(g.type)}'.`);
              let x = p.parse(d[2], 2, je);
              if (!x) return null;
              if (!io(m, x.type)) return p.concat(2).error(`"${m}" comparisons are not supported for type '${pt(x.type)}'.`);
              if (g.type.kind !== x.type.kind && g.type.kind !== "value" && x.type.kind !== "value") return p.error(`Cannot compare types '${pt(g.type)}' and '${pt(x.type)}'.`);
              s && (g.type.kind === "value" && x.type.kind !== "value" ? g = new Oi(x.type, [g]) : g.type.kind !== "value" && x.type.kind === "value" && (x = new Oi(g.type, [x])));
              let b = null;
              if (d.length === 4) {
                if (g.type.kind !== "string" && x.type.kind !== "string" && g.type.kind !== "value" && x.type.kind !== "value") return p.error("Cannot use collator to compare non-string types.");
                if (b = p.parse(d[3], 3, on), !b) return null;
              }
              return new Td(g, x, b);
            }
            evaluate(d) {
              const p = this.lhs.evaluate(d), m = this.rhs.evaluate(d);
              if (s && this.hasUntypedArgument) {
                const g = Ot(p), x = Ot(m);
                if (g.kind !== x.kind || g.kind !== "string" && g.kind !== "number") throw new It(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${g.kind}, ${x.kind}) instead.`);
              }
              if (this.collator && !s && this.hasUntypedArgument) {
                const g = Ot(p), x = Ot(m);
                if (g.kind !== "string" || x.kind !== "string") return t(d, p, m);
              }
              return this.collator ? n(d, p, m, this.collator.evaluate(d)) : t(d, p, m);
            }
            eachChild(d) {
              d(this.lhs), d(this.rhs), this.collator && d(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const Ac = cn("==", function(r, t, n) {
          return t === n;
        }, $s), qs = cn("!=", function(r, t, n) {
          return t !== n;
        }, function(r, t, n, s) {
          return !$s(0, t, n, s);
        }), ro = cn("<", function(r, t, n) {
          return t < n;
        }, function(r, t, n, s) {
          return s.compare(t, n) < 0;
        }), zc = cn(">", function(r, t, n) {
          return t > n;
        }, function(r, t, n, s) {
          return s.compare(t, n) > 0;
        }), Ws = cn("<=", function(r, t, n) {
          return t <= n;
        }, function(r, t, n, s) {
          return s.compare(t, n) <= 0;
        }), Hs = cn(">=", function(r, t, n) {
          return t >= n;
        }, function(r, t, n, s) {
          return s.compare(t, n) >= 0;
        });
        class vi {
          constructor(t, n, s) {
            this.type = on, this.locale = s, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const s = t[1];
            if (typeof s != "object" || Array.isArray(s)) return n.error("Collator options argument must be an object.");
            const l = n.parse(s["case-sensitive"] !== void 0 && s["case-sensitive"], 1, ke);
            if (!l) return null;
            const d = n.parse(s["diacritic-sensitive"] !== void 0 && s["diacritic-sensitive"], 1, ke);
            if (!d) return null;
            let p = null;
            return s.locale && (p = n.parse(s.locale, 1, De), !p) ? null : new vi(l, d, p);
          }
          evaluate(t) {
            return new js(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class Xs {
          constructor(t, n, s, l, d) {
            this.type = De, this.number = t, this.locale = n, this.currency = s, this.minFractionDigits = l, this.maxFractionDigits = d;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const s = n.parse(t[1], 1, ye);
            if (!s) return null;
            const l = t[2];
            if (typeof l != "object" || Array.isArray(l)) return n.error("NumberFormat options argument must be an object.");
            let d = null;
            if (l.locale && (d = n.parse(l.locale, 1, De), !d)) return null;
            let p = null;
            if (l.currency && (p = n.parse(l.currency, 1, De), !p)) return null;
            let m = null;
            if (l["min-fraction-digits"] && (m = n.parse(l["min-fraction-digits"], 1, ye), !m)) return null;
            let g = null;
            return l["max-fraction-digits"] && (g = n.parse(l["max-fraction-digits"], 1, ye), !g) ? null : new Xs(s, d, p, m, g);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class hn {
          constructor(t) {
            this.type = Ft, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const s = t[1];
            if (!Array.isArray(s) && typeof s == "object") return n.error("First argument must be an image or text section.");
            const l = [];
            let d = !1;
            for (let p = 1; p <= t.length - 1; ++p) {
              const m = t[p];
              if (d && typeof m == "object" && !Array.isArray(m)) {
                d = !1;
                let g = null;
                if (m["font-scale"] && (g = n.parse(m["font-scale"], 1, ye), !g)) return null;
                let x = null;
                if (m["text-font"] && (x = n.parse(m["text-font"], 1, yi(De)), !x)) return null;
                let b = null;
                if (m["text-color"] && (b = n.parse(m["text-color"], 1, Ke), !b)) return null;
                let w = null;
                if (m["vertical-align"]) {
                  if (typeof m["vertical-align"] == "string" && !Ya.includes(m["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${m["vertical-align"]}' instead.`);
                  if (w = n.parse(m["vertical-align"], 1, De), !w) return null;
                }
                const I = l[l.length - 1];
                I.scale = g, I.font = x, I.textColor = b, I.verticalAlign = w;
              } else {
                const g = n.parse(t[p], 1, je);
                if (!g) return null;
                const x = g.type.kind;
                if (x !== "string" && x !== "value" && x !== "null" && x !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                d = !0, l.push({ content: g, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new hn(l);
          }
          evaluate(t) {
            return new ri(this.sections.map((n) => {
              const s = n.content.evaluate(t);
              return Ot(s) === yt ? new Bi("", s, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Bi(Fr(s), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            }));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class no {
          constructor(t) {
            this.type = yt, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const s = n.parse(t[1], 1, De);
            return s ? new no(s) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), s = _i.fromString(n);
            return s && t.availableImages && (s.available = t.availableImages.indexOf(n) > -1), s;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class _s {
          constructor(t) {
            this.type = ye, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const s = n.parse(t[1], 1);
            return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${pt(s.type)} instead.`) : new _s(s) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new It(`Expected value to be of type string or array, but found ${pt(Ot(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const or = 8192;
        function kc(r, t) {
          const n = (180 + r[0]) / 360, s = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, l = Math.pow(2, t.z);
          return [Math.round(n * l * or), Math.round(s * l * or)];
        }
        function so(r, t) {
          const n = Math.pow(2, t.z);
          return [(l = (r[0] / or + t.x) / n, 360 * l - 180), (s = (r[1] / or + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * s) * Math.PI / 180)) - 90)];
          var s, l;
        }
        function gs(r, t) {
          r[0] = Math.min(r[0], t[0]), r[1] = Math.min(r[1], t[1]), r[2] = Math.max(r[2], t[0]), r[3] = Math.max(r[3], t[1]);
        }
        function Or(r, t) {
          return !(r[0] <= t[0] || r[2] >= t[2] || r[1] <= t[1] || r[3] >= t[3]);
        }
        function Dc(r, t, n) {
          const s = r[0] - t[0], l = r[1] - t[1], d = r[0] - n[0], p = r[1] - n[1];
          return s * p - d * l == 0 && s * d <= 0 && l * p <= 0;
        }
        function ys(r, t, n, s) {
          return (l = [s[0] - n[0], s[1] - n[1]])[0] * (d = [t[0] - r[0], t[1] - r[1]])[1] - l[1] * d[0] != 0 && !(!xl(r, t, n, s) || !xl(n, s, r, t));
          var l, d;
        }
        function _l(r, t, n) {
          for (const s of n) for (let l = 0; l < s.length - 1; ++l) if (ys(r, t, s[l], s[l + 1])) return !0;
          return !1;
        }
        function Vn(r, t, n = !1) {
          let s = !1;
          for (const m of t) for (let g = 0; g < m.length - 1; g++) {
            if (Dc(r, m[g], m[g + 1])) return n;
            (d = m[g])[1] > (l = r)[1] != (p = m[g + 1])[1] > l[1] && l[0] < (p[0] - d[0]) * (l[1] - d[1]) / (p[1] - d[1]) + d[0] && (s = !s);
          }
          var l, d, p;
          return s;
        }
        function gl(r, t) {
          for (const n of t) if (Vn(r, n)) return !0;
          return !1;
        }
        function yl(r, t) {
          for (const n of r) if (!Vn(n, t)) return !1;
          for (let n = 0; n < r.length - 1; ++n) if (_l(r[n], r[n + 1], t)) return !1;
          return !0;
        }
        function Rc(r, t) {
          for (const n of t) if (yl(r, n)) return !0;
          return !1;
        }
        function xl(r, t, n, s) {
          const l = s[0] - n[0], d = s[1] - n[1], p = (r[0] - n[0]) * d - l * (r[1] - n[1]), m = (t[0] - n[0]) * d - l * (t[1] - n[1]);
          return p > 0 && m < 0 || p < 0 && m > 0;
        }
        function ao(r, t, n) {
          const s = [];
          for (let l = 0; l < r.length; l++) {
            const d = [];
            for (let p = 0; p < r[l].length; p++) {
              const m = kc(r[l][p], n);
              gs(t, m), d.push(m);
            }
            s.push(d);
          }
          return s;
        }
        function vl(r, t, n) {
          const s = [];
          for (let l = 0; l < r.length; l++) {
            const d = ao(r[l], t, n);
            s.push(d);
          }
          return s;
        }
        function oo(r, t, n, s) {
          if (r[0] < n[0] || r[0] > n[2]) {
            const l = 0.5 * s;
            let d = r[0] - n[0] > l ? -s : n[0] - r[0] > l ? s : 0;
            d === 0 && (d = r[0] - n[2] > l ? -s : n[2] - r[0] > l ? s : 0), r[0] += d;
          }
          gs(t, r);
        }
        function lo(r, t, n, s) {
          const l = Math.pow(2, s.z) * or, d = [s.x * or, s.y * or], p = [];
          for (const m of r) for (const g of m) {
            const x = [g.x + d[0], g.y + d[1]];
            oo(x, t, n, l), p.push(x);
          }
          return p;
        }
        function co(r, t, n, s) {
          const l = Math.pow(2, s.z) * or, d = [s.x * or, s.y * or], p = [];
          for (const g of r) {
            const x = [];
            for (const b of g) {
              const w = [b.x + d[0], b.y + d[1]];
              gs(t, w), x.push(w);
            }
            p.push(x);
          }
          if (t[2] - t[0] <= l / 2) {
            (m = t)[0] = m[1] = 1 / 0, m[2] = m[3] = -1 / 0;
            for (const g of p) for (const x of g) oo(x, t, n, l);
          }
          var m;
          return p;
        }
        class un {
          constructor(t, n) {
            this.type = ke, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ki(t[1])) {
              const s = t[1];
              if (s.type === "FeatureCollection") {
                const l = [];
                for (const d of s.features) {
                  const { type: p, coordinates: m } = d.geometry;
                  p === "Polygon" && l.push(m), p === "MultiPolygon" && l.push(...m);
                }
                if (l.length) return new un(s, { type: "MultiPolygon", coordinates: l });
              } else if (s.type === "Feature") {
                const l = s.geometry.type;
                if (l === "Polygon" || l === "MultiPolygon") return new un(s, s.geometry);
              } else if (s.type === "Polygon" || s.type === "MultiPolygon") return new un(s, s);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return function(n, s) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = n.canonicalID();
                if (s.type === "Polygon") {
                  const m = ao(s.coordinates, d, p), g = lo(n.geometry(), l, d, p);
                  if (!Or(l, d)) return !1;
                  for (const x of g) if (!Vn(x, m)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const m = vl(s.coordinates, d, p), g = lo(n.geometry(), l, d, p);
                  if (!Or(l, d)) return !1;
                  for (const x of g) if (!gl(x, m)) return !1;
                }
                return !0;
              }(t, this.geometries);
              if (t.geometryType() === "LineString") return function(n, s) {
                const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = n.canonicalID();
                if (s.type === "Polygon") {
                  const m = ao(s.coordinates, d, p), g = co(n.geometry(), l, d, p);
                  if (!Or(l, d)) return !1;
                  for (const x of g) if (!yl(x, m)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const m = vl(s.coordinates, d, p), g = co(n.geometry(), l, d, p);
                  if (!Or(l, d)) return !1;
                  for (const x of g) if (!Rc(x, m)) return !1;
                }
                return !0;
              }(t, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let bl = class {
          constructor(r = [], t = (n, s) => n < s ? -1 : n > s ? 1 : 0) {
            if (this.data = r, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(r) {
            this.data.push(r), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const r = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), r;
          }
          peek() {
            return this.data[0];
          }
          _up(r) {
            const { data: t, compare: n } = this, s = t[r];
            for (; r > 0; ) {
              const l = r - 1 >> 1, d = t[l];
              if (n(s, d) >= 0) break;
              t[r] = d, r = l;
            }
            t[r] = s;
          }
          _down(r) {
            const { data: t, compare: n } = this, s = this.length >> 1, l = t[r];
            for (; r < s; ) {
              let d = 1 + (r << 1);
              const p = d + 1;
              if (p < this.length && n(t[p], t[d]) < 0 && (d = p), n(t[d], l) >= 0) break;
              t[r] = t[d], r = d;
            }
            t[r] = l;
          }
        };
        function wl(r, t, n = 0, s = r.length - 1, l = Lc) {
          for (; s > n; ) {
            if (s - n > 600) {
              const g = s - n + 1, x = t - n + 1, b = Math.log(g), w = 0.5 * Math.exp(2 * b / 3), I = 0.5 * Math.sqrt(b * w * (g - w) / g) * (x - g / 2 < 0 ? -1 : 1);
              wl(r, t, Math.max(n, Math.floor(t - x * w / g + I)), Math.min(s, Math.floor(t + (g - x) * w / g + I)), l);
            }
            const d = r[t];
            let p = n, m = s;
            for (dn(r, n, t), l(r[s], d) > 0 && dn(r, n, s); p < m; ) {
              for (dn(r, p, m), p++, m--; l(r[p], d) < 0; ) p++;
              for (; l(r[m], d) > 0; ) m--;
            }
            l(r[n], d) === 0 ? dn(r, n, m) : (m++, dn(r, m, s)), m <= t && (n = m + 1), t <= m && (s = m - 1);
          }
        }
        function dn(r, t, n) {
          const s = r[t];
          r[t] = r[n], r[n] = s;
        }
        function Lc(r, t) {
          return r < t ? -1 : r > t ? 1 : 0;
        }
        function Ks(r, t) {
          if (r.length <= 1) return [r];
          const n = [];
          let s, l;
          for (const d of r) {
            const p = Tl(d);
            p !== 0 && (d.area = Math.abs(p), l === void 0 && (l = p < 0), l === p < 0 ? (s && n.push(s), s = [d]) : s.push(d));
          }
          if (s && n.push(s), t > 1) for (let d = 0; d < n.length; d++) n[d].length <= t || (wl(n[d], t, 1, n[d].length - 1, Bc), n[d] = n[d].slice(0, t));
          return n;
        }
        function Bc(r, t) {
          return t.area - r.area;
        }
        function Tl(r) {
          let t = 0;
          for (let n, s, l = 0, d = r.length, p = d - 1; l < d; p = l++) n = r[l], s = r[p], t += (s.x - n.x) * (n.y + s.y);
          return t;
        }
        const ho = 1 / 298.257223563, Pl = ho * (2 - ho), Sl = Math.PI / 180;
        class Js {
          constructor(t) {
            const n = 6378.137 * Sl * 1e3, s = Math.cos(t * Sl), l = 1 / (1 - Pl * (1 - s * s)), d = Math.sqrt(l);
            this.kx = n * d * s, this.ky = n * d * l * (1 - Pl);
          }
          distance(t, n) {
            const s = this.wrap(t[0] - n[0]) * this.kx, l = (t[1] - n[1]) * this.ky;
            return Math.sqrt(s * s + l * l);
          }
          pointOnLine(t, n) {
            let s, l, d, p, m = 1 / 0;
            for (let g = 0; g < t.length - 1; g++) {
              let x = t[g][0], b = t[g][1], w = this.wrap(t[g + 1][0] - x) * this.kx, I = (t[g + 1][1] - b) * this.ky, E = 0;
              w === 0 && I === 0 || (E = (this.wrap(n[0] - x) * this.kx * w + (n[1] - b) * this.ky * I) / (w * w + I * I), E > 1 ? (x = t[g + 1][0], b = t[g + 1][1]) : E > 0 && (x += w / this.kx * E, b += I / this.ky * E)), w = this.wrap(n[0] - x) * this.kx, I = (n[1] - b) * this.ky;
              const A = w * w + I * I;
              A < m && (m = A, s = x, l = b, d = g, p = E);
            }
            return { point: [s, l], index: d, t: Math.max(0, Math.min(1, p)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function uo(r, t) {
          return t[0] - r[0];
        }
        function Ys(r) {
          return r[1] - r[0] + 1;
        }
        function xr(r, t) {
          return r[1] >= r[0] && r[1] < t;
        }
        function po(r, t) {
          if (r[0] > r[1]) return [null, null];
          const n = Ys(r);
          if (t) {
            if (n === 2) return [r, null];
            const l = Math.floor(n / 2);
            return [[r[0], r[0] + l], [r[0] + l, r[1]]];
          }
          if (n === 1) return [r, null];
          const s = Math.floor(n / 2) - 1;
          return [[r[0], r[0] + s], [r[0] + s + 1, r[1]]];
        }
        function Qs(r, t) {
          if (!xr(t, r.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let s = t[0]; s <= t[1]; ++s) gs(n, r[s]);
          return n;
        }
        function fo(r) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of r) for (const s of n) gs(t, s);
          return t;
        }
        function Ml(r) {
          return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;
        }
        function mo(r, t, n) {
          if (!Ml(r) || !Ml(t)) return NaN;
          let s = 0, l = 0;
          return r[2] < t[0] && (s = t[0] - r[2]), r[0] > t[2] && (s = r[0] - t[2]), r[1] > t[3] && (l = r[1] - t[3]), r[3] < t[1] && (l = t[1] - r[3]), n.distance([0, 0], [s, l]);
        }
        function pn(r, t, n) {
          const s = n.pointOnLine(t, r);
          return n.distance(r, s.point);
        }
        function ot(r, t, n, s, l) {
          const d = Math.min(pn(r, [n, s], l), pn(t, [n, s], l)), p = Math.min(pn(n, [r, t], l), pn(s, [r, t], l));
          return Math.min(d, p);
        }
        function Fc(r, t, n, s, l) {
          if (!xr(t, r.length) || !xr(s, n.length)) return 1 / 0;
          let d = 1 / 0;
          for (let p = t[0]; p < t[1]; ++p) {
            const m = r[p], g = r[p + 1];
            for (let x = s[0]; x < s[1]; ++x) {
              const b = n[x], w = n[x + 1];
              if (ys(m, g, b, w)) return 0;
              d = Math.min(d, ot(m, g, b, w, l));
            }
          }
          return d;
        }
        function Oc(r, t, n, s, l) {
          if (!xr(t, r.length) || !xr(s, n.length)) return NaN;
          let d = 1 / 0;
          for (let p = t[0]; p <= t[1]; ++p) for (let m = s[0]; m <= s[1]; ++m) if (d = Math.min(d, l.distance(r[p], n[m])), d === 0) return d;
          return d;
        }
        function jc(r, t, n) {
          if (Vn(r, t, !0)) return 0;
          let s = 1 / 0;
          for (const l of t) {
            const d = l[0], p = l[l.length - 1];
            if (d !== p && (s = Math.min(s, pn(r, [p, d], n)), s === 0)) return s;
            const m = n.pointOnLine(l, r);
            if (s = Math.min(s, n.distance(r, m.point)), s === 0) return s;
          }
          return s;
        }
        function Vc(r, t, n, s) {
          if (!xr(t, r.length)) return NaN;
          for (let d = t[0]; d <= t[1]; ++d) if (Vn(r[d], n, !0)) return 0;
          let l = 1 / 0;
          for (let d = t[0]; d < t[1]; ++d) {
            const p = r[d], m = r[d + 1];
            for (const g of n) for (let x = 0, b = g.length, w = b - 1; x < b; w = x++) {
              const I = g[w], E = g[x];
              if (ys(p, m, I, E)) return 0;
              l = Math.min(l, ot(p, m, I, E, s));
            }
          }
          return l;
        }
        function Il(r, t) {
          for (const n of r) for (const s of n) if (Vn(s, t, !0)) return !0;
          return !1;
        }
        function Nc(r, t, n, s = 1 / 0) {
          const l = fo(r), d = fo(t);
          if (s !== 1 / 0 && mo(l, d, n) >= s) return s;
          if (Or(l, d)) {
            if (Il(r, t)) return 0;
          } else if (Il(t, r)) return 0;
          let p = 1 / 0;
          for (const m of r) for (let g = 0, x = m.length, b = x - 1; g < x; b = g++) {
            const w = m[b], I = m[g];
            for (const E of t) for (let A = 0, D = E.length, F = D - 1; A < D; F = A++) {
              const Z = E[F], Y = E[A];
              if (ys(w, I, Z, Y)) return 0;
              p = Math.min(p, ot(w, I, Z, Y, n));
            }
          }
          return p;
        }
        function Cl(r, t, n, s, l, d) {
          if (!d) return;
          const p = mo(Qs(s, d), l, n);
          p < t && r.push([p, d, [0, 0]]);
        }
        function ea(r, t, n, s, l, d, p) {
          if (!d || !p) return;
          const m = mo(Qs(s, d), Qs(l, p), n);
          m < t && r.push([m, d, p]);
        }
        function ta(r, t, n, s, l = 1 / 0) {
          let d = Math.min(s.distance(r[0], n[0][0]), l);
          if (d === 0) return d;
          const p = new bl([[0, [0, r.length - 1], [0, 0]]], uo), m = fo(n);
          for (; p.length > 0; ) {
            const g = p.pop();
            if (g[0] >= d) continue;
            const x = g[1], b = t ? 50 : 100;
            if (Ys(x) <= b) {
              if (!xr(x, r.length)) return NaN;
              if (t) {
                const w = Vc(r, x, n, s);
                if (isNaN(w) || w === 0) return w;
                d = Math.min(d, w);
              } else for (let w = x[0]; w <= x[1]; ++w) {
                const I = jc(r[w], n, s);
                if (d = Math.min(d, I), d === 0) return 0;
              }
            } else {
              const w = po(x, t);
              Cl(p, d, s, r, m, w[0]), Cl(p, d, s, r, m, w[1]);
            }
          }
          return d;
        }
        function ia(r, t, n, s, l, d = 1 / 0) {
          let p = Math.min(d, l.distance(r[0], n[0]));
          if (p === 0) return p;
          const m = new bl([[0, [0, r.length - 1], [0, n.length - 1]]], uo);
          for (; m.length > 0; ) {
            const g = m.pop();
            if (g[0] >= p) continue;
            const x = g[1], b = g[2], w = t ? 50 : 100, I = s ? 50 : 100;
            if (Ys(x) <= w && Ys(b) <= I) {
              if (!xr(x, r.length) && xr(b, n.length)) return NaN;
              let E;
              if (t && s) E = Fc(r, x, n, b, l), p = Math.min(p, E);
              else if (t && !s) {
                const A = r.slice(x[0], x[1] + 1);
                for (let D = b[0]; D <= b[1]; ++D) if (E = pn(n[D], A, l), p = Math.min(p, E), p === 0) return p;
              } else if (!t && s) {
                const A = n.slice(b[0], b[1] + 1);
                for (let D = x[0]; D <= x[1]; ++D) if (E = pn(r[D], A, l), p = Math.min(p, E), p === 0) return p;
              } else E = Oc(r, x, n, b, l), p = Math.min(p, E);
            } else {
              const E = po(x, t), A = po(b, s);
              ea(m, p, l, r, n, E[0], A[0]), ea(m, p, l, r, n, E[0], A[1]), ea(m, p, l, r, n, E[1], A[0]), ea(m, p, l, r, n, E[1], A[1]);
            }
          }
          return p;
        }
        function _o(r) {
          return r.type === "MultiPolygon" ? r.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : r.type === "MultiLineString" ? r.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : r.type === "MultiPoint" ? r.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [r];
        }
        class fn {
          constructor(t, n) {
            this.type = ye, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ki(t[1])) {
              const s = t[1];
              if (s.type === "FeatureCollection") return new fn(s, s.features.map((l) => _o(l.geometry)).flat());
              if (s.type === "Feature") return new fn(s, _o(s.geometry));
              if ("type" in s && "coordinates" in s) return new fn(s, _o(s));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return function(n, s) {
                const l = n.geometry(), d = l.flat().map((g) => so([g.x, g.y], n.canonical));
                if (l.length === 0) return NaN;
                const p = new Js(d[0][1]);
                let m = 1 / 0;
                for (const g of s) {
                  switch (g.type) {
                    case "Point":
                      m = Math.min(m, ia(d, !1, [g.coordinates], !1, p, m));
                      break;
                    case "LineString":
                      m = Math.min(m, ia(d, !1, g.coordinates, !0, p, m));
                      break;
                    case "Polygon":
                      m = Math.min(m, ta(d, !1, g.coordinates, p, m));
                  }
                  if (m === 0) return m;
                }
                return m;
              }(t, this.geometries);
              if (t.geometryType() === "LineString") return function(n, s) {
                const l = n.geometry(), d = l.flat().map((g) => so([g.x, g.y], n.canonical));
                if (l.length === 0) return NaN;
                const p = new Js(d[0][1]);
                let m = 1 / 0;
                for (const g of s) {
                  switch (g.type) {
                    case "Point":
                      m = Math.min(m, ia(d, !0, [g.coordinates], !1, p, m));
                      break;
                    case "LineString":
                      m = Math.min(m, ia(d, !0, g.coordinates, !0, p, m));
                      break;
                    case "Polygon":
                      m = Math.min(m, ta(d, !0, g.coordinates, p, m));
                  }
                  if (m === 0) return m;
                }
                return m;
              }(t, this.geometries);
              if (t.geometryType() === "Polygon") return function(n, s) {
                const l = n.geometry();
                if (l.length === 0 || l[0].length === 0) return NaN;
                const d = Ks(l, 0).map((g) => g.map((x) => x.map((b) => so([b.x, b.y], n.canonical)))), p = new Js(d[0][0][0][1]);
                let m = 1 / 0;
                for (const g of s) for (const x of d) {
                  switch (g.type) {
                    case "Point":
                      m = Math.min(m, ta([g.coordinates], !1, x, p, m));
                      break;
                    case "LineString":
                      m = Math.min(m, ta(g.coordinates, !0, x, p, m));
                      break;
                    case "Polygon":
                      m = Math.min(m, Nc(x, g.coordinates, p, m));
                  }
                  if (m === 0) return m;
                }
                return m;
              }(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Nn = { "==": Ac, "!=": qs, ">": zc, "<": ro, ">=": Hs, "<=": Ws, array: Oi, at: rt, boolean: Oi, case: Zs, coalesce: Rt, collator: vi, format: hn, image: no, in: ds, "index-of": ji, interpolate: ui, "interpolate-hcl": ui, "interpolate-lab": ui, length: _s, let: Xe, literal: Fi, match: ps, number: Oi, "number-format": Xs, object: Oi, slice: fs, step: jn, string: Oi, "to-boolean": Ji, "to-color": Ji, "to-number": Ji, "to-string": Ji, var: Fn, within: un, distance: fn };
        class Vi {
          constructor(t, n, s, l) {
            this.name = t, this.type = n, this._evaluate = s, this.args = l;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return !1;
          }
          static parse(t, n) {
            const s = t[0], l = Vi.definitions[s];
            if (!l) return n.error(`Unknown expression "${s}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const d = Array.isArray(l) ? l[0] : l.type, p = Array.isArray(l) ? [[l[1], l[2]]] : l.overloads, m = p.filter(([x]) => !Array.isArray(x) || x.length === t.length - 1);
            let g = null;
            for (const [x, b] of m) {
              g = new it(n.registry, ra, n.path, null, n.scope);
              const w = [];
              let I = !1;
              for (let E = 1; E < t.length; E++) {
                const A = t[E], D = Array.isArray(x) ? x[E - 1] : x.type, F = g.parse(A, 1 + w.length, D);
                if (!F) {
                  I = !0;
                  break;
                }
                w.push(F);
              }
              if (!I) if (Array.isArray(x) && x.length !== w.length) g.error(`Expected ${x.length} arguments, but found ${w.length} instead.`);
              else {
                for (let E = 0; E < w.length; E++) {
                  const A = Array.isArray(x) ? x[E] : x.type, D = w[E];
                  g.concat(E + 1).checkSubtype(A, D.type);
                }
                if (g.errors.length === 0) return new Vi(s, d, b, w);
              }
            }
            if (m.length === 1) n.errors.push(...g.errors);
            else {
              const x = (m.length ? m : p).map(([w]) => {
                return I = w, Array.isArray(I) ? `(${I.map(pt).join(", ")})` : `(${pt(I.type)}...)`;
                var I;
              }).join(" | "), b = [];
              for (let w = 1; w < t.length; w++) {
                const I = n.parse(t[w], 1 + b.length);
                if (!I) return null;
                b.push(pt(I.type));
              }
              n.error(`Expected arguments of type ${x}, but found (${b.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Vi.definitions = n;
            for (const s in n) t[s] = Vi;
          }
        }
        function El(r, [t, n, s, l]) {
          t = t.evaluate(r), n = n.evaluate(r), s = s.evaluate(r);
          const d = l ? l.evaluate(r) : 1, p = Vs(t, n, s, d);
          if (p) throw new It(p);
          return new st(t / 255, n / 255, s / 255, d, !1);
        }
        function Al(r, t) {
          return r in t;
        }
        function go(r, t) {
          const n = t[r];
          return n === void 0 ? null : n;
        }
        function mn(r) {
          return { type: r };
        }
        function ra(r) {
          if (r instanceof Fn) return ra(r.boundExpression);
          if (r instanceof Vi && r.name === "error" || r instanceof vi || r instanceof un || r instanceof fn) return !1;
          const t = r instanceof Ji || r instanceof Oi;
          let n = !0;
          return r.eachChild((s) => {
            n = t ? n && ra(s) : n && s instanceof Fi;
          }), !!n && na(r) && sa(r, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function na(r) {
          if (r instanceof Vi && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof un || r instanceof fn) return !1;
          let t = !0;
          return r.eachChild((n) => {
            t && !na(n) && (t = !1);
          }), t;
        }
        function xs(r) {
          if (r instanceof Vi && r.name === "feature-state") return !1;
          let t = !0;
          return r.eachChild((n) => {
            t && !xs(n) && (t = !1);
          }), t;
        }
        function sa(r, t) {
          if (r instanceof Vi && t.indexOf(r.name) >= 0) return !1;
          let n = !0;
          return r.eachChild((s) => {
            n && !sa(s, t) && (n = !1);
          }), n;
        }
        function zl(r) {
          return { result: "success", value: r };
        }
        function Zn(r) {
          return { result: "error", value: r };
        }
        function Un(r) {
          return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
        }
        function kl(r) {
          return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
        }
        function yo(r) {
          return !!r.expression && r.expression.interpolated;
        }
        function at(r) {
          return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
        }
        function aa(r) {
          return typeof r == "object" && r !== null && !Array.isArray(r);
        }
        function Zc(r) {
          return r;
        }
        function Dl(r, t) {
          const n = t.type === "color", s = r.stops && typeof r.stops[0][0] == "object", l = s || !(s || r.property !== void 0), d = r.type || (yo(t) ? "exponential" : "interval");
          if (n || t.type === "padding") {
            const b = n ? st.parse : Ht.parse;
            (r = Ce({}, r)).stops && (r.stops = r.stops.map((w) => [w[0], b(w[1])])), r.default = b(r.default ? r.default : t.default);
          }
          if (r.colorSpace && (p = r.colorSpace) !== "rgb" && p !== "hcl" && p !== "lab") throw new Error(`Unknown color space: "${r.colorSpace}"`);
          var p;
          let m, g, x;
          if (d === "exponential") m = Rl;
          else if (d === "interval") m = Gc;
          else if (d === "categorical") {
            m = Uc, g = /* @__PURE__ */ Object.create(null);
            for (const b of r.stops) g[b[0]] = b[1];
            x = typeof r.stops[0][0];
          } else {
            if (d !== "identity") throw new Error(`Unknown function type "${d}"`);
            m = Ll;
          }
          if (s) {
            const b = {}, w = [];
            for (let A = 0; A < r.stops.length; A++) {
              const D = r.stops[A], F = D[0].zoom;
              b[F] === void 0 && (b[F] = { zoom: F, type: r.type, property: r.property, default: r.default, stops: [] }, w.push(F)), b[F].stops.push([D[0].value, D[1]]);
            }
            const I = [];
            for (const A of w) I.push([b[A].zoom, Dl(b[A], t)]);
            const E = { name: "linear" };
            return { kind: "composite", interpolationType: E, interpolationFactor: ui.interpolationFactor.bind(void 0, E), zoomStops: I.map((A) => A[0]), evaluate: ({ zoom: A }, D) => Rl({ stops: I, base: r.base }, t, A).evaluate(A, D) };
          }
          if (l) {
            const b = d === "exponential" ? { name: "exponential", base: r.base !== void 0 ? r.base : 1 } : null;
            return { kind: "camera", interpolationType: b, interpolationFactor: ui.interpolationFactor.bind(void 0, b), zoomStops: r.stops.map((w) => w[0]), evaluate: ({ zoom: w }) => m(r, t, w, g, x) };
          }
          return { kind: "source", evaluate(b, w) {
            const I = w && w.properties ? w.properties[r.property] : void 0;
            return I === void 0 ? _n(r.default, t.default) : m(r, t, I, g, x);
          } };
        }
        function _n(r, t, n) {
          return r !== void 0 ? r : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function Uc(r, t, n, s, l) {
          return _n(typeof n === l ? s[n] : void 0, r.default, t.default);
        }
        function Gc(r, t, n) {
          if (at(n) !== "number") return _n(r.default, t.default);
          const s = r.stops.length;
          if (s === 1 || n <= r.stops[0][0]) return r.stops[0][1];
          if (n >= r.stops[s - 1][0]) return r.stops[s - 1][1];
          const l = On(r.stops.map((d) => d[0]), n);
          return r.stops[l][1];
        }
        function Rl(r, t, n) {
          const s = r.base !== void 0 ? r.base : 1;
          if (at(n) !== "number") return _n(r.default, t.default);
          const l = r.stops.length;
          if (l === 1 || n <= r.stops[0][0]) return r.stops[0][1];
          if (n >= r.stops[l - 1][0]) return r.stops[l - 1][1];
          const d = On(r.stops.map((b) => b[0]), n), p = function(b, w, I, E) {
            const A = E - I, D = b - I;
            return A === 0 ? 0 : w === 1 ? D / A : (Math.pow(w, D) - 1) / (Math.pow(w, A) - 1);
          }(n, s, r.stops[d][0], r.stops[d + 1][0]), m = r.stops[d][1], g = r.stops[d + 1][1], x = Mi[t.type] || Zc;
          return typeof m.evaluate == "function" ? { evaluate(...b) {
            const w = m.evaluate.apply(void 0, b), I = g.evaluate.apply(void 0, b);
            if (w !== void 0 && I !== void 0) return x(w, I, p, r.colorSpace);
          } } : x(m, g, p, r.colorSpace);
        }
        function Ll(r, t, n) {
          switch (t.type) {
            case "color":
              n = st.parse(n);
              break;
            case "formatted":
              n = ri.fromString(n.toString());
              break;
            case "resolvedImage":
              n = _i.fromString(n.toString());
              break;
            case "padding":
              n = Ht.parse(n);
              break;
            default:
              at(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return _n(n, r.default, t.default);
        }
        Vi.register(Nn, { error: [{ kind: "error" }, [De], (r, [t]) => {
          throw new It(t.evaluate(r));
        }], typeof: [De, [je], (r, [t]) => pt(Ot(t.evaluate(r)))], "to-rgba": [yi(ye, 4), [Ke], (r, [t]) => {
          const [n, s, l, d] = t.evaluate(r).rgb;
          return [255 * n, 255 * s, 255 * l, d];
        }], rgb: [Ke, [ye, ye, ye], El], rgba: [Ke, [ye, ye, ye, ye], El], has: { type: ke, overloads: [[[De], (r, [t]) => Al(t.evaluate(r), r.properties())], [[De, Je], (r, [t, n]) => Al(t.evaluate(r), n.evaluate(r))]] }, get: { type: je, overloads: [[[De], (r, [t]) => go(t.evaluate(r), r.properties())], [[De, Je], (r, [t, n]) => go(t.evaluate(r), n.evaluate(r))]] }, "feature-state": [je, [De], (r, [t]) => go(t.evaluate(r), r.featureState || {})], properties: [Je, [], (r) => r.properties()], "geometry-type": [De, [], (r) => r.geometryType()], id: [je, [], (r) => r.id()], zoom: [ye, [], (r) => r.globals.zoom], "heatmap-density": [ye, [], (r) => r.globals.heatmapDensity || 0], "line-progress": [ye, [], (r) => r.globals.lineProgress || 0], accumulated: [je, [], (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated], "+": [ye, mn(ye), (r, t) => {
          let n = 0;
          for (const s of t) n += s.evaluate(r);
          return n;
        }], "*": [ye, mn(ye), (r, t) => {
          let n = 1;
          for (const s of t) n *= s.evaluate(r);
          return n;
        }], "-": { type: ye, overloads: [[[ye, ye], (r, [t, n]) => t.evaluate(r) - n.evaluate(r)], [[ye], (r, [t]) => -t.evaluate(r)]] }, "/": [ye, [ye, ye], (r, [t, n]) => t.evaluate(r) / n.evaluate(r)], "%": [ye, [ye, ye], (r, [t, n]) => t.evaluate(r) % n.evaluate(r)], ln2: [ye, [], () => Math.LN2], pi: [ye, [], () => Math.PI], e: [ye, [], () => Math.E], "^": [ye, [ye, ye], (r, [t, n]) => Math.pow(t.evaluate(r), n.evaluate(r))], sqrt: [ye, [ye], (r, [t]) => Math.sqrt(t.evaluate(r))], log10: [ye, [ye], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN10], ln: [ye, [ye], (r, [t]) => Math.log(t.evaluate(r))], log2: [ye, [ye], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN2], sin: [ye, [ye], (r, [t]) => Math.sin(t.evaluate(r))], cos: [ye, [ye], (r, [t]) => Math.cos(t.evaluate(r))], tan: [ye, [ye], (r, [t]) => Math.tan(t.evaluate(r))], asin: [ye, [ye], (r, [t]) => Math.asin(t.evaluate(r))], acos: [ye, [ye], (r, [t]) => Math.acos(t.evaluate(r))], atan: [ye, [ye], (r, [t]) => Math.atan(t.evaluate(r))], min: [ye, mn(ye), (r, t) => Math.min(...t.map((n) => n.evaluate(r)))], max: [ye, mn(ye), (r, t) => Math.max(...t.map((n) => n.evaluate(r)))], abs: [ye, [ye], (r, [t]) => Math.abs(t.evaluate(r))], round: [ye, [ye], (r, [t]) => {
          const n = t.evaluate(r);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [ye, [ye], (r, [t]) => Math.floor(t.evaluate(r))], ceil: [ye, [ye], (r, [t]) => Math.ceil(t.evaluate(r))], "filter-==": [ke, [De, je], (r, [t, n]) => r.properties()[t.value] === n.value], "filter-id-==": [ke, [je], (r, [t]) => r.id() === t.value], "filter-type-==": [ke, [De], (r, [t]) => r.geometryType() === t.value], "filter-<": [ke, [De, je], (r, [t, n]) => {
          const s = r.properties()[t.value], l = n.value;
          return typeof s == typeof l && s < l;
        }], "filter-id-<": [ke, [je], (r, [t]) => {
          const n = r.id(), s = t.value;
          return typeof n == typeof s && n < s;
        }], "filter->": [ke, [De, je], (r, [t, n]) => {
          const s = r.properties()[t.value], l = n.value;
          return typeof s == typeof l && s > l;
        }], "filter-id->": [ke, [je], (r, [t]) => {
          const n = r.id(), s = t.value;
          return typeof n == typeof s && n > s;
        }], "filter-<=": [ke, [De, je], (r, [t, n]) => {
          const s = r.properties()[t.value], l = n.value;
          return typeof s == typeof l && s <= l;
        }], "filter-id-<=": [ke, [je], (r, [t]) => {
          const n = r.id(), s = t.value;
          return typeof n == typeof s && n <= s;
        }], "filter->=": [ke, [De, je], (r, [t, n]) => {
          const s = r.properties()[t.value], l = n.value;
          return typeof s == typeof l && s >= l;
        }], "filter-id->=": [ke, [je], (r, [t]) => {
          const n = r.id(), s = t.value;
          return typeof n == typeof s && n >= s;
        }], "filter-has": [ke, [je], (r, [t]) => t.value in r.properties()], "filter-has-id": [ke, [], (r) => r.id() !== null && r.id() !== void 0], "filter-type-in": [ke, [yi(De)], (r, [t]) => t.value.indexOf(r.geometryType()) >= 0], "filter-id-in": [ke, [yi(je)], (r, [t]) => t.value.indexOf(r.id()) >= 0], "filter-in-small": [ke, [De, yi(je)], (r, [t, n]) => n.value.indexOf(r.properties()[t.value]) >= 0], "filter-in-large": [ke, [De, yi(je)], (r, [t, n]) => function(s, l, d, p) {
          for (; d <= p; ) {
            const m = d + p >> 1;
            if (l[m] === s) return !0;
            l[m] > s ? p = m - 1 : d = m + 1;
          }
          return !1;
        }(r.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: ke, overloads: [[[ke, ke], (r, [t, n]) => t.evaluate(r) && n.evaluate(r)], [mn(ke), (r, t) => {
          for (const n of t) if (!n.evaluate(r)) return !1;
          return !0;
        }]] }, any: { type: ke, overloads: [[[ke, ke], (r, [t, n]) => t.evaluate(r) || n.evaluate(r)], [mn(ke), (r, t) => {
          for (const n of t) if (n.evaluate(r)) return !0;
          return !1;
        }]] }, "!": [ke, [ke], (r, [t]) => !t.evaluate(r)], "is-supported-script": [ke, [De], (r, [t]) => {
          const n = r.globals && r.globals.isSupportedScript;
          return !n || n(t.evaluate(r));
        }], upcase: [De, [De], (r, [t]) => t.evaluate(r).toUpperCase()], downcase: [De, [De], (r, [t]) => t.evaluate(r).toLowerCase()], concat: [De, mn(je), (r, t) => t.map((n) => Fr(n.evaluate(r))).join("")], "resolved-locale": [De, [on], (r, [t]) => t.evaluate(r).resolvedLocale()] });
        class xo {
          constructor(t, n) {
            var s;
            this.expression = t, this._warningHistory = {}, this._evaluator = new Ns(), this._defaultValue = n ? (s = n).type === "color" && aa(s.default) ? new st(0, 0, 0, 0) : s.type === "color" ? st.parse(s.default) || null : s.type === "padding" ? Ht.parse(s.default) || null : s.type === "variableAnchorOffsetCollection" ? Xt.parse(s.default) || null : s.type === "projectionDefinition" ? xi.parse(s.default) || null : s.default === void 0 ? null : s.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
          }
          evaluateWithoutErrorHandling(t, n, s, l, d, p) {
            return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = s, this._evaluator.canonical = l, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = p, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, s, l, d, p) {
            this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = s || null, this._evaluator.canonical = l, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = p || null;
            try {
              const m = this.expression.evaluate(this._evaluator);
              if (m == null || typeof m == "number" && m != m) return this._defaultValue;
              if (this._enumValues && !(m in this._enumValues)) throw new It(`Expected value to be one of ${Object.keys(this._enumValues).map((g) => JSON.stringify(g)).join(", ")}, but found ${JSON.stringify(m)} instead.`);
              return m;
            } catch (m) {
              return this._warningHistory[m.message] || (this._warningHistory[m.message] = !0, typeof console < "u" && console.warn(m.message)), this._defaultValue;
            }
          }
        }
        function oa(r) {
          return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Nn;
        }
        function gn(r, t) {
          const n = new it(Nn, ra, [], t ? function(l) {
            const d = { color: Ke, string: De, number: ye, enum: De, boolean: ke, formatted: Ft, padding: Nt, projectionDefinition: qe, resolvedImage: yt, variableAnchorOffsetCollection: Fs };
            return l.type === "array" ? yi(d[l.value] || je, l.length) : d[l.type];
          }(t) : void 0), s = n.parse(r, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return s ? zl(new xo(s, t)) : Zn(n.errors);
        }
        class la {
          constructor(t, n) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !xs(n.expression);
          }
          evaluateWithoutErrorHandling(t, n, s, l, d, p) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, l, d, p);
          }
          evaluate(t, n, s, l, d, p) {
            return this._styleExpression.evaluate(t, n, s, l, d, p);
          }
        }
        class vo {
          constructor(t, n, s, l) {
            this.kind = t, this.zoomStops = s, this._styleExpression = n, this.isStateDependent = t !== "camera" && !xs(n.expression), this.interpolationType = l;
          }
          evaluateWithoutErrorHandling(t, n, s, l, d, p) {
            return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, l, d, p);
          }
          evaluate(t, n, s, l, d, p) {
            return this._styleExpression.evaluate(t, n, s, l, d, p);
          }
          interpolationFactor(t, n, s) {
            return this.interpolationType ? ui.interpolationFactor(this.interpolationType, t, n, s) : 0;
          }
        }
        function Bl(r, t) {
          const n = gn(r, t);
          if (n.result === "error") return n;
          const s = n.value.expression, l = na(s);
          if (!l && !Un(t)) return Zn([new Be("", "data expressions not supported")]);
          const d = sa(s, ["zoom"]);
          if (!d && !kl(t)) return Zn([new Be("", "zoom expressions not supported")]);
          const p = ha(s);
          return p || d ? p instanceof Be ? Zn([p]) : p instanceof ui && !yo(t) ? Zn([new Be("", '"interpolate" expressions cannot be used with this property')]) : zl(p ? new vo(l ? "camera" : "composite", n.value, p.labels, p instanceof ui ? p.interpolation : void 0) : new la(l ? "constant" : "source", n.value)) : Zn([new Be("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class ca {
          constructor(t, n) {
            this._parameters = t, this._specification = n, Ce(this, Dl(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new ca(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function ha(r) {
          let t = null;
          if (r instanceof Xe) t = ha(r.result);
          else if (r instanceof Rt) {
            for (const n of r.args) if (t = ha(n), t) break;
          } else (r instanceof jn || r instanceof ui) && r.input instanceof Vi && r.input.name === "zoom" && (t = r);
          return t instanceof Be || r.eachChild((n) => {
            const s = ha(n);
            s instanceof Be ? t = s : !t && s ? t = new Be("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && s && t !== s && (t = new Be("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), t;
        }
        function bo(r) {
          if (r === !0 || r === !1) return !0;
          if (!Array.isArray(r) || r.length === 0) return !1;
          switch (r[0]) {
            case "has":
              return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
            case "in":
              return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
            case "any":
            case "all":
              for (const t of r.slice(1)) if (!bo(t) && typeof t != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const Fl = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function ua(r) {
          if (r == null) return { filter: () => !0, needGeometry: !1 };
          bo(r) || (r = vs(r));
          const t = gn(r, Fl);
          if (t.result === "error") throw new Error(t.value.map((n) => `${n.key}: ${n.message}`).join(", "));
          return { filter: (n, s, l) => t.value.evaluate(n, s, {}, l), needGeometry: Ol(r) };
        }
        function $c(r, t) {
          return r < t ? -1 : r > t ? 1 : 0;
        }
        function Ol(r) {
          if (!Array.isArray(r)) return !1;
          if (r[0] === "within" || r[0] === "distance") return !0;
          for (let t = 1; t < r.length; t++) if (Ol(r[t])) return !0;
          return !1;
        }
        function vs(r) {
          if (!r) return !0;
          const t = r[0];
          return r.length <= 1 ? t !== "any" : t === "==" ? da(r[1], r[2], "==") : t === "!=" ? Gn(da(r[1], r[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? da(r[1], r[2], t) : t === "any" ? (n = r.slice(1), ["any"].concat(n.map(vs))) : t === "all" ? ["all"].concat(r.slice(1).map(vs)) : t === "none" ? ["all"].concat(r.slice(1).map(vs).map(Gn)) : t === "in" ? wo(r[1], r.slice(2)) : t === "!in" ? Gn(wo(r[1], r.slice(2))) : t === "has" ? To(r[1]) : t !== "!has" || Gn(To(r[1]));
          var n;
        }
        function da(r, t, n) {
          switch (r) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, r, t];
          }
        }
        function wo(r, t) {
          if (t.length === 0) return !1;
          switch (r) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some((n) => typeof n != typeof t[0]) ? ["filter-in-large", r, ["literal", t.sort($c)]] : ["filter-in-small", r, ["literal", t]];
          }
        }
        function To(r) {
          switch (r) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", r];
          }
        }
        function Gn(r) {
          return ["!", r];
        }
        function bs(r) {
          const t = typeof r;
          if (t === "number" || t === "boolean" || t === "string" || r == null) return JSON.stringify(r);
          if (Array.isArray(r)) {
            let l = "[";
            for (const d of r) l += `${bs(d)},`;
            return `${l}]`;
          }
          const n = Object.keys(r).sort();
          let s = "{";
          for (let l = 0; l < n.length; l++) s += `${JSON.stringify(n[l])}:${bs(r[n[l]])},`;
          return `${s}}`;
        }
        function Po(r) {
          let t = "";
          for (const n of L) t += `/${bs(r[n])}`;
          return t;
        }
        function ws(r) {
          const t = r.value;
          return t ? [new ne(r.key, t, "constants have been deprecated as of v8")] : [];
        }
        function kt(r) {
          return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
        }
        function yn(r) {
          if (Array.isArray(r)) return r.map(yn);
          if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
            const t = {};
            for (const n in r) t[n] = yn(r[n]);
            return t;
          }
          return kt(r);
        }
        function Ni(r) {
          const t = r.key, n = r.value, s = r.valueSpec || {}, l = r.objectElementValidators || {}, d = r.style, p = r.styleSpec, m = r.validateSpec;
          let g = [];
          const x = at(n);
          if (x !== "object") return [new ne(t, n, `object expected, ${x} found`)];
          for (const b in n) {
            const w = b.split(".")[0], I = s[w] || s["*"];
            let E;
            if (l[w]) E = l[w];
            else if (s[w]) E = m;
            else if (l["*"]) E = l["*"];
            else {
              if (!s["*"]) {
                g.push(new ne(t, n[b], `unknown property "${b}"`));
                continue;
              }
              E = m;
            }
            g = g.concat(E({ key: (t && `${t}.`) + b, value: n[b], valueSpec: I, style: d, styleSpec: p, object: n, objectKey: b, validateSpec: m }, n));
          }
          for (const b in s) l[b] || s[b].required && s[b].default === void 0 && n[b] === void 0 && g.push(new ne(t, n, `missing required property "${b}"`));
          return g;
        }
        function So(r) {
          const t = r.value, n = r.valueSpec, s = r.style, l = r.styleSpec, d = r.key, p = r.arrayElementValidator || r.validateSpec;
          if (at(t) !== "array") return [new ne(d, t, `array expected, ${at(t)} found`)];
          if (n.length && t.length !== n.length) return [new ne(d, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new ne(d, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let m = { type: n.value, values: n.values };
          l.$version < 7 && (m.function = n.function), at(n.value) === "object" && (m = n.value);
          let g = [];
          for (let x = 0; x < t.length; x++) g = g.concat(p({ array: t, arrayIndex: x, value: t[x], valueSpec: m, validateSpec: r.validateSpec, style: s, styleSpec: l, key: `${d}[${x}]` }));
          return g;
        }
        function Mo(r) {
          const t = r.key, n = r.value, s = r.valueSpec;
          let l = at(n);
          return l === "number" && n != n && (l = "NaN"), l !== "number" ? [new ne(t, n, `number expected, ${l} found`)] : "minimum" in s && n < s.minimum ? [new ne(t, n, `${n} is less than the minimum value ${s.minimum}`)] : "maximum" in s && n > s.maximum ? [new ne(t, n, `${n} is greater than the maximum value ${s.maximum}`)] : [];
        }
        function jl(r) {
          const t = r.valueSpec, n = kt(r.value.type);
          let s, l, d, p = {};
          const m = n !== "categorical" && r.value.property === void 0, g = !m, x = at(r.value.stops) === "array" && at(r.value.stops[0]) === "array" && at(r.value.stops[0][0]) === "object", b = Ni({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, validateSpec: r.validateSpec, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function(E) {
            if (n === "identity") return [new ne(E.key, E.value, 'identity function may not have a "stops" property')];
            let A = [];
            const D = E.value;
            return A = A.concat(So({ key: E.key, value: D, valueSpec: E.valueSpec, validateSpec: E.validateSpec, style: E.style, styleSpec: E.styleSpec, arrayElementValidator: w })), at(D) === "array" && D.length === 0 && A.push(new ne(E.key, D, "array must have at least one stop")), A;
          }, default: function(E) {
            return E.validateSpec({ key: E.key, value: E.value, valueSpec: t, validateSpec: E.validateSpec, style: E.style, styleSpec: E.styleSpec });
          } } });
          return n === "identity" && m && b.push(new ne(r.key, r.value, 'missing required property "property"')), n === "identity" || r.value.stops || b.push(new ne(r.key, r.value, 'missing required property "stops"')), n === "exponential" && r.valueSpec.expression && !yo(r.valueSpec) && b.push(new ne(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (g && !Un(r.valueSpec) ? b.push(new ne(r.key, r.value, "property functions not supported")) : m && !kl(r.valueSpec) && b.push(new ne(r.key, r.value, "zoom functions not supported"))), n !== "categorical" && !x || r.value.property !== void 0 || b.push(new ne(r.key, r.value, '"property" property is required')), b;
          function w(E) {
            let A = [];
            const D = E.value, F = E.key;
            if (at(D) !== "array") return [new ne(F, D, `array expected, ${at(D)} found`)];
            if (D.length !== 2) return [new ne(F, D, `array length 2 expected, length ${D.length} found`)];
            if (x) {
              if (at(D[0]) !== "object") return [new ne(F, D, `object expected, ${at(D[0])} found`)];
              if (D[0].zoom === void 0) return [new ne(F, D, "object stop key must have zoom")];
              if (D[0].value === void 0) return [new ne(F, D, "object stop key must have value")];
              if (d && d > kt(D[0].zoom)) return [new ne(F, D[0].zoom, "stop zoom values must appear in ascending order")];
              kt(D[0].zoom) !== d && (d = kt(D[0].zoom), l = void 0, p = {}), A = A.concat(Ni({ key: `${F}[0]`, value: D[0], valueSpec: { zoom: {} }, validateSpec: E.validateSpec, style: E.style, styleSpec: E.styleSpec, objectElementValidators: { zoom: Mo, value: I } }));
            } else A = A.concat(I({ key: `${F}[0]`, value: D[0], validateSpec: E.validateSpec, style: E.style, styleSpec: E.styleSpec }, D));
            return oa(yn(D[1])) ? A.concat([new ne(`${F}[1]`, D[1], "expressions are not allowed in function stops.")]) : A.concat(E.validateSpec({ key: `${F}[1]`, value: D[1], valueSpec: t, validateSpec: E.validateSpec, style: E.style, styleSpec: E.styleSpec }));
          }
          function I(E, A) {
            const D = at(E.value), F = kt(E.value), Z = E.value !== null ? E.value : A;
            if (s) {
              if (D !== s) return [new ne(E.key, Z, `${D} stop domain type must match previous stop domain type ${s}`)];
            } else s = D;
            if (D !== "number" && D !== "string" && D !== "boolean") return [new ne(E.key, Z, "stop domain value must be a number, string, or boolean")];
            if (D !== "number" && n !== "categorical") {
              let Y = `number expected, ${D} found`;
              return Un(t) && n === void 0 && (Y += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ne(E.key, Z, Y)];
            }
            return n !== "categorical" || D !== "number" || isFinite(F) && Math.floor(F) === F ? n !== "categorical" && D === "number" && l !== void 0 && F < l ? [new ne(E.key, Z, "stop domain values must appear in ascending order")] : (l = F, n === "categorical" && F in p ? [new ne(E.key, Z, "stop domain values must be unique")] : (p[F] = !0, [])) : [new ne(E.key, Z, `integer expected, found ${F}`)];
          }
        }
        function xn(r) {
          const t = (r.expressionContext === "property" ? Bl : gn)(yn(r.value), r.valueSpec);
          if (t.result === "error") return t.value.map((s) => new ne(`${r.key}${s.key}`, r.value, s.message));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (r.expressionContext === "property" && r.propertyKey === "text-font" && !n.outputDefined()) return [new ne(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (r.expressionContext === "property" && r.propertyType === "layout" && !xs(n)) return [new ne(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (r.expressionContext === "filter" && !xs(n)) return [new ne(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
          if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
            if (!sa(n, ["zoom", "feature-state"])) return [new ne(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (r.expressionContext === "cluster-initial" && !na(n)) return [new ne(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function $n(r) {
          const t = r.key, n = r.value, s = r.valueSpec, l = [];
          return Array.isArray(s.values) ? s.values.indexOf(kt(n)) === -1 && l.push(new ne(t, n, `expected one of [${s.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(s.values).indexOf(kt(n)) === -1 && l.push(new ne(t, n, `expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(n)} found`)), l;
        }
        function qn(r) {
          return bo(yn(r.value)) ? xn(Ce({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Vl(r);
        }
        function Vl(r) {
          const t = r.value, n = r.key;
          if (at(t) !== "array") return [new ne(n, t, `array expected, ${at(t)} found`)];
          const s = r.styleSpec;
          let l, d = [];
          if (t.length < 1) return [new ne(n, t, "filter array must have at least 1 element")];
          switch (d = d.concat($n({ key: `${n}[0]`, value: t[0], valueSpec: s.filter_operator, style: r.style, styleSpec: r.styleSpec })), kt(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && kt(t[1]) === "$type" && d.push(new ne(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && d.push(new ne(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (l = at(t[1]), l !== "string" && d.push(new ne(`${n}[1]`, t[1], `string expected, ${l} found`)));
              for (let p = 2; p < t.length; p++) l = at(t[p]), kt(t[1]) === "$type" ? d = d.concat($n({ key: `${n}[${p}]`, value: t[p], valueSpec: s.geometry_type, style: r.style, styleSpec: r.styleSpec })) : l !== "string" && l !== "number" && l !== "boolean" && d.push(new ne(`${n}[${p}]`, t[p], `string, number, or boolean expected, ${l} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let p = 1; p < t.length; p++) d = d.concat(Vl({ key: `${n}[${p}]`, value: t[p], style: r.style, styleSpec: r.styleSpec }));
              break;
            case "has":
            case "!has":
              l = at(t[1]), t.length !== 2 ? d.push(new ne(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : l !== "string" && d.push(new ne(`${n}[1]`, t[1], `string expected, ${l} found`));
          }
          return d;
        }
        function Io(r, t) {
          const n = r.key, s = r.validateSpec, l = r.style, d = r.styleSpec, p = r.value, m = r.objectKey, g = d[`${t}_${r.layerType}`];
          if (!g) return [];
          const x = m.match(/^(.*)-transition$/);
          if (t === "paint" && x && g[x[1]] && g[x[1]].transition) return s({ key: n, value: p, valueSpec: d.transition, style: l, styleSpec: d });
          const b = r.valueSpec || g[m];
          if (!b) return [new ne(n, p, `unknown property "${m}"`)];
          let w;
          if (at(p) === "string" && Un(b) && !b.tokens && (w = /^{([^}]+)}$/.exec(p))) return [new ne(n, p, `"${m}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(w[1])} }\`.`)];
          const I = [];
          return r.layerType === "symbol" && (m === "text-field" && l && !l.glyphs && I.push(new ne(n, p, 'use of "text-field" requires a style "glyphs" property')), m === "text-font" && aa(yn(p)) && kt(p.type) === "identity" && I.push(new ne(n, p, '"text-font" does not support identity functions'))), I.concat(s({ key: r.key, value: p, valueSpec: b, style: l, styleSpec: d, expressionContext: "property", propertyType: t, propertyKey: m }));
        }
        function Co(r) {
          return Io(r, "paint");
        }
        function Nl(r) {
          return Io(r, "layout");
        }
        function Eo(r) {
          let t = [];
          const n = r.value, s = r.key, l = r.style, d = r.styleSpec;
          n.type || n.ref || t.push(new ne(s, n, 'either "type" or "ref" is required'));
          let p = kt(n.type);
          const m = kt(n.ref);
          if (n.id) {
            const g = kt(n.id);
            for (let x = 0; x < r.arrayIndex; x++) {
              const b = l.layers[x];
              kt(b.id) === g && t.push(new ne(s, n.id, `duplicate layer id "${n.id}", previously used at line ${b.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let g;
            ["type", "source", "source-layer", "filter", "layout"].forEach((x) => {
              x in n && t.push(new ne(s, n[x], `"${x}" is prohibited for ref layers`));
            }), l.layers.forEach((x) => {
              kt(x.id) === m && (g = x);
            }), g ? g.ref ? t.push(new ne(s, n.ref, "ref cannot reference another ref layer")) : p = kt(g.type) : t.push(new ne(s, n.ref, `ref layer "${m}" not found`));
          } else if (p !== "background") if (n.source) {
            const g = l.sources && l.sources[n.source], x = g && kt(g.type);
            g ? x === "vector" && p === "raster" ? t.push(new ne(s, n.source, `layer "${n.id}" requires a raster source`)) : x !== "raster-dem" && p === "hillshade" ? t.push(new ne(s, n.source, `layer "${n.id}" requires a raster-dem source`)) : x === "raster" && p !== "raster" ? t.push(new ne(s, n.source, `layer "${n.id}" requires a vector source`)) : x !== "vector" || n["source-layer"] ? x === "raster-dem" && p !== "hillshade" ? t.push(new ne(s, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : p !== "line" || !n.paint || !n.paint["line-gradient"] || x === "geojson" && g.lineMetrics || t.push(new ne(s, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ne(s, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new ne(s, n.source, `source "${n.source}" not found`));
          } else t.push(new ne(s, n, 'missing required property "source"'));
          return t = t.concat(Ni({ key: s, value: n, valueSpec: d.layer, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, objectElementValidators: { "*": () => [], type: () => r.validateSpec({ key: `${s}.type`, value: n.type, valueSpec: d.layer.type, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, object: n, objectKey: "type" }), filter: qn, layout: (g) => Ni({ layer: n, key: g.key, value: g.value, style: g.style, styleSpec: g.styleSpec, validateSpec: g.validateSpec, objectElementValidators: { "*": (x) => Nl(Ce({ layerType: p }, x)) } }), paint: (g) => Ni({ layer: n, key: g.key, value: g.value, style: g.style, styleSpec: g.styleSpec, validateSpec: g.validateSpec, objectElementValidators: { "*": (x) => Co(Ce({ layerType: p }, x)) } }) } })), t;
        }
        function jr(r) {
          const t = r.value, n = r.key, s = at(t);
          return s !== "string" ? [new ne(n, t, `string expected, ${s} found`)] : [];
        }
        const Wn = { promoteId: function({ key: r, value: t }) {
          if (at(t) === "string") return jr({ key: r, value: t });
          {
            const n = [];
            for (const s in t) n.push(...jr({ key: `${r}.${s}`, value: t[s] }));
            return n;
          }
        } };
        function Zl(r) {
          const t = r.value, n = r.key, s = r.styleSpec, l = r.style, d = r.validateSpec;
          if (!t.type) return [new ne(n, t, '"type" is required')];
          const p = kt(t.type);
          let m;
          switch (p) {
            case "vector":
            case "raster":
              return m = Ni({ key: n, value: t, valueSpec: s[`source_${p.replace("-", "_")}`], style: r.style, styleSpec: s, objectElementValidators: Wn, validateSpec: d }), m;
            case "raster-dem":
              return m = function(g) {
                var x;
                const b = (x = g.sourceName) !== null && x !== void 0 ? x : "", w = g.value, I = g.styleSpec, E = I.source_raster_dem, A = g.style;
                let D = [];
                const F = at(w);
                if (w === void 0) return D;
                if (F !== "object") return D.push(new ne("source_raster_dem", w, `object expected, ${F} found`)), D;
                const Z = kt(w.encoding) === "custom", Y = ["redFactor", "greenFactor", "blueFactor", "baseShift"], $ = g.value.encoding ? `"${g.value.encoding}"` : "Default";
                for (const C in w) !Z && Y.includes(C) ? D.push(new ne(C, w[C], `In "${b}": "${C}" is only valid when "encoding" is set to "custom". ${$} encoding found`)) : E[C] ? D = D.concat(g.validateSpec({ key: C, value: w[C], valueSpec: E[C], validateSpec: g.validateSpec, style: A, styleSpec: I })) : D.push(new ne(C, w[C], `unknown property "${C}"`));
                return D;
              }({ sourceName: n, value: t, style: r.style, styleSpec: s, validateSpec: d }), m;
            case "geojson":
              if (m = Ni({ key: n, value: t, valueSpec: s.source_geojson, style: l, styleSpec: s, validateSpec: d, objectElementValidators: Wn }), t.cluster) for (const g in t.clusterProperties) {
                const [x, b] = t.clusterProperties[g], w = typeof x == "string" ? [x, ["accumulated"], ["get", g]] : x;
                m.push(...xn({ key: `${n}.${g}.map`, value: b, expressionContext: "cluster-map" })), m.push(...xn({ key: `${n}.${g}.reduce`, value: w, expressionContext: "cluster-reduce" }));
              }
              return m;
            case "video":
              return Ni({ key: n, value: t, valueSpec: s.source_video, style: l, validateSpec: d, styleSpec: s });
            case "image":
              return Ni({ key: n, value: t, valueSpec: s.source_image, style: l, validateSpec: d, styleSpec: s });
            case "canvas":
              return [new ne(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return $n({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Ul(r) {
          const t = r.value, n = r.styleSpec, s = n.light, l = r.style;
          let d = [];
          const p = at(t);
          if (t === void 0) return d;
          if (p !== "object") return d = d.concat([new ne("light", t, `object expected, ${p} found`)]), d;
          for (const m in t) {
            const g = m.match(/^(.*)-transition$/);
            d = d.concat(g && s[g[1]] && s[g[1]].transition ? r.validateSpec({ key: m, value: t[m], valueSpec: n.transition, validateSpec: r.validateSpec, style: l, styleSpec: n }) : s[m] ? r.validateSpec({ key: m, value: t[m], valueSpec: s[m], validateSpec: r.validateSpec, style: l, styleSpec: n }) : [new ne(m, t[m], `unknown property "${m}"`)]);
          }
          return d;
        }
        function Gl(r) {
          const t = r.value, n = r.styleSpec, s = n.sky, l = r.style, d = at(t);
          if (t === void 0) return [];
          if (d !== "object") return [new ne("sky", t, `object expected, ${d} found`)];
          let p = [];
          for (const m in t) p = p.concat(s[m] ? r.validateSpec({ key: m, value: t[m], valueSpec: s[m], style: l, styleSpec: n }) : [new ne(m, t[m], `unknown property "${m}"`)]);
          return p;
        }
        function $l(r) {
          const t = r.value, n = r.styleSpec, s = n.terrain, l = r.style;
          let d = [];
          const p = at(t);
          if (t === void 0) return d;
          if (p !== "object") return d = d.concat([new ne("terrain", t, `object expected, ${p} found`)]), d;
          for (const m in t) d = d.concat(s[m] ? r.validateSpec({ key: m, value: t[m], valueSpec: s[m], validateSpec: r.validateSpec, style: l, styleSpec: n }) : [new ne(m, t[m], `unknown property "${m}"`)]);
          return d;
        }
        function ql(r) {
          let t = [];
          const n = r.value, s = r.key;
          if (Array.isArray(n)) {
            const l = [], d = [];
            for (const p in n) n[p].id && l.includes(n[p].id) && t.push(new ne(s, n, `all the sprites' ids must be unique, but ${n[p].id} is duplicated`)), l.push(n[p].id), n[p].url && d.includes(n[p].url) && t.push(new ne(s, n, `all the sprites' URLs must be unique, but ${n[p].url} is duplicated`)), d.push(n[p].url), t = t.concat(Ni({ key: `${s}[${p}]`, value: n[p], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: r.validateSpec }));
            return t;
          }
          return jr({ key: s, value: n });
        }
        const Wl = { "*": () => [], array: So, boolean: function(r) {
          const t = r.value, n = r.key, s = at(t);
          return s !== "boolean" ? [new ne(n, t, `boolean expected, ${s} found`)] : [];
        }, number: Mo, color: function(r) {
          const t = r.key, n = r.value, s = at(n);
          return s !== "string" ? [new ne(t, n, `color expected, ${s} found`)] : st.parse(String(n)) ? [] : [new ne(t, n, `color expected, "${n}" found`)];
        }, constants: ws, enum: $n, filter: qn, function: jl, layer: Eo, object: Ni, source: Zl, light: Ul, sky: Gl, terrain: $l, projection: function(r) {
          const t = r.value, n = r.styleSpec, s = n.projection, l = r.style, d = at(t);
          if (t === void 0) return [];
          if (d !== "object") return [new ne("projection", t, `object expected, ${d} found`)];
          let p = [];
          for (const m in t) p = p.concat(s[m] ? r.validateSpec({ key: m, value: t[m], valueSpec: s[m], style: l, styleSpec: n }) : [new ne(m, t[m], `unknown property "${m}"`)]);
          return p;
        }, projectionDefinition: function(r) {
          const t = r.key;
          let n = r.value;
          n = n instanceof String ? n.valueOf() : n;
          const s = at(n);
          return s !== "array" || function(l) {
            return Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number";
          }(n) || function(l) {
            return !!["interpolate", "step", "literal"].includes(l[0]);
          }(n) ? ["array", "string"].includes(s) ? [] : [new ne(t, n, `projection expected, invalid type "${s}" found`)] : [new ne(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: jr, formatted: function(r) {
          return jr(r).length === 0 ? [] : xn(r);
        }, resolvedImage: function(r) {
          return jr(r).length === 0 ? [] : xn(r);
        }, padding: function(r) {
          const t = r.key, n = r.value;
          if (at(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new ne(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const s = { type: "number" };
            let l = [];
            for (let d = 0; d < n.length; d++) l = l.concat(r.validateSpec({ key: `${t}[${d}]`, value: n[d], validateSpec: r.validateSpec, valueSpec: s }));
            return l;
          }
          return Mo({ key: t, value: n, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(r) {
          const t = r.key, n = r.value, s = at(n), l = r.styleSpec;
          if (s !== "array" || n.length < 1 || n.length % 2 != 0) return [new ne(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let d = [];
          for (let p = 0; p < n.length; p += 2) d = d.concat($n({ key: `${t}[${p}]`, value: n[p], valueSpec: l.layout_symbol["text-anchor"] })), d = d.concat(So({ key: `${t}[${p + 1}]`, value: n[p + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r.validateSpec, style: r.style, styleSpec: l }));
          return d;
        }, sprite: ql };
        function Vr(r) {
          const t = r.value, n = r.valueSpec, s = r.styleSpec;
          return r.validateSpec = Vr, n.expression && aa(kt(t)) ? jl(r) : n.expression && oa(yn(t)) ? xn(r) : n.type && Wl[n.type] ? Wl[n.type](r) : Ni(Ce({}, r, { valueSpec: n.type ? s[n.type] : n }));
        }
        function Hn(r) {
          const t = r.value, n = r.key, s = jr(r);
          return s.length || (t.indexOf("{fontstack}") === -1 && s.push(new ne(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && s.push(new ne(n, t, '"glyphs" url must include a "{range}" token'))), s;
        }
        function Ct(r, t = P) {
          let n = [];
          return n = n.concat(Vr({ key: "", value: r, valueSpec: t.$root, styleSpec: t, style: r, validateSpec: Vr, objectElementValidators: { glyphs: Hn, "*": () => [] } })), r.constants && (n = n.concat(ws({ key: "constants", value: r.constants }))), Ao(n);
        }
        function bi(r) {
          return function(t) {
            return r({ ...t, validateSpec: Vr });
          };
        }
        function Ao(r) {
          return [].concat(r).sort((t, n) => t.line - n.line);
        }
        function lr(r) {
          return function(...t) {
            return Ao(r.apply(this, t));
          };
        }
        Ct.source = lr(bi(Zl)), Ct.sprite = lr(bi(ql)), Ct.glyphs = lr(bi(Hn)), Ct.light = lr(bi(Ul)), Ct.sky = lr(bi(Gl)), Ct.terrain = lr(bi($l)), Ct.layer = lr(bi(Eo)), Ct.filter = lr(bi(qn)), Ct.paintProperty = lr(bi(Co)), Ct.layoutProperty = lr(bi(Nl));
        const Xn = Ct, Ts = Xn.light, Hl = Xn.sky, zo = Xn.paintProperty, qc = Xn.layoutProperty;
        function pa(r, t) {
          let n = !1;
          if (t && t.length) for (const s of t) r.fire(new yr(new Error(s.message))), n = !0;
          return n;
        }
        class Ps {
          constructor(t, n, s) {
            const l = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const p = new Int32Array(this.arrayBuffer);
              t = p[0], this.d = (n = p[1]) + 2 * (s = p[2]);
              for (let g = 0; g < this.d * this.d; g++) {
                const x = p[3 + g], b = p[3 + g + 1];
                l.push(x === b ? null : p.subarray(x, b));
              }
              const m = p[3 + l.length + 1];
              this.keys = p.subarray(p[3 + l.length], m), this.bboxes = p.subarray(m), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * s;
              for (let p = 0; p < this.d * this.d; p++) l.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = s, this.scale = n / t, this.uid = 0;
            const d = s / n * t;
            this.min = -d, this.max = t + d;
          }
          insert(t, n, s, l, d) {
            this._forEachCell(n, s, l, d, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(d);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, s, l, d, p) {
            this.cells[d].push(p);
          }
          query(t, n, s, l, d) {
            const p = this.min, m = this.max;
            if (t <= p && n <= p && m <= s && m <= l && !d) return Array.prototype.slice.call(this.keys);
            {
              const g = [];
              return this._forEachCell(t, n, s, l, this._queryCell, g, {}, d), g;
            }
          }
          _queryCell(t, n, s, l, d, p, m, g) {
            const x = this.cells[d];
            if (x !== null) {
              const b = this.keys, w = this.bboxes;
              for (let I = 0; I < x.length; I++) {
                const E = x[I];
                if (m[E] === void 0) {
                  const A = 4 * E;
                  (g ? g(w[A + 0], w[A + 1], w[A + 2], w[A + 3]) : t <= w[A + 2] && n <= w[A + 3] && s >= w[A + 0] && l >= w[A + 1]) ? (m[E] = !0, p.push(b[E])) : m[E] = !1;
                }
              }
            }
          }
          _forEachCell(t, n, s, l, d, p, m, g) {
            const x = this._convertToCellCoord(t), b = this._convertToCellCoord(n), w = this._convertToCellCoord(s), I = this._convertToCellCoord(l);
            for (let E = x; E <= w; E++) for (let A = b; A <= I; A++) {
              const D = this.d * A + E;
              if ((!g || g(this._convertFromCellCoord(E), this._convertFromCellCoord(A), this._convertFromCellCoord(E + 1), this._convertFromCellCoord(A + 1))) && d.call(this, t, n, s, l, D, p, m, g)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let s = 0;
            for (let p = 0; p < this.cells.length; p++) s += this.cells[p].length;
            const l = new Int32Array(n + s + this.keys.length + this.bboxes.length);
            l[0] = this.extent, l[1] = this.n, l[2] = this.padding;
            let d = n;
            for (let p = 0; p < t.length; p++) {
              const m = t[p];
              l[3 + p] = d, l.set(m, d), d += m.length;
            }
            return l[3 + t.length] = d, l.set(this.keys, d), d += this.keys.length, l[3 + t.length + 1] = d, l.set(this.bboxes, d), d += this.bboxes.length, l.buffer;
          }
          static serialize(t, n) {
            const s = t.toArrayBuffer();
            return n && n.push(s), { buffer: s };
          }
          static deserialize(t) {
            return new Ps(t.buffer);
          }
        }
        const Ii = {};
        function Ae(r, t, n = {}) {
          if (Ii[r]) throw new Error(`${r} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: r, writeable: !1 }), Ii[r] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        Ae("Object", Object), Ae("TransferableGridIndex", Ps), Ae("Color", st), Ae("Error", Error), Ae("AJAXError", _r), Ae("ResolvedImage", _i), Ae("StylePropertyFunction", ca), Ae("StyleExpression", xo, { omit: ["_evaluator"] }), Ae("ZoomDependentExpression", vo), Ae("ZoomConstantExpression", la), Ae("CompoundExpression", Vi, { omit: ["_evaluate"] });
        for (const r in Nn) Nn[r]._classRegistryKey || Ae(`Expression_${r}`, Nn[r]);
        function Kn(r) {
          return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
        }
        function ko(r) {
          return r.$name || r.constructor._classRegistryKey;
        }
        function Xl(r) {
          return !function(t) {
            if (t === null || typeof t != "object") return !1;
            const n = ko(t);
            return !(!n || n === "Object");
          }(r) && (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || r instanceof Blob || r instanceof Error || Kn(r) || tn(r) || ArrayBuffer.isView(r) || r instanceof ImageData);
        }
        function Nr(r, t) {
          if (Xl(r)) return (Kn(r) || tn(r)) && t && t.push(r), ArrayBuffer.isView(r) && t && t.push(r.buffer), r instanceof ImageData && t && t.push(r.data.buffer), r;
          if (Array.isArray(r)) {
            const d = [];
            for (const p of r) d.push(Nr(p, t));
            return d;
          }
          if (typeof r != "object") throw new Error("can't serialize object of type " + typeof r);
          const n = ko(r);
          if (!n) throw new Error(`can't serialize object of unregistered class ${r.constructor.name}`);
          if (!Ii[n]) throw new Error(`${n} is not registered.`);
          const { klass: s } = Ii[n], l = s.serialize ? s.serialize(r, t) : {};
          if (s.serialize) {
            if (t && l === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const d in r) {
              if (!r.hasOwnProperty(d) || Ii[n].omit.indexOf(d) >= 0) continue;
              const p = r[d];
              l[d] = Ii[n].shallow.indexOf(d) >= 0 ? p : Nr(p, t);
            }
            r instanceof Error && (l.message = r.message);
          }
          if (l.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (l.$name = n), l;
        }
        function Ss(r) {
          if (Xl(r)) return r;
          if (Array.isArray(r)) return r.map(Ss);
          if (typeof r != "object") throw new Error("can't deserialize object of type " + typeof r);
          const t = ko(r) || "Object";
          if (!Ii[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = Ii[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(r);
          const s = Object.create(n.prototype);
          for (const l of Object.keys(r)) {
            if (l === "$name") continue;
            const d = r[l];
            s[l] = Ii[t].shallow.indexOf(l) >= 0 ? d : Ss(d);
          }
          return s;
        }
        class fa {
          constructor() {
            this.first = !0;
          }
          update(t, n) {
            const s = Math.floor(t);
            return this.first ? (this.first = !1, this.lastIntegerZoom = s, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = s, !0) : (this.lastFloorZoom > s ? (this.lastIntegerZoom = s + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < s && (this.lastIntegerZoom = s, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = s, !0));
          }
        }
        const Ye = { "Latin-1 Supplement": (r) => r >= 128 && r <= 255, "Hangul Jamo": (r) => r >= 4352 && r <= 4607, Khmer: (r) => r >= 6016 && r <= 6143, "General Punctuation": (r) => r >= 8192 && r <= 8303, "Letterlike Symbols": (r) => r >= 8448 && r <= 8527, "Number Forms": (r) => r >= 8528 && r <= 8591, "Miscellaneous Technical": (r) => r >= 8960 && r <= 9215, "Control Pictures": (r) => r >= 9216 && r <= 9279, "Optical Character Recognition": (r) => r >= 9280 && r <= 9311, "Enclosed Alphanumerics": (r) => r >= 9312 && r <= 9471, "Geometric Shapes": (r) => r >= 9632 && r <= 9727, "Miscellaneous Symbols": (r) => r >= 9728 && r <= 9983, "Miscellaneous Symbols and Arrows": (r) => r >= 11008 && r <= 11263, "Ideographic Description Characters": (r) => r >= 12272 && r <= 12287, "CJK Symbols and Punctuation": (r) => r >= 12288 && r <= 12351, Hiragana: (r) => r >= 12352 && r <= 12447, Katakana: (r) => r >= 12448 && r <= 12543, Kanbun: (r) => r >= 12688 && r <= 12703, "CJK Strokes": (r) => r >= 12736 && r <= 12783, "Enclosed CJK Letters and Months": (r) => r >= 12800 && r <= 13055, "CJK Compatibility": (r) => r >= 13056 && r <= 13311, "Yijing Hexagram Symbols": (r) => r >= 19904 && r <= 19967, "CJK Unified Ideographs": (r) => r >= 19968 && r <= 40959, "Hangul Syllables": (r) => r >= 44032 && r <= 55215, "Private Use Area": (r) => r >= 57344 && r <= 63743, "Vertical Forms": (r) => r >= 65040 && r <= 65055, "CJK Compatibility Forms": (r) => r >= 65072 && r <= 65103, "Small Form Variants": (r) => r >= 65104 && r <= 65135, "Halfwidth and Fullwidth Forms": (r) => r >= 65280 && r <= 65519 };
        function ma(r) {
          for (const t of r) if (Lo(t.charCodeAt(0))) return !0;
          return !1;
        }
        function Kl(r) {
          for (const t of r) if (!Do(t.charCodeAt(0))) return !1;
          return !0;
        }
        function _a(r) {
          const t = r.map((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          }).filter((n) => n);
          return new RegExp(t.join("|"), "u");
        }
        const Jl = _a(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Do(r) {
          return !Jl.test(String.fromCodePoint(r));
        }
        const Ro = _a(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Lo(r) {
          return !(r !== 746 && r !== 747 && (r < 4352 || !(Ye["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || Ye["CJK Compatibility"](r) || Ye["CJK Strokes"](r) || !(!Ye["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || Ye["Enclosed CJK Letters and Months"](r) || Ye["Ideographic Description Characters"](r) || Ye.Kanbun(r) || Ye.Katakana(r) && r !== 12540 || !(!Ye["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!Ye["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || Ye["Vertical Forms"](r) || Ye["Yijing Hexagram Symbols"](r) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(r)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(r)) || Ro.test(String.fromCodePoint(r)))));
        }
        function Bo(r) {
          return !(Lo(r) || function(t) {
            return !!(Ye["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || Ye["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || Ye["Letterlike Symbols"](t) || Ye["Number Forms"](t) || Ye["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Ye["Control Pictures"](t) && t !== 9251 || Ye["Optical Character Recognition"](t) || Ye["Enclosed Alphanumerics"](t) || Ye["Geometric Shapes"](t) || Ye["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Ye["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Ye["CJK Symbols and Punctuation"](t) || Ye.Katakana(t) || Ye["Private Use Area"](t) || Ye["CJK Compatibility Forms"](t) || Ye["Small Form Variants"](t) || Ye["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          }(r));
        }
        const Wc = _a(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Fo(r) {
          return Wc.test(String.fromCodePoint(r));
        }
        function Yl(r, t) {
          return !(!t && Fo(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || Ye.Khmer(r));
        }
        function Ql(r) {
          for (const t of r) if (Fo(t.charCodeAt(0))) return !0;
          return !1;
        }
        const Zr = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(r) {
            this.pluginStatus = r.pluginStatus, this.pluginURL = r.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(r) {
            if (Zr.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = r.applyArabicShaping, this.processBidirectionalText = r.processBidirectionalText, this.processStyledBidirectionalText = r.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(r, t) {
            return c(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if (r.pluginStatus !== "loading") return this.setState(r), r;
              const n = r.pluginURL, s = new Promise((d) => {
                this.loadScriptResolve = d;
              });
              t(n);
              const l = new Promise((d) => setTimeout(() => d(), this.TIMEOUT));
              if (yield Promise.race([s, l]), this.isParsed()) {
                const d = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(d), d;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            });
          }
        }();
        class Tt {
          constructor(t, n) {
            this.zoom = t, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new fa(), this.transition = {});
          }
          isSupportedScript(t) {
            return function(n, s) {
              for (const l of n) if (!Yl(l.charCodeAt(0), s)) return !1;
              return !0;
            }(t, Zr.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), s = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * s } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - s) * n };
          }
        }
        class Ms {
          constructor(t, n) {
            this.property = t, this.value = n, this.expression = function(s, l) {
              if (aa(s)) return new ca(s, l);
              if (oa(s)) {
                const d = Bl(s, l);
                if (d.result === "error") throw new Error(d.value.map((p) => `${p.key}: ${p.message}`).join(", "));
                return d.value;
              }
              {
                let d = s;
                return l.type === "color" && typeof s == "string" ? d = st.parse(s) : l.type !== "padding" || typeof s != "number" && !Array.isArray(s) ? l.type === "variableAnchorOffsetCollection" && Array.isArray(s) ? d = Xt.parse(s) : l.type === "projectionDefinition" && typeof s == "string" && (d = xi.parse(s)) : d = Ht.parse(s), { kind: "constant", evaluate: () => d };
              }
            }(n === void 0 ? t.specification.default : n, t.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(t, n, s) {
            return this.property.possiblyEvaluate(this, t, n, s);
          }
        }
        class ga {
          constructor(t) {
            this.property = t, this.value = new Ms(t, void 0);
          }
          transitioned(t, n) {
            return new jo(this.property, this.value, n, ii({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new jo(this.property, this.value, null, {}, 0);
          }
        }
        class Oo {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
          }
          getValue(t) {
            return Pi(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ga(this._values[t].property)), this._values[t].value = new Ms(this._values[t].property, n === null ? void 0 : Pi(n));
          }
          getTransition(t) {
            return Pi(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ga(this._values[t].property)), this._values[t].transition = Pi(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const s = this.getValue(n);
              s !== void 0 && (t[n] = s);
              const l = this.getTransition(n);
              l !== void 0 && (t[`${n}-transition`] = l);
            }
            return t;
          }
          transitioned(t, n) {
            const s = new Is(this._properties);
            for (const l of Object.keys(this._values)) s._values[l] = this._values[l].transitioned(t, n._values[l]);
            return s;
          }
          untransitioned() {
            const t = new Is(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class jo {
          constructor(t, n, s, l, d) {
            this.property = t, this.value = n, this.begin = d + l.delay || 0, this.end = this.begin + l.duration || 0, t.specification.transition && (l.delay || l.duration) && (this.prior = s);
          }
          possiblyEvaluate(t, n, s) {
            const l = t.now || 0, d = this.value.possiblyEvaluate(t, n, s), p = this.prior;
            if (p) {
              if (l > this.end) return this.prior = null, d;
              if (this.value.isDataDriven()) return this.prior = null, d;
              if (l < this.begin) return p.possiblyEvaluate(t, n, s);
              {
                const m = (l - this.begin) / (this.end - this.begin);
                return this.property.interpolate(p.possiblyEvaluate(t, n, s), d, Jr(m));
              }
            }
            return d;
          }
        }
        class Is {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, s) {
            const l = new ya(this._properties);
            for (const d of Object.keys(this._values)) l._values[d] = this._values[d].possiblyEvaluate(t, n, s);
            return l;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
            return !1;
          }
        }
        class Hc {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues);
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return Pi(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new Ms(this._values[t].property, n === null ? void 0 : Pi(n));
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const s = this.getValue(n);
              s !== void 0 && (t[n] = s);
            }
            return t;
          }
          possiblyEvaluate(t, n, s) {
            const l = new ya(this._properties);
            for (const d of Object.keys(this._values)) l._values[d] = this._values[d].possiblyEvaluate(t, n, s);
            return l;
          }
        }
        class Zi {
          constructor(t, n, s) {
            this.property = t, this.value = n, this.parameters = s;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, s, l) {
            return this.property.evaluate(this.value, this.parameters, t, n, s, l);
          }
        }
        class ya {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class Fe {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, s) {
            const l = Mi[this.specification.type];
            return l ? l(t, n, s) : t;
          }
        }
        class Ge {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, s, l) {
            return new Zi(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, s, l) } : t.expression, n);
          }
          interpolate(t, n, s) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new Zi(this, { kind: "constant", value: void 0 }, t.parameters);
            const l = Mi[this.specification.type];
            if (l) {
              const d = l(t.value.value, n.value.value, s);
              return new Zi(this, { kind: "constant", value: d }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, s, l, d, p) {
            return t.kind === "constant" ? t.value : t.evaluate(n, s, l, d, p);
          }
        }
        class Cs extends Ge {
          possiblyEvaluate(t, n, s, l) {
            if (t.value === void 0) return new Zi(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const d = t.expression.evaluate(n, null, {}, s, l), p = t.property.specification.type === "resolvedImage" && typeof d != "string" ? d.name : d, m = this._calculate(p, p, p, n);
              return new Zi(this, { kind: "constant", value: m }, n);
            }
            if (t.expression.kind === "camera") {
              const d = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new Zi(this, { kind: "constant", value: d }, n);
            }
            return new Zi(this, t.expression, n);
          }
          evaluate(t, n, s, l, d, p) {
            if (t.kind === "source") {
              const m = t.evaluate(n, s, l, d, p);
              return this._calculate(m, m, m, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, s, l), t.evaluate({ zoom: Math.floor(n.zoom) }, s, l), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, s, l), n) : t.value;
          }
          _calculate(t, n, s, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: s, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class xa {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, s, l) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const d = t.expression.evaluate(n, null, {}, s, l);
                return this._calculate(d, d, d, n);
              }
              return this._calculate(t.expression.evaluate(new Tt(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Tt(Math.floor(n.zoom), n)), t.expression.evaluate(new Tt(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, s, l) {
            return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: s, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class Vo {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, s, l) {
            return !!t.expression.evaluate(n, null, {}, s, l);
          }
          interpolate() {
            return !1;
          }
        }
        class wi {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const s = t[n];
              s.specification.overridable && this.overridableProperties.push(n);
              const l = this.defaultPropertyValues[n] = new Ms(s, void 0), d = this.defaultTransitionablePropertyValues[n] = new ga(s);
              this.defaultTransitioningPropertyValues[n] = d.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = l.possiblyEvaluate({});
            }
          }
        }
        Ae("DataDrivenProperty", Ge), Ae("DataConstantProperty", Fe), Ae("CrossFadedDataDrivenProperty", Cs), Ae("CrossFadedProperty", xa), Ae("ColorRampProperty", Vo);
        const ec = "-transition";
        class cr extends ie {
          constructor(t, n) {
            if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), n.layout && (this._unevaluatedLayout = new Hc(n.layout)), n.paint)) {
              this._transitionablePaint = new Oo(n.paint);
              for (const s in t.paint) this.setPaintProperty(s, t.paint[s], { validate: !1 });
              for (const s in t.layout) this.setLayoutProperty(s, t.layout[s], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ya(n.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          setLayoutProperty(t, n, s = {}) {
            n != null && this._validate(qc, `layers.${this.id}.layout.${t}`, t, n, s) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(ec) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, s = {}) {
            if (n != null && this._validate(zo, `layers.${this.id}.paint.${t}`, t, n, s)) return !1;
            if (t.endsWith(ec)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
            {
              const l = this._transitionablePaint._values[t], d = l.property.specification["property-type"] === "cross-faded-data-driven", p = l.value.isDataDriven(), m = l.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const g = this._transitionablePaint._values[t].value;
              return g.isDataDriven() || p || d || this._handleOverridablePaintPropertyUpdate(t, m, g);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, s) {
            return !1;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), en(t, (n, s) => !(n === void 0 || s === "layout" && !Object.keys(n).length || s === "paint" && !Object.keys(n).length));
          }
          _validate(t, n, s, l, d = {}) {
            return (!d || d.validate !== !1) && pa(this, t.call(Xn, { key: n, layerType: this.type, objectKey: s, value: l, styleSpec: P, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof Zi && Un(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const Xc = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class hr {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Et {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Lt(r, t = 1) {
          let n = 0, s = 0;
          return { members: r.map((l) => {
            const d = Xc[l.type].BYTES_PER_ELEMENT, p = n = tc(n, Math.max(t, d)), m = l.components || 1;
            return s = Math.max(s, d), n += d * m, { name: l.name, type: l.type, components: m, offset: p };
          }), size: tc(n, Math.max(s, t)), alignment: t };
        }
        function tc(r, t) {
          return Math.ceil(r / t) * t;
        }
        class Jn extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, n);
          }
          emplace(t, n, s) {
            const l = 2 * t;
            return this.int16[l + 0] = n, this.int16[l + 1] = s, t;
          }
        }
        Jn.prototype.bytesPerElement = 4, Ae("StructArrayLayout2i4", Jn);
        class va extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n, s);
          }
          emplace(t, n, s, l) {
            const d = 3 * t;
            return this.int16[d + 0] = n, this.int16[d + 1] = s, this.int16[d + 2] = l, t;
          }
        }
        va.prototype.bytesPerElement = 6, Ae("StructArrayLayout3i6", va);
        class No extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l) {
            const d = this.length;
            return this.resize(d + 1), this.emplace(d, t, n, s, l);
          }
          emplace(t, n, s, l, d) {
            const p = 4 * t;
            return this.int16[p + 0] = n, this.int16[p + 1] = s, this.int16[p + 2] = l, this.int16[p + 3] = d, t;
          }
        }
        No.prototype.bytesPerElement = 8, Ae("StructArrayLayout4i8", No);
        class vr extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, s, l, d, p);
          }
          emplace(t, n, s, l, d, p, m) {
            const g = 6 * t;
            return this.int16[g + 0] = n, this.int16[g + 1] = s, this.int16[g + 2] = l, this.int16[g + 3] = d, this.int16[g + 4] = p, this.int16[g + 5] = m, t;
          }
        }
        vr.prototype.bytesPerElement = 12, Ae("StructArrayLayout2i4i12", vr);
        class ba extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, s, l, d, p);
          }
          emplace(t, n, s, l, d, p, m) {
            const g = 4 * t, x = 8 * t;
            return this.int16[g + 0] = n, this.int16[g + 1] = s, this.uint8[x + 4] = l, this.uint8[x + 5] = d, this.uint8[x + 6] = p, this.uint8[x + 7] = m, t;
          }
        }
        ba.prototype.bytesPerElement = 8, Ae("StructArrayLayout2i4ub8", ba);
        class vn extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, n);
          }
          emplace(t, n, s) {
            const l = 2 * t;
            return this.float32[l + 0] = n, this.float32[l + 1] = s, t;
          }
        }
        vn.prototype.bytesPerElement = 8, Ae("StructArrayLayout2f8", vn);
        class wa extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p, m, g, x, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, s, l, d, p, m, g, x, b);
          }
          emplace(t, n, s, l, d, p, m, g, x, b, w) {
            const I = 10 * t;
            return this.uint16[I + 0] = n, this.uint16[I + 1] = s, this.uint16[I + 2] = l, this.uint16[I + 3] = d, this.uint16[I + 4] = p, this.uint16[I + 5] = m, this.uint16[I + 6] = g, this.uint16[I + 7] = x, this.uint16[I + 8] = b, this.uint16[I + 9] = w, t;
          }
        }
        wa.prototype.bytesPerElement = 20, Ae("StructArrayLayout10ui20", wa);
        class Es extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p, m, g, x, b, w, I) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, t, n, s, l, d, p, m, g, x, b, w, I);
          }
          emplace(t, n, s, l, d, p, m, g, x, b, w, I, E) {
            const A = 12 * t;
            return this.int16[A + 0] = n, this.int16[A + 1] = s, this.int16[A + 2] = l, this.int16[A + 3] = d, this.uint16[A + 4] = p, this.uint16[A + 5] = m, this.uint16[A + 6] = g, this.uint16[A + 7] = x, this.int16[A + 8] = b, this.int16[A + 9] = w, this.int16[A + 10] = I, this.int16[A + 11] = E, t;
          }
        }
        Es.prototype.bytesPerElement = 24, Ae("StructArrayLayout4i4ui4i24", Es);
        class Zo extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n, s);
          }
          emplace(t, n, s, l) {
            const d = 3 * t;
            return this.float32[d + 0] = n, this.float32[d + 1] = s, this.float32[d + 2] = l, t;
          }
        }
        Zo.prototype.bytesPerElement = 12, Ae("StructArrayLayout3f12", Zo);
        class Yn extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        Yn.prototype.bytesPerElement = 4, Ae("StructArrayLayout1ul4", Yn);
        class bn extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p, m, g, x) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, n, s, l, d, p, m, g, x);
          }
          emplace(t, n, s, l, d, p, m, g, x, b) {
            const w = 10 * t, I = 5 * t;
            return this.int16[w + 0] = n, this.int16[w + 1] = s, this.int16[w + 2] = l, this.int16[w + 3] = d, this.int16[w + 4] = p, this.int16[w + 5] = m, this.uint32[I + 3] = g, this.uint16[w + 8] = x, this.uint16[w + 9] = b, t;
          }
        }
        bn.prototype.bytesPerElement = 20, Ae("StructArrayLayout6i1ul2ui20", bn);
        class Uo extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, s, l, d, p);
          }
          emplace(t, n, s, l, d, p, m) {
            const g = 6 * t;
            return this.int16[g + 0] = n, this.int16[g + 1] = s, this.int16[g + 2] = l, this.int16[g + 3] = d, this.int16[g + 4] = p, this.int16[g + 5] = m, t;
          }
        }
        Uo.prototype.bytesPerElement = 12, Ae("StructArrayLayout2i2i2i12", Uo);
        class Ta extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, t, n, s, l, d);
          }
          emplace(t, n, s, l, d, p) {
            const m = 4 * t, g = 8 * t;
            return this.float32[m + 0] = n, this.float32[m + 1] = s, this.float32[m + 2] = l, this.int16[g + 6] = d, this.int16[g + 7] = p, t;
          }
        }
        Ta.prototype.bytesPerElement = 16, Ae("StructArrayLayout2f1f2i16", Ta);
        class wn extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, t, n, s, l, d, p);
          }
          emplace(t, n, s, l, d, p, m) {
            const g = 16 * t, x = 4 * t, b = 8 * t;
            return this.uint8[g + 0] = n, this.uint8[g + 1] = s, this.float32[x + 1] = l, this.float32[x + 2] = d, this.int16[b + 6] = p, this.int16[b + 7] = m, t;
          }
        }
        wn.prototype.bytesPerElement = 16, Ae("StructArrayLayout2ub2f2i16", wn);
        class Pa extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n, s);
          }
          emplace(t, n, s, l) {
            const d = 3 * t;
            return this.uint16[d + 0] = n, this.uint16[d + 1] = s, this.uint16[d + 2] = l, t;
          }
        }
        Pa.prototype.bytesPerElement = 6, Ae("StructArrayLayout3ui6", Pa);
        class Go extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z) {
            const Y = this.length;
            return this.resize(Y + 1), this.emplace(Y, t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z);
          }
          emplace(t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z, Y) {
            const $ = 24 * t, C = 12 * t, B = 48 * t;
            return this.int16[$ + 0] = n, this.int16[$ + 1] = s, this.uint16[$ + 2] = l, this.uint16[$ + 3] = d, this.uint32[C + 2] = p, this.uint32[C + 3] = m, this.uint32[C + 4] = g, this.uint16[$ + 10] = x, this.uint16[$ + 11] = b, this.uint16[$ + 12] = w, this.float32[C + 7] = I, this.float32[C + 8] = E, this.uint8[B + 36] = A, this.uint8[B + 37] = D, this.uint8[B + 38] = F, this.uint32[C + 10] = Z, this.int16[$ + 22] = Y, t;
          }
        }
        Go.prototype.bytesPerElement = 48, Ae("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Go);
        class Sa extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z, Y, $, C, B, q, ae, ve, ce, de, Te, we) {
            const Pe = this.length;
            return this.resize(Pe + 1), this.emplace(Pe, t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z, Y, $, C, B, q, ae, ve, ce, de, Te, we);
          }
          emplace(t, n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z, Y, $, C, B, q, ae, ve, ce, de, Te, we, Pe) {
            const ge = 32 * t, ze = 16 * t;
            return this.int16[ge + 0] = n, this.int16[ge + 1] = s, this.int16[ge + 2] = l, this.int16[ge + 3] = d, this.int16[ge + 4] = p, this.int16[ge + 5] = m, this.int16[ge + 6] = g, this.int16[ge + 7] = x, this.uint16[ge + 8] = b, this.uint16[ge + 9] = w, this.uint16[ge + 10] = I, this.uint16[ge + 11] = E, this.uint16[ge + 12] = A, this.uint16[ge + 13] = D, this.uint16[ge + 14] = F, this.uint16[ge + 15] = Z, this.uint16[ge + 16] = Y, this.uint16[ge + 17] = $, this.uint16[ge + 18] = C, this.uint16[ge + 19] = B, this.uint16[ge + 20] = q, this.uint16[ge + 21] = ae, this.uint16[ge + 22] = ve, this.uint32[ze + 12] = ce, this.float32[ze + 13] = de, this.float32[ze + 14] = Te, this.uint16[ge + 30] = we, this.uint16[ge + 31] = Pe, t;
          }
        }
        Sa.prototype.bytesPerElement = 64, Ae("StructArrayLayout8i15ui1ul2f2ui64", Sa);
        class Ma extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        Ma.prototype.bytesPerElement = 4, Ae("StructArrayLayout1f4", Ma);
        class h extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n, s);
          }
          emplace(t, n, s, l) {
            const d = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[d + 1] = s, this.float32[d + 2] = l, t;
          }
        }
        h.prototype.bytesPerElement = 12, Ae("StructArrayLayout1ui2f12", h);
        class e extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s) {
            const l = this.length;
            return this.resize(l + 1), this.emplace(l, t, n, s);
          }
          emplace(t, n, s, l) {
            const d = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[d + 2] = s, this.uint16[d + 3] = l, t;
          }
        }
        e.prototype.bytesPerElement = 8, Ae("StructArrayLayout1ul2ui8", e);
        class i extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, t, n);
          }
          emplace(t, n, s) {
            const l = 2 * t;
            return this.uint16[l + 0] = n, this.uint16[l + 1] = s, t;
          }
        }
        i.prototype.bytesPerElement = 4, Ae("StructArrayLayout2ui4", i);
        class a extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        a.prototype.bytesPerElement = 2, Ae("StructArrayLayout1ui2", a);
        class o extends Et {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, s, l) {
            const d = this.length;
            return this.resize(d + 1), this.emplace(d, t, n, s, l);
          }
          emplace(t, n, s, l, d) {
            const p = 4 * t;
            return this.float32[p + 0] = n, this.float32[p + 1] = s, this.float32[p + 2] = l, this.float32[p + 3] = d, t;
          }
        }
        o.prototype.bytesPerElement = 16, Ae("StructArrayLayout4f16", o);
        class u extends hr {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new Ue(this.anchorPointX, this.anchorPointY);
          }
        }
        u.prototype.size = 20;
        class f extends bn {
          get(t) {
            return new u(this, t);
          }
        }
        Ae("CollisionBoxArray", f);
        class _ extends hr {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        _.prototype.size = 48;
        class y extends Go {
          get(t) {
            return new _(this, t);
          }
        }
        Ae("PlacedSymbolArray", y);
        class v extends hr {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        v.prototype.size = 64;
        class T extends Sa {
          get(t) {
            return new v(this, t);
          }
        }
        Ae("SymbolInstanceArray", T);
        class S extends Ma {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Ae("GlyphOffsetArray", S);
        class M extends va {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Ae("SymbolLineVertexArray", M);
        class k extends hr {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        k.prototype.size = 12;
        class R extends h {
          get(t) {
            return new k(this, t);
          }
        }
        Ae("TextAnchorOffsetArray", R);
        class V extends hr {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        V.prototype.size = 8;
        class j extends e {
          get(t) {
            return new V(this, t);
          }
        }
        Ae("FeatureIndexArray", j);
        class N extends Jn {
        }
        class G extends Jn {
        }
        class W extends Jn {
        }
        class H extends vr {
        }
        class K extends ba {
        }
        class Q extends vn {
        }
        class J extends wa {
        }
        class se extends Es {
        }
        class oe extends Zo {
        }
        class fe extends Yn {
        }
        class _e extends Uo {
        }
        class pe extends wn {
        }
        class Ie extends Pa {
        }
        class Se extends i {
        }
        const be = Lt([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Re } = be;
        class Oe {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = !1, this.segments = t;
          }
          prepareSegment(t, n, s, l) {
            const d = this.segments[this.segments.length - 1];
            return t > Oe.MAX_VERTEX_ARRAY_LENGTH && ci(`Max vertices per segment is ${Oe.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Oe.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !d || d.vertexLength + t > Oe.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== l ? this.createNewSegment(n, s, l) : d;
          }
          createNewSegment(t, n, s) {
            const l = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return s !== void 0 && (l.sortKey = s), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(l), l;
          }
          getOrCreateLatestSegment(t, n, s) {
            return this.prepareSegment(0, t, n, s);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, s, l) {
            return new Oe([{ vertexOffset: t, primitiveOffset: n, vertexLength: s, primitiveLength: l, vaos: {}, sortKey: 0 }]);
          }
        }
        function lt(r, t) {
          return 256 * (r = qi(Math.floor(r), 0, 255)) + qi(Math.floor(t), 0, 255);
        }
        Oe.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ae("SegmentVector", Oe);
        const _t = Lt([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var ut, Pt, xt, ct = { exports: {} }, dt = { exports: {} }, Kt = { exports: {} }, Jt = function() {
          if (xt) return ct.exports;
          xt = 1;
          var r = (ut || (ut = 1, dt.exports = function(n, s) {
            var l, d, p, m, g, x, b, w;
            for (d = n.length - (l = 3 & n.length), p = s, g = 3432918353, x = 461845907, w = 0; w < d; ) b = 255 & n.charCodeAt(w) | (255 & n.charCodeAt(++w)) << 8 | (255 & n.charCodeAt(++w)) << 16 | (255 & n.charCodeAt(++w)) << 24, ++w, p = 27492 + (65535 & (m = 5 * (65535 & (p = (p ^= b = (65535 & (b = (b = (65535 & b) * g + (((b >>> 16) * g & 65535) << 16) & 4294967295) << 15 | b >>> 17)) * x + (((b >>> 16) * x & 65535) << 16) & 4294967295) << 13 | p >>> 19)) + ((5 * (p >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (m >>> 16) & 65535) << 16);
            switch (b = 0, l) {
              case 3:
                b ^= (255 & n.charCodeAt(w + 2)) << 16;
              case 2:
                b ^= (255 & n.charCodeAt(w + 1)) << 8;
              case 1:
                p ^= b = (65535 & (b = (b = (65535 & (b ^= 255 & n.charCodeAt(w))) * g + (((b >>> 16) * g & 65535) << 16) & 4294967295) << 15 | b >>> 17)) * x + (((b >>> 16) * x & 65535) << 16) & 4294967295;
            }
            return p ^= n.length, p = 2246822507 * (65535 & (p ^= p >>> 16)) + ((2246822507 * (p >>> 16) & 65535) << 16) & 4294967295, p = 3266489909 * (65535 & (p ^= p >>> 13)) + ((3266489909 * (p >>> 16) & 65535) << 16) & 4294967295, (p ^= p >>> 16) >>> 0;
          }), dt.exports), t = (Pt || (Pt = 1, Kt.exports = function(n, s) {
            for (var l, d = n.length, p = s ^ d, m = 0; d >= 4; ) l = 1540483477 * (65535 & (l = 255 & n.charCodeAt(m) | (255 & n.charCodeAt(++m)) << 8 | (255 & n.charCodeAt(++m)) << 16 | (255 & n.charCodeAt(++m)) << 24)) + ((1540483477 * (l >>> 16) & 65535) << 16), p = 1540483477 * (65535 & p) + ((1540483477 * (p >>> 16) & 65535) << 16) ^ (l = 1540483477 * (65535 & (l ^= l >>> 24)) + ((1540483477 * (l >>> 16) & 65535) << 16)), d -= 4, ++m;
            switch (d) {
              case 3:
                p ^= (255 & n.charCodeAt(m + 2)) << 16;
              case 2:
                p ^= (255 & n.charCodeAt(m + 1)) << 8;
              case 1:
                p = 1540483477 * (65535 & (p ^= 255 & n.charCodeAt(m))) + ((1540483477 * (p >>> 16) & 65535) << 16);
            }
            return p = 1540483477 * (65535 & (p ^= p >>> 13)) + ((1540483477 * (p >>> 16) & 65535) << 16), (p ^= p >>> 15) >>> 0;
          }), Kt.exports);
          return ct.exports = r, ct.exports.murmur3 = r, ct.exports.murmur2 = t, ct.exports;
        }(), Zt = fi(Jt);
        class ni {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(t, n, s, l) {
            this.ids.push(Ur(t)), this.positions.push(n, s, l);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = Ur(t);
            let s = 0, l = this.ids.length - 1;
            for (; s < l; ) {
              const p = s + l >> 1;
              this.ids[p] >= n ? l = p : s = p + 1;
            }
            const d = [];
            for (; this.ids[s] === n; ) d.push({ index: this.positions[3 * s], start: this.positions[3 * s + 1], end: this.positions[3 * s + 2] }), s++;
            return d;
          }
          static serialize(t, n) {
            const s = new Float64Array(t.ids), l = new Uint32Array(t.positions);
            return br(s, l, 0, s.length - 1), n && n.push(s.buffer, l.buffer), { ids: s, positions: l };
          }
          static deserialize(t) {
            const n = new ni();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n;
          }
        }
        function Ur(r) {
          const t = +r;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Zt(String(r));
        }
        function br(r, t, n, s) {
          for (; n < s; ) {
            const l = r[n + s >> 1];
            let d = n - 1, p = s + 1;
            for (; ; ) {
              do
                d++;
              while (r[d] < l);
              do
                p--;
              while (r[p] > l);
              if (d >= p) break;
              ur(r, d, p), ur(t, 3 * d, 3 * p), ur(t, 3 * d + 1, 3 * p + 1), ur(t, 3 * d + 2, 3 * p + 2);
            }
            p - n < s - p ? (br(r, t, n, p), n = p + 1) : (br(r, t, p + 1, s), s = p);
          }
        }
        function ur(r, t, n) {
          const s = r[t];
          r[t] = r[n], r[n] = s;
        }
        Ae("FeaturePositionMap", ni);
        class Ui {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class Tn extends Ui {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class As extends Ui {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class Pn extends Ui {
          constructor(t, n) {
            super(t, n), this.current = st.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Gi = new Float32Array(16);
        function dr(r) {
          return [lt(255 * r.r, 255 * r.g), lt(255 * r.b, 255 * r.a)];
        }
        class Yi {
          constructor(t, n, s) {
            this.value = t, this.uniformNames = n.map((l) => `u_${l}`), this.type = s;
          }
          setUniform(t, n, s) {
            t.set(s.constantOr(this.value));
          }
          getBinding(t, n, s) {
            return this.type === "color" ? new Pn(t, n) : new Tn(t, n);
          }
        }
        class pr {
          constructor(t, n) {
            this.uniformNames = n.map((s) => `u_${s}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, n, s, l) {
            const d = l === "u_pattern_to" ? this.patternTo : l === "u_pattern_from" ? this.patternFrom : l === "u_pixel_ratio_to" ? this.pixelRatioTo : l === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            d && t.set(d);
          }
          getBinding(t, n, s) {
            return s.substr(0, 9) === "u_pattern" ? new As(t, n) : new Tn(t, n);
          }
        }
        class gt {
          constructor(t, n, s, l) {
            this.expression = t, this.type = s, this.maxValue = 0, this.paintVertexAttributes = n.map((d) => ({ name: `a_${d}`, type: "Float32", components: s === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new l();
          }
          populatePaintArray(t, n, s, l, d) {
            const p = this.paintVertexArray.length, m = this.expression.evaluate(new Tt(0), n, {}, l, [], d);
            this.paintVertexArray.resize(t), this._setPaintValue(p, t, m);
          }
          updatePaintArray(t, n, s, l) {
            const d = this.expression.evaluate({ zoom: 0 }, s, l);
            this._setPaintValue(t, n, d);
          }
          _setPaintValue(t, n, s) {
            if (this.type === "color") {
              const l = dr(s);
              for (let d = t; d < n; d++) this.paintVertexArray.emplace(d, l[0], l[1]);
            } else {
              for (let l = t; l < n; l++) this.paintVertexArray.emplace(l, s);
              this.maxValue = Math.max(this.maxValue, Math.abs(s));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ft {
          constructor(t, n, s, l, d, p) {
            this.expression = t, this.uniformNames = n.map((m) => `u_${m}_t`), this.type = s, this.useIntegerZoom = l, this.zoom = d, this.maxValue = 0, this.paintVertexAttributes = n.map((m) => ({ name: `a_${m}`, type: "Float32", components: s === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new p();
          }
          populatePaintArray(t, n, s, l, d) {
            const p = this.expression.evaluate(new Tt(this.zoom), n, {}, l, [], d), m = this.expression.evaluate(new Tt(this.zoom + 1), n, {}, l, [], d), g = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(g, t, p, m);
          }
          updatePaintArray(t, n, s, l) {
            const d = this.expression.evaluate({ zoom: this.zoom }, s, l), p = this.expression.evaluate({ zoom: this.zoom + 1 }, s, l);
            this._setPaintValue(t, n, d, p);
          }
          _setPaintValue(t, n, s, l) {
            if (this.type === "color") {
              const d = dr(s), p = dr(l);
              for (let m = t; m < n; m++) this.paintVertexArray.emplace(m, d[0], d[1], p[0], p[1]);
            } else {
              for (let d = t; d < n; d++) this.paintVertexArray.emplace(d, s, l);
              this.maxValue = Math.max(this.maxValue, Math.abs(s), Math.abs(l));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const s = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, l = qi(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
            t.set(l);
          }
          getBinding(t, n, s) {
            return new Tn(t, n);
          }
        }
        class Ut {
          constructor(t, n, s, l, d, p) {
            this.expression = t, this.type = n, this.useIntegerZoom = s, this.zoom = l, this.layerId = p, this.zoomInPaintVertexArray = new d(), this.zoomOutPaintVertexArray = new d();
          }
          populatePaintArray(t, n, s) {
            const l = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(l, t, n.patterns && n.patterns[this.layerId], s);
          }
          updatePaintArray(t, n, s, l, d) {
            this._setPaintValues(t, n, s.patterns && s.patterns[this.layerId], d);
          }
          _setPaintValues(t, n, s, l) {
            if (!l || !s) return;
            const { min: d, mid: p, max: m } = s, g = l[d], x = l[p], b = l[m];
            if (g && x && b) for (let w = t; w < n; w++) this.zoomInPaintVertexArray.emplace(w, x.tl[0], x.tl[1], x.br[0], x.br[1], g.tl[0], g.tl[1], g.br[0], g.br[1], x.pixelRatio, g.pixelRatio), this.zoomOutPaintVertexArray.emplace(w, x.tl[0], x.tl[1], x.br[0], x.br[1], b.tl[0], b.tl[1], b.br[0], b.br[1], x.pixelRatio, b.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, _t.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, _t.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Gt {
          constructor(t, n, s) {
            this.binders = {}, this._buffers = [];
            const l = [];
            for (const d in t.paint._values) {
              if (!s(d)) continue;
              const p = t.paint.get(d);
              if (!(p instanceof Zi && Un(p.property.specification))) continue;
              const m = Kc(d, t.type), g = p.value, x = p.property.specification.type, b = p.property.useIntegerZoom, w = p.property.specification["property-type"], I = w === "cross-faded" || w === "cross-faded-data-driven";
              if (g.kind === "constant") this.binders[d] = I ? new pr(g.value, m) : new Yi(g.value, m, x), l.push(`/u_${d}`);
              else if (g.kind === "source" || I) {
                const E = ic(d, x, "source");
                this.binders[d] = I ? new Ut(g, x, b, n, E, t.id) : new gt(g, m, x, E), l.push(`/a_${d}`);
              } else {
                const E = ic(d, x, "composite");
                this.binders[d] = new ft(g, m, x, b, n, E), l.push(`/z_${d}`);
              }
            }
            this.cacheKey = l.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof gt || n instanceof ft ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, s, l, d) {
            for (const p in this.binders) {
              const m = this.binders[p];
              (m instanceof gt || m instanceof ft || m instanceof Ut) && m.populatePaintArray(t, n, s, l, d);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const s in this.binders) {
              const l = this.binders[s];
              l instanceof pr && l.setConstantPatternPositions(t, n);
            }
          }
          updatePaintArrays(t, n, s, l, d) {
            let p = !1;
            for (const m in t) {
              const g = n.getPositions(m);
              for (const x of g) {
                const b = s.feature(x.index);
                for (const w in this.binders) {
                  const I = this.binders[w];
                  if ((I instanceof gt || I instanceof ft || I instanceof Ut) && I.expression.isStateDependent === !0) {
                    const E = l.paint.get(w);
                    I.expression = E.value, I.updatePaintArray(x.start, x.end, b, t[m], d), p = !0;
                  }
                }
              }
            }
            return p;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const s = this.binders[n];
              (s instanceof Yi || s instanceof pr) && t.push(...s.uniformNames.map((l) => `#define HAS_UNIFORM_${l}`));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const s = this.binders[n];
              if (s instanceof gt || s instanceof ft) for (let l = 0; l < s.paintVertexAttributes.length; l++) t.push(s.paintVertexAttributes[l].name);
              else if (s instanceof Ut) for (let l = 0; l < _t.members.length; l++) t.push(_t.members[l].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const s = this.binders[n];
              if (s instanceof Yi || s instanceof pr || s instanceof ft) for (const l of s.uniformNames) t.push(l);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const s = [];
            for (const l in this.binders) {
              const d = this.binders[l];
              if (d instanceof Yi || d instanceof pr || d instanceof ft) {
                for (const p of d.uniformNames) if (n[p]) {
                  const m = d.getBinding(t, n[p], p);
                  s.push({ name: p, property: l, binding: m });
                }
              }
            }
            return s;
          }
          setUniforms(t, n, s, l) {
            for (const { name: d, property: p, binding: m } of n) this.binders[p].setUniform(m, l, s.get(p), d);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const s = this.binders[n];
              if (t && s instanceof Ut) {
                const l = t.fromScale === 2 ? s.zoomInPaintVertexBuffer : s.zoomOutPaintVertexBuffer;
                l && this._buffers.push(l);
              } else (s instanceof gt || s instanceof ft) && s.paintVertexBuffer && this._buffers.push(s.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const s = this.binders[n];
              (s instanceof gt || s instanceof ft || s instanceof Ut) && s.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof gt || n instanceof ft || n instanceof Ut) && n.destroy();
            }
          }
        }
        class Sn {
          constructor(t, n, s = () => !0) {
            this.programConfigurations = {};
            for (const l of t) this.programConfigurations[l.id] = new Gt(l, n, s);
            this.needsUpload = !1, this._featureMap = new ni(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, s, l, d, p) {
            for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(t, n, l, d, p);
            n.id !== void 0 && this._featureMap.add(n.id, s, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
          }
          updatePaintArrays(t, n, s, l) {
            for (const d of s) this.needsUpload = this.programConfigurations[d.id].updatePaintArrays(t, this._featureMap, n, d, l) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Kc(r, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function ic(r, t, n) {
          const s = { color: { source: vn, composite: o }, number: { source: Ma, composite: vn } }, l = function(d) {
            return { "line-pattern": { source: J, composite: J }, "fill-pattern": { source: J, composite: J }, "fill-extrusion-pattern": { source: J, composite: J } }[d];
          }(r);
          return l && l[n] || s[t][n];
        }
        Ae("ConstantBinder", Yi), Ae("CrossFadedConstantBinder", pr), Ae("SourceExpressionBinder", gt), Ae("CrossFadedCompositeBinder", Ut), Ae("CompositeExpressionBinder", ft), Ae("ProgramConfiguration", Gt, { omit: ["_buffers"] }), Ae("ProgramConfigurationSet", Sn);
        const $o = Math.pow(2, 14) - 1, rc = -$o - 1;
        function Mn(r) {
          const t = ht / r.extent, n = r.loadGeometry();
          for (let s = 0; s < n.length; s++) {
            const l = n[s];
            for (let d = 0; d < l.length; d++) {
              const p = l[d], m = Math.round(p.x * t), g = Math.round(p.y * t);
              p.x = qi(m, rc, $o), p.y = qi(g, rc, $o), (m < p.x || m > p.x + 1 || g < p.y || g > p.y + 1) && ci("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function Ci(r, t) {
          return { type: r.type, id: r.id, properties: r.properties, geometry: t ? Mn(r) : [] };
        }
        const qo = -32768;
        function nc(r, t, n, s, l) {
          r.emplaceBack(qo + 8 * t + s, qo + 8 * n + l);
        }
        class Ia {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new G(), this.indexArray = new Ie(), this.segments = new Oe(), this.programConfigurations = new Sn(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
          }
          populate(t, n, s) {
            const l = this.layers[0], d = [];
            let p = null, m = !1, g = l.type === "heatmap";
            if (l.type === "circle") {
              const b = l;
              p = b.layout.get("circle-sort-key"), m = !p.isConstant(), g = g || b.paint.get("circle-pitch-alignment") === "map";
            }
            const x = g ? n.subdivisionGranularity.circle : 1;
            for (const { feature: b, id: w, index: I, sourceLayerIndex: E } of t) {
              const A = this.layers[0]._featureFilter.needGeometry, D = Ci(b, A);
              if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), D, s)) continue;
              const F = m ? p.evaluate(D, {}, s) : void 0, Z = { id: w, properties: b.properties, type: b.type, sourceLayerIndex: E, index: I, geometry: A ? D.geometry : Mn(b), patterns: {}, sortKey: F };
              d.push(Z);
            }
            m && d.sort((b, w) => b.sortKey - w.sortKey);
            for (const b of d) {
              const { geometry: w, index: I, sourceLayerIndex: E } = b, A = t[I].feature;
              this.addFeature(b, w, I, s, x), n.featureIndex.insert(A, w, I, E, this.index);
            }
          }
          update(t, n, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Re), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, s, l, d = 1) {
            let p;
            switch (d) {
              case 1:
                p = [0, 7];
                break;
              case 3:
                p = [0, 2, 5, 7];
                break;
              case 5:
                p = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                p = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${d}; valid values are 1, 3, 5, 7.`);
            }
            const m = p.length;
            for (const g of n) for (const x of g) {
              const b = x.x, w = x.y;
              if (b < 0 || b >= ht || w < 0 || w >= ht) continue;
              const I = this.segments.prepareSegment(m * m, this.layoutVertexArray, this.indexArray, t.sortKey), E = I.vertexLength;
              for (let A = 0; A < m; A++) for (let D = 0; D < m; D++) nc(this.layoutVertexArray, b, w, p[D], p[A]);
              for (let A = 0; A < m - 1; A++) for (let D = 0; D < m - 1; D++) {
                const F = E + A * m + D, Z = E + (A + 1) * m + D;
                this.indexArray.emplaceBack(F, Z + 1, F + 1), this.indexArray.emplaceBack(F, Z, Z + 1);
              }
              I.vertexLength += m * m, I.primitiveLength += (m - 1) * (m - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, {}, l);
          }
        }
        function Ca(r, t) {
          for (let n = 0; n < r.length; n++) if (Aa(t, r[n])) return !0;
          for (let n = 0; n < t.length; n++) if (Aa(r, t[n])) return !0;
          return !!Jc(r, t);
        }
        function sc(r, t, n) {
          return !!Aa(r, t) || !!Yc(t, r, n);
        }
        function Ea(r, t) {
          if (r.length === 1) return Vh(t, r[0]);
          for (let n = 0; n < t.length; n++) {
            const s = t[n];
            for (let l = 0; l < s.length; l++) if (Aa(r, s[l])) return !0;
          }
          for (let n = 0; n < r.length; n++) if (Vh(t, r[n])) return !0;
          for (let n = 0; n < t.length; n++) if (Jc(r, t[n])) return !0;
          return !1;
        }
        function Pd(r, t, n) {
          if (r.length > 1) {
            if (Jc(r, t)) return !0;
            for (let s = 0; s < t.length; s++) if (Yc(t[s], r, n)) return !0;
          }
          for (let s = 0; s < r.length; s++) if (Yc(r[s], t, n)) return !0;
          return !1;
        }
        function Jc(r, t) {
          if (r.length === 0 || t.length === 0) return !1;
          for (let n = 0; n < r.length - 1; n++) {
            const s = r[n], l = r[n + 1];
            for (let d = 0; d < t.length - 1; d++) if (Sd(s, l, t[d], t[d + 1])) return !0;
          }
          return !1;
        }
        function Sd(r, t, n, s) {
          return Vt(r, n, s) !== Vt(t, n, s) && Vt(r, t, n) !== Vt(r, t, s);
        }
        function Yc(r, t, n) {
          const s = n * n;
          if (t.length === 1) return r.distSqr(t[0]) < s;
          for (let l = 1; l < t.length; l++) if (jh(r, t[l - 1], t[l]) < s) return !0;
          return !1;
        }
        function jh(r, t, n) {
          const s = t.distSqr(n);
          if (s === 0) return r.distSqr(t);
          const l = ((r.x - t.x) * (n.x - t.x) + (r.y - t.y) * (n.y - t.y)) / s;
          return r.distSqr(l < 0 ? t : l > 1 ? n : n.sub(t)._mult(l)._add(t));
        }
        function Vh(r, t) {
          let n, s, l, d = !1;
          for (let p = 0; p < r.length; p++) {
            n = r[p];
            for (let m = 0, g = n.length - 1; m < n.length; g = m++) s = n[m], l = n[g], s.y > t.y != l.y > t.y && t.x < (l.x - s.x) * (t.y - s.y) / (l.y - s.y) + s.x && (d = !d);
          }
          return d;
        }
        function Aa(r, t) {
          let n = !1;
          for (let s = 0, l = r.length - 1; s < r.length; l = s++) {
            const d = r[s], p = r[l];
            d.y > t.y != p.y > t.y && t.x < (p.x - d.x) * (t.y - d.y) / (p.y - d.y) + d.x && (n = !n);
          }
          return n;
        }
        function Md(r, t, n) {
          const s = n[0], l = n[2];
          if (r.x < s.x && t.x < s.x || r.x > l.x && t.x > l.x || r.y < s.y && t.y < s.y || r.y > l.y && t.y > l.y) return !1;
          const d = Vt(r, t, n[0]);
          return d !== Vt(r, t, n[1]) || d !== Vt(r, t, n[2]) || d !== Vt(r, t, n[3]);
        }
        function Wo(r, t, n) {
          const s = t.paint.get(r).value;
          return s.kind === "constant" ? s.value : n.programConfigurations.get(t.id).getMaxValue(r);
        }
        function ac(r) {
          return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
        }
        function oc(r, t, n, s, l) {
          if (!t[0] && !t[1]) return r;
          const d = Ue.convert(t)._mult(l);
          n === "viewport" && d._rotate(-s);
          const p = [];
          for (let m = 0; m < r.length; m++) p.push(r[m].sub(d));
          return p;
        }
        let Nh, Zh;
        Ae("CircleBucket", Ia, { omit: ["layers"] });
        var Id = { get paint() {
          return Zh = Zh || new wi({ "circle-radius": new Ge(P.paint_circle["circle-radius"]), "circle-color": new Ge(P.paint_circle["circle-color"]), "circle-blur": new Ge(P.paint_circle["circle-blur"]), "circle-opacity": new Ge(P.paint_circle["circle-opacity"]), "circle-translate": new Fe(P.paint_circle["circle-translate"]), "circle-translate-anchor": new Fe(P.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Fe(P.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Fe(P.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ge(P.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ge(P.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ge(P.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Nh = Nh || new wi({ "circle-sort-key": new Ge(P.layout_circle["circle-sort-key"]) });
        } };
        class Cd extends cr {
          constructor(t) {
            super(t, Id);
          }
          createBucket(t) {
            return new Ia(t);
          }
          queryRadius(t) {
            const n = t;
            return Wo("circle-radius", this, n) + Wo("circle-stroke-width", this, n) + ac(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p, pixelPosMatrix: m }) {
            const g = oc(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -d.bearingInRadians, p), x = this.paint.get("circle-radius").evaluate(n, s) + this.paint.get("circle-stroke-width").evaluate(n, s), b = this.paint.get("circle-pitch-alignment") === "map", w = b ? g : function(E, A) {
              return E.map((D) => Uh(D, A));
            }(g, m), I = b ? x * p : x;
            for (const E of l) for (const A of E) {
              const D = b ? A : Uh(A, m);
              let F = I;
              const Z = fr([], [A.x, A.y, 0, 1], m);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? F *= Z[3] / d.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (F *= d.cameraToCenterDistance / Z[3]), sc(w, D, F)) return !0;
            }
            return !1;
          }
        }
        function Uh(r, t) {
          const n = fr([], [r.x, r.y, 0, 1], t);
          return new Ue(n[0] / n[3], n[1] / n[3]);
        }
        class Gh extends Ia {
        }
        let $h;
        Ae("HeatmapBucket", Gh, { omit: ["layers"] });
        var Ed = { get paint() {
          return $h = $h || new wi({ "heatmap-radius": new Ge(P.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ge(P.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Fe(P.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Vo(P.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Fe(P.paint_heatmap["heatmap-opacity"]) });
        } };
        function Qc(r, { width: t, height: n }, s, l) {
          if (l) {
            if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer);
            else if (l.length !== t * n * s) throw new RangeError(`mismatched image size. expected: ${l.length} but got: ${t * n * s}`);
          } else l = new Uint8Array(t * n * s);
          return r.width = t, r.height = n, r.data = l, r;
        }
        function qh(r, { width: t, height: n }, s) {
          if (t === r.width && n === r.height) return;
          const l = Qc({}, { width: t, height: n }, s);
          eh(r, l, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, t), height: Math.min(r.height, n) }, s), r.width = t, r.height = n, r.data = l.data;
        }
        function eh(r, t, n, s, l, d) {
          if (l.width === 0 || l.height === 0) return t;
          if (l.width > r.width || l.height > r.height || n.x > r.width - l.width || n.y > r.height - l.height) throw new RangeError("out of range source coordinates for image copy");
          if (l.width > t.width || l.height > t.height || s.x > t.width - l.width || s.y > t.height - l.height) throw new RangeError("out of range destination coordinates for image copy");
          const p = r.data, m = t.data;
          if (p === m) throw new Error("srcData equals dstData, so image is already copied");
          for (let g = 0; g < l.height; g++) {
            const x = ((n.y + g) * r.width + n.x) * d, b = ((s.y + g) * t.width + s.x) * d;
            for (let w = 0; w < l.width * d; w++) m[b + w] = p[x + w];
          }
          return t;
        }
        class Ho {
          constructor(t, n) {
            Qc(this, t, 1, n);
          }
          resize(t) {
            qh(this, t, 1);
          }
          clone() {
            return new Ho({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, s, l, d) {
            eh(t, n, s, l, d, 1);
          }
        }
        class Qi {
          constructor(t, n) {
            Qc(this, t, 4, n);
          }
          resize(t) {
            qh(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Qi({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, s, l, d) {
            eh(t, n, s, l, d, 4);
          }
        }
        function Wh(r) {
          const t = {}, n = r.resolution || 256, s = r.clips ? r.clips.length : 1, l = r.image || new Qi({ width: n, height: s });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const d = (p, m, g) => {
            t[r.evaluationKey] = g;
            const x = r.expression.evaluate(t);
            l.data[p + m + 0] = Math.floor(255 * x.r / x.a), l.data[p + m + 1] = Math.floor(255 * x.g / x.a), l.data[p + m + 2] = Math.floor(255 * x.b / x.a), l.data[p + m + 3] = Math.floor(255 * x.a);
          };
          if (r.clips) for (let p = 0, m = 0; p < s; ++p, m += 4 * n) for (let g = 0, x = 0; g < n; g++, x += 4) {
            const b = g / (n - 1), { start: w, end: I } = r.clips[p];
            d(m, x, w * (1 - b) + I * b);
          }
          else for (let p = 0, m = 0; p < n; p++, m += 4) d(0, m, p / (n - 1));
          return l;
        }
        Ae("AlphaImage", Ho), Ae("RGBAImage", Qi);
        const th = "big-fb";
        class Ad extends cr {
          createBucket(t) {
            return new Gh(t);
          }
          constructor(t) {
            super(t, Ed), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Wh({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(th) && this.heatmapFbos.delete(th);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let Hh;
        var zd = { get paint() {
          return Hh = Hh || new wi({ "hillshade-illumination-direction": new Fe(P.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Fe(P.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Fe(P.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Fe(P.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Fe(P.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Fe(P.paint_hillshade["hillshade-accent-color"]) });
        } };
        class kd extends cr {
          constructor(t) {
            super(t, zd);
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        const Dd = Lt([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Rd } = Dd;
        function ih(r, t, n) {
          const s = n.patternDependencies;
          let l = !1;
          for (const d of t) {
            const p = d.paint.get(`${r}-pattern`);
            p.isConstant() || (l = !0);
            const m = p.constantOr(null);
            m && (l = !0, s[m.to] = !0, s[m.from] = !0);
          }
          return l;
        }
        function rh(r, t, n, s, l) {
          const d = l.patternDependencies;
          for (const p of t) {
            const m = p.paint.get(`${r}-pattern`).value;
            if (m.kind !== "constant") {
              let g = m.evaluate({ zoom: s - 1 }, n, {}, l.availableImages), x = m.evaluate({ zoom: s }, n, {}, l.availableImages), b = m.evaluate({ zoom: s + 1 }, n, {}, l.availableImages);
              g = g && g.name ? g.name : g, x = x && x.name ? x.name : x, b = b && b.name ? b.name : b, d[g] = !0, d[x] = !0, d[b] = !0, n.patterns[p.id] = { min: g, mid: x, max: b };
            }
          }
          return n;
        }
        function Xh(r, t, n, s, l) {
          let d;
          if (l === function(p, m, g, x) {
            let b = 0;
            for (let w = m, I = g - x; w < g; w += x) b += (p[I] - p[w]) * (p[w + 1] + p[I + 1]), I = w;
            return b;
          }(r, t, n, s) > 0) for (let p = t; p < n; p += s) d = Qh(p / s | 0, r[p], r[p + 1], d);
          else for (let p = n - s; p >= t; p -= s) d = Qh(p / s | 0, r[p], r[p + 1], d);
          return d && za(d, d.next) && (Yo(d), d = d.next), d;
        }
        function zs(r, t) {
          if (!r) return r;
          t || (t = r);
          let n, s = r;
          do
            if (n = !1, s.steiner || !za(s, s.next) && Bt(s.prev, s, s.next) !== 0) s = s.next;
            else {
              if (Yo(s), s = t = s.prev, s === s.next) break;
              n = !0;
            }
          while (n || s !== t);
          return t;
        }
        function Xo(r, t, n, s, l, d, p) {
          if (!r) return;
          !p && d && function(g, x, b, w) {
            let I = g;
            do
              I.z === 0 && (I.z = nh(I.x, I.y, x, b, w)), I.prevZ = I.prev, I.nextZ = I.next, I = I.next;
            while (I !== g);
            I.prevZ.nextZ = null, I.prevZ = null, function(E) {
              let A, D = 1;
              do {
                let F, Z = E;
                E = null;
                let Y = null;
                for (A = 0; Z; ) {
                  A++;
                  let $ = Z, C = 0;
                  for (let q = 0; q < D && (C++, $ = $.nextZ, $); q++) ;
                  let B = D;
                  for (; C > 0 || B > 0 && $; ) C !== 0 && (B === 0 || !$ || Z.z <= $.z) ? (F = Z, Z = Z.nextZ, C--) : (F = $, $ = $.nextZ, B--), Y ? Y.nextZ = F : E = F, F.prevZ = Y, Y = F;
                  Z = $;
                }
                Y.nextZ = null, D *= 2;
              } while (A > 1);
            }(I);
          }(r, s, l, d);
          let m = r;
          for (; r.prev !== r.next; ) {
            const g = r.prev, x = r.next;
            if (d ? Bd(r, s, l, d) : Ld(r)) t.push(g.i, r.i, x.i), Yo(r), r = x.next, m = x.next;
            else if ((r = x) === m) {
              p ? p === 1 ? Xo(r = Fd(zs(r), t), t, n, s, l, d, 2) : p === 2 && Od(r, t, n, s, l, d) : Xo(zs(r), t, n, s, l, d, 1);
              break;
            }
          }
        }
        function Ld(r) {
          const t = r.prev, n = r, s = r.next;
          if (Bt(t, n, s) >= 0) return !1;
          const l = t.x, d = n.x, p = s.x, m = t.y, g = n.y, x = s.y, b = Math.min(l, d, p), w = Math.min(m, g, x), I = Math.max(l, d, p), E = Math.max(m, g, x);
          let A = s.next;
          for (; A !== t; ) {
            if (A.x >= b && A.x <= I && A.y >= w && A.y <= E && Ko(l, m, d, g, p, x, A.x, A.y) && Bt(A.prev, A, A.next) >= 0) return !1;
            A = A.next;
          }
          return !0;
        }
        function Bd(r, t, n, s) {
          const l = r.prev, d = r, p = r.next;
          if (Bt(l, d, p) >= 0) return !1;
          const m = l.x, g = d.x, x = p.x, b = l.y, w = d.y, I = p.y, E = Math.min(m, g, x), A = Math.min(b, w, I), D = Math.max(m, g, x), F = Math.max(b, w, I), Z = nh(E, A, t, n, s), Y = nh(D, F, t, n, s);
          let $ = r.prevZ, C = r.nextZ;
          for (; $ && $.z >= Z && C && C.z <= Y; ) {
            if ($.x >= E && $.x <= D && $.y >= A && $.y <= F && $ !== l && $ !== p && Ko(m, b, g, w, x, I, $.x, $.y) && Bt($.prev, $, $.next) >= 0 || ($ = $.prevZ, C.x >= E && C.x <= D && C.y >= A && C.y <= F && C !== l && C !== p && Ko(m, b, g, w, x, I, C.x, C.y) && Bt(C.prev, C, C.next) >= 0)) return !1;
            C = C.nextZ;
          }
          for (; $ && $.z >= Z; ) {
            if ($.x >= E && $.x <= D && $.y >= A && $.y <= F && $ !== l && $ !== p && Ko(m, b, g, w, x, I, $.x, $.y) && Bt($.prev, $, $.next) >= 0) return !1;
            $ = $.prevZ;
          }
          for (; C && C.z <= Y; ) {
            if (C.x >= E && C.x <= D && C.y >= A && C.y <= F && C !== l && C !== p && Ko(m, b, g, w, x, I, C.x, C.y) && Bt(C.prev, C, C.next) >= 0) return !1;
            C = C.nextZ;
          }
          return !0;
        }
        function Fd(r, t) {
          let n = r;
          do {
            const s = n.prev, l = n.next.next;
            !za(s, l) && Jh(s, n, n.next, l) && Jo(s, l) && Jo(l, s) && (t.push(s.i, n.i, l.i), Yo(n), Yo(n.next), n = r = l), n = n.next;
          } while (n !== r);
          return zs(n);
        }
        function Od(r, t, n, s, l, d) {
          let p = r;
          do {
            let m = p.next.next;
            for (; m !== p.prev; ) {
              if (p.i !== m.i && Ud(p, m)) {
                let g = Yh(p, m);
                return p = zs(p, p.next), g = zs(g, g.next), Xo(p, t, n, s, l, d, 0), void Xo(g, t, n, s, l, d, 0);
              }
              m = m.next;
            }
            p = p.next;
          } while (p !== r);
        }
        function jd(r, t) {
          let n = r.x - t.x;
          return n === 0 && (n = r.y - t.y, n === 0) && (n = (r.next.y - r.y) / (r.next.x - r.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function Vd(r, t) {
          const n = function(l, d) {
            let p = d;
            const m = l.x, g = l.y;
            let x, b = -1 / 0;
            if (za(l, p)) return p;
            do {
              if (za(l, p.next)) return p.next;
              if (g <= p.y && g >= p.next.y && p.next.y !== p.y) {
                const D = p.x + (g - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (D <= m && D > b && (b = D, x = p.x < p.next.x ? p : p.next, D === m)) return x;
              }
              p = p.next;
            } while (p !== d);
            if (!x) return null;
            const w = x, I = x.x, E = x.y;
            let A = 1 / 0;
            p = x;
            do {
              if (m >= p.x && p.x >= I && m !== p.x && Kh(g < E ? m : b, g, I, E, g < E ? b : m, g, p.x, p.y)) {
                const D = Math.abs(g - p.y) / (m - p.x);
                Jo(p, l) && (D < A || D === A && (p.x > x.x || p.x === x.x && Nd(x, p))) && (x = p, A = D);
              }
              p = p.next;
            } while (p !== w);
            return x;
          }(r, t);
          if (!n) return t;
          const s = Yh(n, r);
          return zs(s, s.next), zs(n, n.next);
        }
        function Nd(r, t) {
          return Bt(r.prev, r, t.prev) < 0 && Bt(t.next, r, r.next) < 0;
        }
        function nh(r, t, n, s, l) {
          return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - n) * l | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - s) * l | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function Zd(r) {
          let t = r, n = r;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== r);
          return n;
        }
        function Kh(r, t, n, s, l, d, p, m) {
          return (l - p) * (t - m) >= (r - p) * (d - m) && (r - p) * (s - m) >= (n - p) * (t - m) && (n - p) * (d - m) >= (l - p) * (s - m);
        }
        function Ko(r, t, n, s, l, d, p, m) {
          return !(r === p && t === m) && Kh(r, t, n, s, l, d, p, m);
        }
        function Ud(r, t) {
          return r.next.i !== t.i && r.prev.i !== t.i && !function(n, s) {
            let l = n;
            do {
              if (l.i !== n.i && l.next.i !== n.i && l.i !== s.i && l.next.i !== s.i && Jh(l, l.next, n, s)) return !0;
              l = l.next;
            } while (l !== n);
            return !1;
          }(r, t) && (Jo(r, t) && Jo(t, r) && function(n, s) {
            let l = n, d = !1;
            const p = (n.x + s.x) / 2, m = (n.y + s.y) / 2;
            do
              l.y > m != l.next.y > m && l.next.y !== l.y && p < (l.next.x - l.x) * (m - l.y) / (l.next.y - l.y) + l.x && (d = !d), l = l.next;
            while (l !== n);
            return d;
          }(r, t) && (Bt(r.prev, r, t.prev) || Bt(r, t.prev, t)) || za(r, t) && Bt(r.prev, r, r.next) > 0 && Bt(t.prev, t, t.next) > 0);
        }
        function Bt(r, t, n) {
          return (t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y);
        }
        function za(r, t) {
          return r.x === t.x && r.y === t.y;
        }
        function Jh(r, t, n, s) {
          const l = cc(Bt(r, t, n)), d = cc(Bt(r, t, s)), p = cc(Bt(n, s, r)), m = cc(Bt(n, s, t));
          return l !== d && p !== m || !(l !== 0 || !lc(r, n, t)) || !(d !== 0 || !lc(r, s, t)) || !(p !== 0 || !lc(n, r, s)) || !(m !== 0 || !lc(n, t, s));
        }
        function lc(r, t, n) {
          return t.x <= Math.max(r.x, n.x) && t.x >= Math.min(r.x, n.x) && t.y <= Math.max(r.y, n.y) && t.y >= Math.min(r.y, n.y);
        }
        function cc(r) {
          return r > 0 ? 1 : r < 0 ? -1 : 0;
        }
        function Jo(r, t) {
          return Bt(r.prev, r, r.next) < 0 ? Bt(r, t, r.next) >= 0 && Bt(r, r.prev, t) >= 0 : Bt(r, t, r.prev) < 0 || Bt(r, r.next, t) < 0;
        }
        function Yh(r, t) {
          const n = sh(r.i, r.x, r.y), s = sh(t.i, t.x, t.y), l = r.next, d = t.prev;
          return r.next = t, t.prev = r, n.next = l, l.prev = n, s.next = n, n.prev = s, d.next = s, s.prev = d, s;
        }
        function Qh(r, t, n, s) {
          const l = sh(r, t, n);
          return s ? (l.next = s.next, l.prev = s, s.next.prev = l, s.next = l) : (l.prev = l, l.next = l), l;
        }
        function Yo(r) {
          r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
        }
        function sh(r, t, n) {
          return { i: r, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class ka {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class hc {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        hc.noSubdivision = new hc({ fill: new ka(0, 0), line: new ka(0, 0), tile: new ka(0, 0), stencil: new ka(0, 0), circle: 1 }), Ae("SubdivisionGranularityExpression", ka), Ae("SubdivisionGranularitySetting", hc);
        const Da = -32768, Qo = 32767;
        class Gd {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = t, this._granularityCellSize = ht / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | (n += 32768) << 0;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const s = 0 | Math.round(t), l = 0 | Math.round(n), d = this._getKey(s, l);
            if (this._vertexDictionary.has(d)) return this._vertexDictionary.get(d);
            const p = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(d, p), this._vertexBuffer.push(s, l), p;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return function(l, d) {
              const p = [];
              for (let m = 0; m < d.length; m += 3) {
                const g = d[m], x = d[m + 1], b = d[m + 2], w = l[2 * g], I = l[2 * g + 1];
                (l[2 * x] - w) * (l[2 * b + 1] - I) - (l[2 * x + 1] - I) * (l[2 * b] - w) > 0 ? (p.push(g), p.push(b), p.push(x)) : (p.push(g), p.push(x), p.push(b));
              }
              return p;
            }(this._vertexBuffer, t);
            const n = [], s = t.length;
            for (let l = 0; l < s; l += 3) {
              const d = [t[l + 0], t[l + 1], t[l + 2]], p = [this._vertexBuffer[2 * t[l + 0] + 0], this._vertexBuffer[2 * t[l + 0] + 1], this._vertexBuffer[2 * t[l + 1] + 0], this._vertexBuffer[2 * t[l + 1] + 1], this._vertexBuffer[2 * t[l + 2] + 0], this._vertexBuffer[2 * t[l + 2] + 1]];
              let m = 1 / 0, g = 1 / 0, x = -1 / 0, b = -1 / 0;
              for (let D = 0; D < 3; D++) {
                const F = p[2 * D], Z = p[2 * D + 1];
                m = Math.min(m, F), x = Math.max(x, F), g = Math.min(g, Z), b = Math.max(b, Z);
              }
              if (m === x || g === b) continue;
              const w = Math.floor(m / this._granularityCellSize), I = Math.ceil(x / this._granularityCellSize), E = Math.floor(g / this._granularityCellSize), A = Math.ceil(b / this._granularityCellSize);
              if (w !== I || E !== A) for (let D = E; D < A; D++) {
                const F = this._scanlineGenerateVertexRingForCellRow(D, p, d);
                $d(this._vertexBuffer, F, n);
              }
              else n.push(...d);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, s) {
            const l = t * this._granularityCellSize, d = l + this._granularityCellSize, p = [];
            for (let m = 0; m < 3; m++) {
              const g = n[2 * m], x = n[2 * m + 1], b = n[2 * (m + 1) % 6], w = n[(2 * (m + 1) + 1) % 6], I = n[2 * (m + 2) % 6], E = n[(2 * (m + 2) + 1) % 6], A = b - g, D = w - x, F = A === 0, Z = D === 0, Y = (l - x) / D, $ = (d - x) / D, C = Math.min(Y, $), B = Math.max(Y, $);
              if (!Z && (C >= 1 || B <= 0) || Z && (x < l || x > d)) {
                w >= l && w <= d && p.push(s[(m + 1) % 3]);
                continue;
              }
              !Z && C > 0 && p.push(this._vertexToIndex(g + A * C, x + D * C));
              const q = g + A * Math.max(C, 0), ae = g + A * Math.min(B, 1);
              F || this._generateIntraEdgeVertices(p, g, x, b, w, q, ae), !Z && B < 1 && p.push(this._vertexToIndex(g + A * B, x + D * B)), (Z || w >= l && w <= d) && p.push(s[(m + 1) % 3]), !Z && (w <= l || w >= d) && this._generateInterEdgeVertices(p, g, x, b, w, I, E, ae, l, d);
            }
            return p;
          }
          _generateIntraEdgeVertices(t, n, s, l, d, p, m) {
            const g = l - n, x = d - s, b = x === 0, w = b ? Math.min(n, l) : Math.min(p, m), I = b ? Math.max(n, l) : Math.max(p, m), E = Math.floor(w / this._granularityCellSize) + 1, A = Math.ceil(I / this._granularityCellSize) - 1;
            if (b ? n < l : p < m) for (let D = E; D <= A; D++) {
              const F = D * this._granularityCellSize;
              t.push(this._vertexToIndex(F, s + x * (F - n) / g));
            }
            else for (let D = A; D >= E; D--) {
              const F = D * this._granularityCellSize;
              t.push(this._vertexToIndex(F, s + x * (F - n) / g));
            }
          }
          _generateInterEdgeVertices(t, n, s, l, d, p, m, g, x, b) {
            const w = d - s, I = p - l, E = m - d, A = (x - d) / E, D = (b - d) / E, F = Math.min(A, D), Z = Math.max(A, D), Y = l + I * F;
            let $ = Math.floor(Math.min(Y, g) / this._granularityCellSize) + 1, C = Math.ceil(Math.max(Y, g) / this._granularityCellSize) - 1, B = g < Y;
            const q = E === 0;
            if (q && (m === x || m === b)) return;
            if (q || F >= 1 || Z <= 0) {
              const ve = s - m, ce = p + (n - p) * Math.min((x - m) / ve, (b - m) / ve);
              $ = Math.floor(Math.min(ce, g) / this._granularityCellSize) + 1, C = Math.ceil(Math.max(ce, g) / this._granularityCellSize) - 1, B = g < ce;
            }
            const ae = w > 0 ? b : x;
            if (B) for (let ve = $; ve <= C; ve++) t.push(this._vertexToIndex(ve * this._granularityCellSize, ae));
            else for (let ve = C; ve >= $; ve--) t.push(this._vertexToIndex(ve * this._granularityCellSize, ae));
          }
          _generateOutline(t) {
            const n = [];
            for (const s of t) {
              const l = ks(s, this._granularity, !0), d = this._pointArrayToIndices(l), p = [];
              for (let m = 1; m < d.length; m++) p.push(d[m - 1]), p.push(d[m]);
              n.push(p);
            }
            return n;
          }
          _handlePoles(t) {
            let n = !1, s = !1;
            this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (s = !0)), (n || s) && this._fillPoles(t, n, s);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const s = t[n + 1];
              s === Da && (t[n + 1] = -32767), s === Qo && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, s, l, d, p) {
            l > d != (p === Da) ? (t.push(n), t.push(s), t.push(this._vertexToIndex(l, p)), t.push(s), t.push(this._vertexToIndex(d, p)), t.push(this._vertexToIndex(l, p))) : (t.push(s), t.push(n), t.push(this._vertexToIndex(l, p)), t.push(this._vertexToIndex(d, p)), t.push(s), t.push(this._vertexToIndex(l, p)));
          }
          _fillPoles(t, n, s) {
            const l = this._vertexBuffer, d = ht, p = t.length;
            for (let m = 2; m < p; m += 3) {
              const g = t[m - 2], x = t[m - 1], b = t[m], w = l[2 * g], I = l[2 * g + 1], E = l[2 * x], A = l[2 * x + 1], D = l[2 * b], F = l[2 * b + 1];
              n && (I === 0 && A === 0 && this._generatePoleQuad(t, g, x, w, E, Da), A === 0 && F === 0 && this._generatePoleQuad(t, x, b, E, D, Da), F === 0 && I === 0 && this._generatePoleQuad(t, b, g, D, w, Da)), s && (I === d && A === d && this._generatePoleQuad(t, g, x, w, E, Qo), A === d && F === d && this._generatePoleQuad(t, x, b, E, D, Qo), F === d && I === d && this._generatePoleQuad(t, b, g, D, w, Qo));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: s, holeIndices: l } = function(m) {
              const g = [], x = [];
              for (const b of m) if (b.length !== 0) {
                b !== m[0] && g.push(x.length / 2);
                for (let w = 0; w < b.length; w++) x.push(b[w].x), x.push(b[w].y);
              }
              return { flattened: x, holeIndices: g };
            }(t);
            let d;
            this._initializeVertices(s);
            try {
              const m = function(x, b, w = 2) {
                const I = b && b.length, E = I ? b[0] * w : x.length;
                let A = Xh(x, 0, E, w, !0);
                const D = [];
                if (!A || A.next === A.prev) return D;
                let F, Z, Y;
                if (I && (A = function($, C, B, q) {
                  const ae = [];
                  for (let ve = 0, ce = C.length; ve < ce; ve++) {
                    const de = Xh($, C[ve] * q, ve < ce - 1 ? C[ve + 1] * q : $.length, q, !1);
                    de === de.next && (de.steiner = !0), ae.push(Zd(de));
                  }
                  ae.sort(jd);
                  for (let ve = 0; ve < ae.length; ve++) B = Vd(ae[ve], B);
                  return B;
                }(x, b, A, w)), x.length > 80 * w) {
                  F = 1 / 0, Z = 1 / 0;
                  let $ = -1 / 0, C = -1 / 0;
                  for (let B = w; B < E; B += w) {
                    const q = x[B], ae = x[B + 1];
                    q < F && (F = q), ae < Z && (Z = ae), q > $ && ($ = q), ae > C && (C = ae);
                  }
                  Y = Math.max($ - F, C - Z), Y = Y !== 0 ? 32767 / Y : 0;
                }
                return Xo(A, D, w, F, Z, Y, 0), D;
              }(s, l), g = this._convertIndices(s, m);
              d = this._subdivideTrianglesScanline(g);
            } catch (m) {
              console.error(m);
            }
            let p = [];
            return n && (p = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(d), { verticesFlattened: this._vertexBuffer, indicesTriangles: d, indicesLineList: p };
          }
          _convertIndices(t, n) {
            const s = [];
            for (let l = 0; l < n.length; l++) s.push(this._vertexToIndex(t[2 * n[l]], t[2 * n[l] + 1]));
            return s;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let s = 0; s < t.length; s++) {
              const l = t[s];
              n.push(this._vertexToIndex(l.x, l.y));
            }
            return n;
          }
        }
        function eu(r, t, n, s = !0) {
          return new Gd(n, t).subdividePolygonInternal(r, s);
        }
        function ks(r, t, n = !1) {
          if (!r || r.length < 1) return [];
          if (r.length < 2) return [];
          const s = r[0], l = r[r.length - 1], d = n && (s.x !== l.x || s.y !== l.y);
          if (t < 2) return d ? [...r, r[0]] : [...r];
          const p = Math.floor(ht / t), m = [];
          m.push(new Ue(r[0].x, r[0].y));
          const g = r.length, x = d ? g : g - 1;
          for (let b = 0; b < x; b++) {
            const w = r[b], I = b < g - 1 ? r[b + 1] : r[0], E = w.x, A = w.y, D = I.x, F = I.y, Z = E !== D, Y = A !== F;
            if (!Z && !Y) continue;
            const $ = D - E, C = F - A, B = Math.abs($), q = Math.abs(C);
            let ae = E, ve = A;
            for (; ; ) {
              const de = $ > 0 ? (Math.floor(ae / p) + 1) * p : (Math.ceil(ae / p) - 1) * p, Te = C > 0 ? (Math.floor(ve / p) + 1) * p : (Math.ceil(ve / p) - 1) * p, we = Math.abs(ae - de), Pe = Math.abs(ve - Te), ge = Math.abs(ae - D), ze = Math.abs(ve - F), Ze = Z ? we / B : Number.POSITIVE_INFINITY, Ve = Y ? Pe / q : Number.POSITIVE_INFINITY;
              if ((ge <= we || !Z) && (ze <= Pe || !Y)) break;
              if (Ze < Ve && Z || !Y) {
                ae = de, ve += C * Ze;
                const Le = new Ue(ae, Math.round(ve));
                m[m.length - 1].x === Le.x && m[m.length - 1].y === Le.y || m.push(Le);
              } else {
                ae += $ * Ve, ve = Te;
                const Le = new Ue(Math.round(ae), ve);
                m[m.length - 1].x === Le.x && m[m.length - 1].y === Le.y || m.push(Le);
              }
            }
            const ce = new Ue(D, F);
            m[m.length - 1].x === ce.x && m[m.length - 1].y === ce.y || m.push(ce);
          }
          return m;
        }
        function $d(r, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let s = 0, l = r[2 * t[0]];
          for (let g = 1; g < t.length; g++) {
            const x = r[2 * t[g]];
            x < l && (l = x, s = g);
          }
          const d = t.length;
          let p = s, m = (p + 1) % d;
          for (; ; ) {
            const g = p - 1 >= 0 ? p - 1 : d - 1, x = (m + 1) % d, b = r[2 * t[g]], w = r[2 * t[x]], I = r[2 * t[p]], E = r[2 * t[p] + 1], A = r[2 * t[m] + 1];
            let D = !1;
            if (b < w) D = !0;
            else if (b > w) D = !1;
            else {
              const F = A - E, Z = -(r[2 * t[m]] - I), Y = E < A ? 1 : -1;
              ((b - I) * F + (r[2 * t[g] + 1] - E) * Z) * Y > ((w - I) * F + (r[2 * t[x] + 1] - E) * Z) * Y && (D = !0);
            }
            if (D) {
              const F = t[g], Z = t[p], Y = t[m];
              F !== Z && F !== Y && Z !== Y && n.push(Y, Z, F), p--, p < 0 && (p = d - 1);
            } else {
              const F = t[x], Z = t[p], Y = t[m];
              F !== Z && F !== Y && Z !== Y && n.push(Y, Z, F), m++, m >= d && (m = 0);
            }
            if (g === x) break;
          }
        }
        function tu(r, t, n, s, l, d, p, m, g) {
          const x = l.length / 2, b = p && m && g;
          if (x < Oe.MAX_VERTEX_ARRAY_LENGTH) {
            const w = t.prepareSegment(x, n, s), I = w.vertexLength;
            for (let D = 0; D < d.length; D += 3) s.emplaceBack(I + d[D], I + d[D + 1], I + d[D + 2]);
            let E, A;
            w.vertexLength += x, w.primitiveLength += d.length / 3, b && (A = p.prepareSegment(x, n, m), E = A.vertexLength, A.vertexLength += x);
            for (let D = 0; D < l.length; D += 2) r(l[D], l[D + 1]);
            if (b) for (let D = 0; D < g.length; D++) {
              const F = g[D];
              for (let Z = 1; Z < F.length; Z += 2) m.emplaceBack(E + F[Z - 1], E + F[Z]);
              A.primitiveLength += F.length / 2;
            }
          } else (function(w, I, E, A, D, F) {
            const Z = [];
            for (let q = 0; q < A.length / 2; q++) Z.push(-1);
            const Y = { count: 0 };
            let $ = 0, C = w.getOrCreateLatestSegment(I, E), B = C.vertexLength;
            for (let q = 2; q < D.length; q += 3) {
              const ae = D[q - 2], ve = D[q - 1], ce = D[q];
              let de = Z[ae] < $, Te = Z[ve] < $, we = Z[ce] < $;
              C.vertexLength + ((de ? 1 : 0) + (Te ? 1 : 0) + (we ? 1 : 0)) > Oe.MAX_VERTEX_ARRAY_LENGTH && (C = w.createNewSegment(I, E), $ = Y.count, de = !0, Te = !0, we = !0, B = 0);
              const Pe = el(Z, A, F, Y, ae, de, C), ge = el(Z, A, F, Y, ve, Te, C), ze = el(Z, A, F, Y, ce, we, C);
              E.emplaceBack(B + Pe - $, B + ge - $, B + ze - $), C.primitiveLength++;
            }
          })(t, n, s, l, d, r), b && function(w, I, E, A, D, F) {
            const Z = [];
            for (let q = 0; q < A.length / 2; q++) Z.push(-1);
            const Y = { count: 0 };
            let $ = 0, C = w.getOrCreateLatestSegment(I, E), B = C.vertexLength;
            for (let q = 0; q < D.length; q++) {
              const ae = D[q];
              for (let ve = 1; ve < D[q].length; ve += 2) {
                const ce = ae[ve - 1], de = ae[ve];
                let Te = Z[ce] < $, we = Z[de] < $;
                C.vertexLength + ((Te ? 1 : 0) + (we ? 1 : 0)) > Oe.MAX_VERTEX_ARRAY_LENGTH && (C = w.createNewSegment(I, E), $ = Y.count, Te = !0, we = !0, B = 0);
                const Pe = el(Z, A, F, Y, ce, Te, C), ge = el(Z, A, F, Y, de, we, C);
                E.emplaceBack(B + Pe - $, B + ge - $), C.primitiveLength++;
              }
            }
          }(p, n, m, l, g, r), t.forceNewSegmentOnNextPrepare(), p == null || p.forceNewSegmentOnNextPrepare();
        }
        function el(r, t, n, s, l, d, p) {
          if (d) {
            const m = s.count;
            return n(t[2 * l], t[2 * l + 1]), r[l] = s.count, s.count++, p.vertexLength++, m;
          }
          return r[l];
        }
        class ah {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new W(), this.indexArray = new Ie(), this.indexArray2 = new Se(), this.programConfigurations = new Sn(t.layers, t.zoom), this.segments = new Oe(), this.segments2 = new Oe(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
          }
          populate(t, n, s) {
            this.hasPattern = ih("fill", this.layers, n);
            const l = this.layers[0].layout.get("fill-sort-key"), d = !l.isConstant(), p = [];
            for (const { feature: m, id: g, index: x, sourceLayerIndex: b } of t) {
              const w = this.layers[0]._featureFilter.needGeometry, I = Ci(m, w);
              if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), I, s)) continue;
              const E = d ? l.evaluate(I, {}, s, n.availableImages) : void 0, A = { id: g, properties: m.properties, type: m.type, sourceLayerIndex: b, index: x, geometry: w ? I.geometry : Mn(m), patterns: {}, sortKey: E };
              p.push(A);
            }
            d && p.sort((m, g) => m.sortKey - g.sortKey);
            for (const m of p) {
              const { geometry: g, index: x, sourceLayerIndex: b } = m;
              if (this.hasPattern) {
                const w = rh("fill", this.layers, m, this.zoom, n);
                this.patternFeatures.push(w);
              } else this.addFeature(m, g, x, s, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[x].feature, g, x, b, this.index);
            }
          }
          update(t, n, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s);
          }
          addFeatures(t, n, s) {
            for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, n, s, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Rd), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, s, l, d, p) {
            for (const m of Ks(n, 500)) {
              const g = eu(m, l, p.fill.getGranularityForZoomLevel(l.z)), x = this.layoutVertexArray;
              tu((b, w) => {
                x.emplaceBack(b, w);
              }, this.segments, this.layoutVertexArray, this.indexArray, g.verticesFlattened, g.indicesTriangles, this.segments2, this.indexArray2, g.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l);
          }
        }
        let iu, ru;
        Ae("FillBucket", ah, { omit: ["layers", "patternFeatures"] });
        var qd = { get paint() {
          return ru = ru || new wi({ "fill-antialias": new Fe(P.paint_fill["fill-antialias"]), "fill-opacity": new Ge(P.paint_fill["fill-opacity"]), "fill-color": new Ge(P.paint_fill["fill-color"]), "fill-outline-color": new Ge(P.paint_fill["fill-outline-color"]), "fill-translate": new Fe(P.paint_fill["fill-translate"]), "fill-translate-anchor": new Fe(P.paint_fill["fill-translate-anchor"]), "fill-pattern": new Cs(P.paint_fill["fill-pattern"]) });
        }, get layout() {
          return iu = iu || new wi({ "fill-sort-key": new Ge(P.layout_fill["fill-sort-key"]) });
        } };
        class Wd extends cr {
          constructor(t) {
            super(t, qd);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const s = this.paint._values["fill-outline-color"];
            s.value.kind === "constant" && s.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new ah(t);
          }
          queryRadius() {
            return ac(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: s, pixelsToTileUnits: l }) {
            return Ea(oc(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -s.bearingInRadians, l), n);
          }
          isTileClipped() {
            return !0;
          }
        }
        const Hd = Lt([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Xd = Lt([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Kd } = Hd;
        var oh, nu, lh, su, ch, au, ou, uc = {};
        function lu() {
          if (nu) return oh;
          nu = 1;
          var r = Ir();
          function t(l, d, p, m, g) {
            this.properties = {}, this.extent = p, this.type = 0, this._pbf = l, this._geometry = -1, this._keys = m, this._values = g, l.readFields(n, this, d);
          }
          function n(l, d, p) {
            l == 1 ? d.id = p.readVarint() : l == 2 ? function(m, g) {
              for (var x = m.readVarint() + m.pos; m.pos < x; ) {
                var b = g._keys[m.readVarint()], w = g._values[m.readVarint()];
                g.properties[b] = w;
              }
            }(p, d) : l == 3 ? d.type = p.readVarint() : l == 4 && (d._geometry = p.pos);
          }
          function s(l) {
            for (var d, p, m = 0, g = 0, x = l.length, b = x - 1; g < x; b = g++) m += ((p = l[b]).x - (d = l[g]).x) * (d.y + p.y);
            return m;
          }
          return oh = t, t.types = ["Unknown", "Point", "LineString", "Polygon"], t.prototype.loadGeometry = function() {
            var l = this._pbf;
            l.pos = this._geometry;
            for (var d, p = l.readVarint() + l.pos, m = 1, g = 0, x = 0, b = 0, w = []; l.pos < p; ) {
              if (g <= 0) {
                var I = l.readVarint();
                m = 7 & I, g = I >> 3;
              }
              if (g--, m === 1 || m === 2) x += l.readSVarint(), b += l.readSVarint(), m === 1 && (d && w.push(d), d = []), d.push(new r(x, b));
              else {
                if (m !== 7) throw new Error("unknown command " + m);
                d && d.push(d[0].clone());
              }
            }
            return d && w.push(d), w;
          }, t.prototype.bbox = function() {
            var l = this._pbf;
            l.pos = this._geometry;
            for (var d = l.readVarint() + l.pos, p = 1, m = 0, g = 0, x = 0, b = 1 / 0, w = -1 / 0, I = 1 / 0, E = -1 / 0; l.pos < d; ) {
              if (m <= 0) {
                var A = l.readVarint();
                p = 7 & A, m = A >> 3;
              }
              if (m--, p === 1 || p === 2) (g += l.readSVarint()) < b && (b = g), g > w && (w = g), (x += l.readSVarint()) < I && (I = x), x > E && (E = x);
              else if (p !== 7) throw new Error("unknown command " + p);
            }
            return [b, I, w, E];
          }, t.prototype.toGeoJSON = function(l, d, p) {
            var m, g, x = this.extent * Math.pow(2, p), b = this.extent * l, w = this.extent * d, I = this.loadGeometry(), E = t.types[this.type];
            function A(Z) {
              for (var Y = 0; Y < Z.length; Y++) {
                var $ = Z[Y];
                Z[Y] = [360 * ($.x + b) / x - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * ($.y + w) / x) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var D = [];
                for (m = 0; m < I.length; m++) D[m] = I[m][0];
                A(I = D);
                break;
              case 2:
                for (m = 0; m < I.length; m++) A(I[m]);
                break;
              case 3:
                for (I = function(Z) {
                  var Y = Z.length;
                  if (Y <= 1) return [Z];
                  for (var $, C, B = [], q = 0; q < Y; q++) {
                    var ae = s(Z[q]);
                    ae !== 0 && (C === void 0 && (C = ae < 0), C === ae < 0 ? ($ && B.push($), $ = [Z[q]]) : $.push(Z[q]));
                  }
                  return $ && B.push($), B;
                }(I), m = 0; m < I.length; m++) for (g = 0; g < I[m].length; g++) A(I[m][g]);
            }
            I.length === 1 ? I = I[0] : E = "Multi" + E;
            var F = { type: "Feature", geometry: { type: E, coordinates: I }, properties: this.properties };
            return "id" in this && (F.id = this.id), F;
          }, oh;
        }
        function cu() {
          if (su) return lh;
          su = 1;
          var r = lu();
          function t(s, l) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = s, this._keys = [], this._values = [], this._features = [], s.readFields(n, this, l), this.length = this._features.length;
          }
          function n(s, l, d) {
            s === 15 ? l.version = d.readVarint() : s === 1 ? l.name = d.readString() : s === 5 ? l.extent = d.readVarint() : s === 2 ? l._features.push(d.pos) : s === 3 ? l._keys.push(d.readString()) : s === 4 && l._values.push(function(p) {
              for (var m = null, g = p.readVarint() + p.pos; p.pos < g; ) {
                var x = p.readVarint() >> 3;
                m = x === 1 ? p.readString() : x === 2 ? p.readFloat() : x === 3 ? p.readDouble() : x === 4 ? p.readVarint64() : x === 5 ? p.readVarint() : x === 6 ? p.readSVarint() : x === 7 ? p.readBoolean() : null;
              }
              return m;
            }(d));
          }
          return lh = t, t.prototype.feature = function(s) {
            if (s < 0 || s >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[s];
            var l = this._pbf.readVarint() + this._pbf.pos;
            return new r(this._pbf, l, this.extent, this._keys, this._values);
          }, lh;
        }
        function hu() {
          return ou || (ou = 1, uc.VectorTile = function() {
            if (au) return ch;
            au = 1;
            var r = cu();
            function t(n, s, l) {
              if (n === 3) {
                var d = new r(l, l.readVarint() + l.pos);
                d.length && (s[d.name] = d);
              }
            }
            return ch = function(n, s) {
              this.layers = n.readFields(t, {}, s);
            }, ch;
          }(), uc.VectorTileFeature = lu(), uc.VectorTileLayer = cu()), uc;
        }
        var tl = fi(hu());
        const Jd = tl.VectorTileFeature.types, hh = Math.pow(2, 13);
        function il(r, t, n, s, l, d, p, m) {
          r.emplaceBack(t, n, 2 * Math.floor(s * hh) + p, l * hh * 2, d * hh * 2, Math.round(m));
        }
        class uh {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new H(), this.centroidVertexArray = new N(), this.indexArray = new Ie(), this.programConfigurations = new Sn(t.layers, t.zoom), this.segments = new Oe(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
          }
          populate(t, n, s) {
            this.features = [], this.hasPattern = ih("fill-extrusion", this.layers, n);
            for (const { feature: l, id: d, index: p, sourceLayerIndex: m } of t) {
              const g = this.layers[0]._featureFilter.needGeometry, x = Ci(l, g);
              if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), x, s)) continue;
              const b = { id: d, sourceLayerIndex: m, index: p, geometry: g ? x.geometry : Mn(l), properties: l.properties, type: l.type, patterns: {} };
              this.hasPattern ? this.features.push(rh("fill-extrusion", this.layers, b, this.zoom, n)) : this.addFeature(b, b.geometry, p, s, {}, n.subdivisionGranularity), n.featureIndex.insert(l, b.geometry, p, m, this.index, !0);
            }
          }
          addFeatures(t, n, s) {
            for (const l of this.features) {
              const { geometry: d } = l;
              this.addFeature(l, d, l.index, n, s, t.subdivisionGranularity);
            }
          }
          update(t, n, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Kd), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Xd.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, s, l, d, p) {
            for (const m of Ks(n, 500)) {
              const g = { x: 0, y: 0, sampleCount: 0 }, x = this.layoutVertexArray.length;
              this.processPolygon(g, l, t, m, p);
              const b = this.layoutVertexArray.length - x, w = Math.floor(g.x / g.sampleCount), I = Math.floor(g.y / g.sampleCount);
              for (let E = 0; E < b; E++) this.centroidVertexArray.emplaceBack(w, I);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l);
          }
          processPolygon(t, n, s, l, d) {
            if (l.length < 1 || uu(l[0])) return;
            for (const w of l) w.length !== 0 && Yd(t, w);
            const p = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, m = d.fill.getGranularityForZoomLevel(n.z), g = Jd[s.type] === "Polygon";
            for (const w of l) {
              if (w.length === 0 || uu(w)) continue;
              const I = ks(w, m, g);
              this._generateSideFaces(I, p);
            }
            if (!g) return;
            const x = eu(l, n, m, !1), b = this.layoutVertexArray;
            tu((w, I) => {
              il(b, w, I, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let s = 0;
            for (let l = 1; l < t.length; l++) {
              const d = t[l], p = t[l - 1];
              if (Qd(d, p)) continue;
              n.segment.vertexLength + 4 > Oe.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const m = d.sub(p)._perp()._unit(), g = p.dist(d);
              s + g > 32768 && (s = 0), il(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 0, s), il(this.layoutVertexArray, d.x, d.y, m.x, m.y, 0, 1, s), s += g, il(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 0, s), il(this.layoutVertexArray, p.x, p.y, m.x, m.y, 0, 1, s);
              const x = n.segment.vertexLength;
              this.indexArray.emplaceBack(x, x + 2, x + 1), this.indexArray.emplaceBack(x + 1, x + 2, x + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function Yd(r, t) {
          for (let n = 0; n < t.length; n++) {
            const s = t[n];
            n === t.length - 1 && t[0].x === s.x && t[0].y === s.y || (r.x += s.x, r.y += s.y, r.sampleCount++);
          }
        }
        function Qd(r, t) {
          return r.x === t.x && (r.x < 0 || r.x > ht) || r.y === t.y && (r.y < 0 || r.y > ht);
        }
        function uu(r) {
          return r.every((t) => t.x < 0) || r.every((t) => t.x > ht) || r.every((t) => t.y < 0) || r.every((t) => t.y > ht);
        }
        let du;
        Ae("FillExtrusionBucket", uh, { omit: ["layers", "features"] });
        var ep = { get paint() {
          return du = du || new wi({ "fill-extrusion-opacity": new Fe(P["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ge(P["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Fe(P["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Fe(P["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Cs(P["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ge(P["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ge(P["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Fe(P["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class tp extends cr {
          constructor(t) {
            super(t, ep);
          }
          createBucket(t) {
            return new uh(t);
          }
          queryRadius() {
            return ac(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p, pixelPosMatrix: m }) {
            const g = oc(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -d.bearingInRadians, p), x = this.paint.get("fill-extrusion-height").evaluate(n, s), b = this.paint.get("fill-extrusion-base").evaluate(n, s), w = function(E, A, D) {
              const F = [];
              for (const Z of E) {
                const Y = [Z.x, Z.y, 0, 1];
                fr(Y, Y, A), F.push(new Ue(Y[0] / Y[3], Y[1] / Y[3]));
              }
              return F;
            }(g, m), I = function(E, A, D, F) {
              const Z = [], Y = [], $ = F[8] * A, C = F[9] * A, B = F[10] * A, q = F[11] * A, ae = F[8] * D, ve = F[9] * D, ce = F[10] * D, de = F[11] * D;
              for (const Te of E) {
                const we = [], Pe = [];
                for (const ge of Te) {
                  const ze = ge.x, Ze = ge.y, Ve = F[0] * ze + F[4] * Ze + F[12], Le = F[1] * ze + F[5] * Ze + F[13], Qe = F[2] * ze + F[6] * Ze + F[14], At = F[3] * ze + F[7] * Ze + F[15], qt = Qe + B, pi = At + q, tr = Ve + ae, Ai = Le + ve, si = Qe + ce, St = At + de, Yt = new Ue((Ve + $) / pi, (Le + C) / pi);
                  Yt.z = qt / pi, we.push(Yt);
                  const ai = new Ue(tr / St, Ai / St);
                  ai.z = si / St, Pe.push(ai);
                }
                Z.push(we), Y.push(Pe);
              }
              return [Z, Y];
            }(l, b, x, m);
            return function(E, A, D) {
              let F = 1 / 0;
              Ea(D, A) && (F = pu(D, A[0]));
              for (let Z = 0; Z < A.length; Z++) {
                const Y = A[Z], $ = E[Z];
                for (let C = 0; C < Y.length - 1; C++) {
                  const B = Y[C], q = [B, Y[C + 1], $[C + 1], $[C], B];
                  Ca(D, q) && (F = Math.min(F, pu(D, q)));
                }
              }
              return F !== 1 / 0 && F;
            }(I[0], I[1], w);
          }
        }
        function rl(r, t) {
          return r.x * t.x + r.y * t.y;
        }
        function pu(r, t) {
          if (r.length === 1) {
            let n = 0;
            const s = t[n++];
            let l;
            for (; !l || s.equals(l); ) if (l = t[n++], !l) return 1 / 0;
            for (; n < t.length; n++) {
              const d = t[n], p = r[0], m = l.sub(s), g = d.sub(s), x = p.sub(s), b = rl(m, m), w = rl(m, g), I = rl(g, g), E = rl(x, m), A = rl(x, g), D = b * I - w * w, F = (I * E - w * A) / D, Z = (b * A - w * E) / D, Y = s.z * (1 - F - Z) + l.z * F + d.z * Z;
              if (isFinite(Y)) return Y;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const s of t) n = Math.min(n, s.z);
            return n;
          }
        }
        const ip = Lt([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: rp } = ip, np = Lt([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: sp } = np, ap = tl.VectorTileFeature.types, op = Math.cos(Math.PI / 180 * 37.5), fu = Math.pow(2, 14) / 0.5;
        class dh {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
              this.gradients[n.id] = {};
            }), this.layoutVertexArray = new K(), this.layoutVertexArray2 = new Q(), this.indexArray = new Ie(), this.programConfigurations = new Sn(t.layers, t.zoom), this.segments = new Oe(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
          }
          populate(t, n, s) {
            this.hasPattern = ih("line", this.layers, n);
            const l = this.layers[0].layout.get("line-sort-key"), d = !l.isConstant(), p = [];
            for (const { feature: m, id: g, index: x, sourceLayerIndex: b } of t) {
              const w = this.layers[0]._featureFilter.needGeometry, I = Ci(m, w);
              if (!this.layers[0]._featureFilter.filter(new Tt(this.zoom), I, s)) continue;
              const E = d ? l.evaluate(I, {}, s) : void 0, A = { id: g, properties: m.properties, type: m.type, sourceLayerIndex: b, index: x, geometry: w ? I.geometry : Mn(m), patterns: {}, sortKey: E };
              p.push(A);
            }
            d && p.sort((m, g) => m.sortKey - g.sortKey);
            for (const m of p) {
              const { geometry: g, index: x, sourceLayerIndex: b } = m;
              if (this.hasPattern) {
                const w = rh("line", this.layers, m, this.zoom, n);
                this.patternFeatures.push(w);
              } else this.addFeature(m, g, x, s, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[x].feature, g, x, b, this.index);
            }
          }
          update(t, n, s) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s);
          }
          addFeatures(t, n, s) {
            for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, n, s, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, sp)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, rp), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, s, l, d, p) {
            const m = this.layers[0].layout, g = m.get("line-join").evaluate(t, {}), x = m.get("line-cap"), b = m.get("line-miter-limit"), w = m.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const I of n) this.addLine(I, t, g, x, b, w, l, p);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l);
          }
          addLine(t, n, s, l, d, p, m, g) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ks(t, m ? g.line.getGranularityForZoomLevel(m.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let $ = 0; $ < t.length - 1; $++) this.totalDistance += t[$].dist(t[$ + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const x = ap[n.type] === "Polygon";
            let b = t.length;
            for (; b >= 2 && t[b - 1].equals(t[b - 2]); ) b--;
            let w = 0;
            for (; w < b - 1 && t[w].equals(t[w + 1]); ) w++;
            if (b < (x ? 3 : 2)) return;
            s === "bevel" && (d = 1.05);
            const I = this.overscaling <= 16 ? 15 * ht / (512 * this.overscaling) : 0, E = this.segments.prepareSegment(10 * b, this.layoutVertexArray, this.indexArray);
            let A, D, F, Z, Y;
            this.e1 = this.e2 = -1, x && (A = t[b - 2], Y = t[w].sub(A)._unit()._perp());
            for (let $ = w; $ < b; $++) {
              if (F = $ === b - 1 ? x ? t[w + 1] : void 0 : t[$ + 1], F && t[$].equals(F)) continue;
              Y && (Z = Y), A && (D = A), A = t[$], Y = F ? F.sub(A)._unit()._perp() : Z, Z = Z || Y;
              let C = Z.add(Y);
              C.x === 0 && C.y === 0 || C._unit();
              const B = Z.x * Y.x + Z.y * Y.y, q = C.x * Y.x + C.y * Y.y, ae = q !== 0 ? 1 / q : 1 / 0, ve = 2 * Math.sqrt(2 - 2 * q), ce = q < op && D && F, de = Z.x * Y.y - Z.y * Y.x > 0;
              if (ce && $ > w) {
                const Pe = A.dist(D);
                if (Pe > 2 * I) {
                  const ge = A.sub(A.sub(D)._mult(I / Pe)._round());
                  this.updateDistance(D, ge), this.addCurrentVertex(ge, Z, 0, 0, E), D = ge;
                }
              }
              const Te = D && F;
              let we = Te ? s : x ? "butt" : l;
              if (Te && we === "round" && (ae < p ? we = "miter" : ae <= 2 && (we = "fakeround")), we === "miter" && ae > d && (we = "bevel"), we === "bevel" && (ae > 2 && (we = "flipbevel"), ae < d && (we = "miter")), D && this.updateDistance(D, A), we === "miter") C._mult(ae), this.addCurrentVertex(A, C, 0, 0, E);
              else if (we === "flipbevel") {
                if (ae > 100) C = Y.mult(-1);
                else {
                  const Pe = ae * Z.add(Y).mag() / Z.sub(Y).mag();
                  C._perp()._mult(Pe * (de ? -1 : 1));
                }
                this.addCurrentVertex(A, C, 0, 0, E), this.addCurrentVertex(A, C.mult(-1), 0, 0, E);
              } else if (we === "bevel" || we === "fakeround") {
                const Pe = -Math.sqrt(ae * ae - 1), ge = de ? Pe : 0, ze = de ? 0 : Pe;
                if (D && this.addCurrentVertex(A, Z, ge, ze, E), we === "fakeround") {
                  const Ze = Math.round(180 * ve / Math.PI / 20);
                  for (let Ve = 1; Ve < Ze; Ve++) {
                    let Le = Ve / Ze;
                    if (Le !== 0.5) {
                      const At = Le - 0.5;
                      Le += Le * At * (Le - 1) * ((1.0904 + B * (B * (3.55645 - 1.43519 * B) - 3.2452)) * At * At + (0.848013 + B * (0.215638 * B - 1.06021)));
                    }
                    const Qe = Y.sub(Z)._mult(Le)._add(Z)._unit()._mult(de ? -1 : 1);
                    this.addHalfVertex(A, Qe.x, Qe.y, !1, de, 0, E);
                  }
                }
                F && this.addCurrentVertex(A, Y, -ge, -ze, E);
              } else if (we === "butt") this.addCurrentVertex(A, C, 0, 0, E);
              else if (we === "square") {
                const Pe = D ? 1 : -1;
                this.addCurrentVertex(A, C, Pe, Pe, E);
              } else we === "round" && (D && (this.addCurrentVertex(A, Z, 0, 0, E), this.addCurrentVertex(A, Z, 1, 1, E, !0)), F && (this.addCurrentVertex(A, Y, -1, -1, E, !0), this.addCurrentVertex(A, Y, 0, 0, E)));
              if (ce && $ < b - 1) {
                const Pe = A.dist(F);
                if (Pe > 2 * I) {
                  const ge = A.add(F.sub(A)._mult(I / Pe)._round());
                  this.updateDistance(A, ge), this.addCurrentVertex(ge, Y, 0, 0, E), A = ge;
                }
              }
            }
          }
          addCurrentVertex(t, n, s, l, d, p = !1) {
            const m = n.y * l - n.x, g = -n.y - n.x * l;
            this.addHalfVertex(t, n.x + n.y * s, n.y - n.x * s, p, !1, s, d), this.addHalfVertex(t, m, g, p, !0, -l, d), this.distance > fu / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, s, l, d, p));
          }
          addHalfVertex({ x: t, y: n }, s, l, d, p, m, g) {
            const x = 0.5 * (this.lineClips ? this.scaledDistance * (fu - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (d ? 1 : 0), (n << 1) + (p ? 1 : 0), Math.round(63 * s) + 128, Math.round(63 * l) + 128, 1 + (m === 0 ? 0 : m < 0 ? -1 : 1) | (63 & x) << 2, x >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const b = g.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, b, this.e2), g.primitiveLength++), p ? this.e2 = b : this.e1 = b;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
        }
        let mu, _u;
        Ae("LineBucket", dh, { omit: ["layers", "patternFeatures"] });
        var gu = { get paint() {
          return _u = _u || new wi({ "line-opacity": new Ge(P.paint_line["line-opacity"]), "line-color": new Ge(P.paint_line["line-color"]), "line-translate": new Fe(P.paint_line["line-translate"]), "line-translate-anchor": new Fe(P.paint_line["line-translate-anchor"]), "line-width": new Ge(P.paint_line["line-width"]), "line-gap-width": new Ge(P.paint_line["line-gap-width"]), "line-offset": new Ge(P.paint_line["line-offset"]), "line-blur": new Ge(P.paint_line["line-blur"]), "line-dasharray": new xa(P.paint_line["line-dasharray"]), "line-pattern": new Cs(P.paint_line["line-pattern"]), "line-gradient": new Vo(P.paint_line["line-gradient"]) });
        }, get layout() {
          return mu = mu || new wi({ "line-cap": new Fe(P.layout_line["line-cap"]), "line-join": new Ge(P.layout_line["line-join"]), "line-miter-limit": new Fe(P.layout_line["line-miter-limit"]), "line-round-limit": new Fe(P.layout_line["line-round-limit"]), "line-sort-key": new Ge(P.layout_line["line-sort-key"]) });
        } };
        class lp extends Ge {
          possiblyEvaluate(t, n) {
            return n = new Tt(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, s, l) {
            return n = ii({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, s, l);
          }
        }
        let dc;
        class cp extends cr {
          constructor(t) {
            super(t, gu), this.gradientVersion = 0, dc || (dc = new lp(gu.paint.properties["line-width"].specification), dc.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!function(s) {
                return s._styleExpression !== void 0;
              }(n) && n._styleExpression.expression instanceof jn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = dc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new dh(t);
          }
          queryRadius(t) {
            const n = t, s = yu(Wo("line-width", this, n), Wo("line-gap-width", this, n)), l = Wo("line-offset", this, n);
            return s / 2 + Math.abs(l) + ac(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p }) {
            const m = oc(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -d.bearingInRadians, p), g = p / 2 * yu(this.paint.get("line-width").evaluate(n, s), this.paint.get("line-gap-width").evaluate(n, s)), x = this.paint.get("line-offset").evaluate(n, s);
            return x && (l = function(b, w) {
              const I = [];
              for (let E = 0; E < b.length; E++) {
                const A = b[E], D = [];
                for (let F = 0; F < A.length; F++) {
                  const Z = A[F - 1], Y = A[F], $ = A[F + 1], C = F === 0 ? new Ue(0, 0) : Y.sub(Z)._unit()._perp(), B = F === A.length - 1 ? new Ue(0, 0) : $.sub(Y)._unit()._perp(), q = C._add(B)._unit(), ae = q.x * B.x + q.y * B.y;
                  ae !== 0 && q._mult(1 / ae), D.push(q._mult(w)._add(Y));
                }
                I.push(D);
              }
              return I;
            }(l, x * p)), function(b, w, I) {
              for (let E = 0; E < w.length; E++) {
                const A = w[E];
                if (b.length >= 3) {
                  for (let D = 0; D < A.length; D++) if (Aa(b, A[D])) return !0;
                }
                if (Pd(b, A, I)) return !0;
              }
              return !1;
            }(m, l, g);
          }
          isTileClipped() {
            return !0;
          }
        }
        function yu(r, t) {
          return t > 0 ? t + 2 * r : r;
        }
        const hp = Lt([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), up = Lt([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Lt([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const dp = Lt([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Lt([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const xu = Lt([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), pp = Lt([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function fp(r, t, n) {
          return r.sections.forEach((s) => {
            s.text = function(l, d, p) {
              const m = d.layout.get("text-transform").evaluate(p, {});
              return m === "uppercase" ? l = l.toLocaleUpperCase() : m === "lowercase" && (l = l.toLocaleLowerCase()), Zr.applyArabicShaping && (l = Zr.applyArabicShaping(l)), l;
            }(s.text, t, n);
          }), r;
        }
        Lt([{ name: "triangle", components: 3, type: "Uint16" }]), Lt([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Lt([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Lt([{ type: "Float32", name: "offsetX" }]), Lt([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Lt([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const nl = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var vu, ph, bu, $t = 24, fh = {};
        function mp() {
          return vu || (vu = 1, fh.read = function(r, t, n, s, l) {
            var d, p, m = 8 * l - s - 1, g = (1 << m) - 1, x = g >> 1, b = -7, w = n ? l - 1 : 0, I = n ? -1 : 1, E = r[t + w];
            for (w += I, d = E & (1 << -b) - 1, E >>= -b, b += m; b > 0; d = 256 * d + r[t + w], w += I, b -= 8) ;
            for (p = d & (1 << -b) - 1, d >>= -b, b += s; b > 0; p = 256 * p + r[t + w], w += I, b -= 8) ;
            if (d === 0) d = 1 - x;
            else {
              if (d === g) return p ? NaN : 1 / 0 * (E ? -1 : 1);
              p += Math.pow(2, s), d -= x;
            }
            return (E ? -1 : 1) * p * Math.pow(2, d - s);
          }, fh.write = function(r, t, n, s, l, d) {
            var p, m, g, x = 8 * d - l - 1, b = (1 << x) - 1, w = b >> 1, I = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = s ? 0 : d - 1, A = s ? 1 : -1, D = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (m = isNaN(t) ? 1 : 0, p = b) : (p = Math.floor(Math.log(t) / Math.LN2), t * (g = Math.pow(2, -p)) < 1 && (p--, g *= 2), (t += p + w >= 1 ? I / g : I * Math.pow(2, 1 - w)) * g >= 2 && (p++, g /= 2), p + w >= b ? (m = 0, p = b) : p + w >= 1 ? (m = (t * g - 1) * Math.pow(2, l), p += w) : (m = t * Math.pow(2, w - 1) * Math.pow(2, l), p = 0)); l >= 8; r[n + E] = 255 & m, E += A, m /= 256, l -= 8) ;
            for (p = p << l | m, x += l; x > 0; r[n + E] = 255 & p, E += A, p /= 256, x -= 8) ;
            r[n + E - A] |= 128 * D;
          }), fh;
        }
        function wu() {
          if (bu) return ph;
          bu = 1, ph = t;
          var r = mp();
          function t(C) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(C) ? C : new Uint8Array(C || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          t.Varint = 0, t.Fixed64 = 1, t.Bytes = 2, t.Fixed32 = 5;
          var n = 4294967296, s = 1 / n, l = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
          function d(C) {
            return C.type === t.Bytes ? C.readVarint() + C.pos : C.pos + 1;
          }
          function p(C, B, q) {
            return q ? 4294967296 * B + (C >>> 0) : 4294967296 * (B >>> 0) + (C >>> 0);
          }
          function m(C, B, q) {
            var ae = B <= 16383 ? 1 : B <= 2097151 ? 2 : B <= 268435455 ? 3 : Math.floor(Math.log(B) / (7 * Math.LN2));
            q.realloc(ae);
            for (var ve = q.pos - 1; ve >= C; ve--) q.buf[ve + ae] = q.buf[ve];
          }
          function g(C, B) {
            for (var q = 0; q < C.length; q++) B.writeVarint(C[q]);
          }
          function x(C, B) {
            for (var q = 0; q < C.length; q++) B.writeSVarint(C[q]);
          }
          function b(C, B) {
            for (var q = 0; q < C.length; q++) B.writeFloat(C[q]);
          }
          function w(C, B) {
            for (var q = 0; q < C.length; q++) B.writeDouble(C[q]);
          }
          function I(C, B) {
            for (var q = 0; q < C.length; q++) B.writeBoolean(C[q]);
          }
          function E(C, B) {
            for (var q = 0; q < C.length; q++) B.writeFixed32(C[q]);
          }
          function A(C, B) {
            for (var q = 0; q < C.length; q++) B.writeSFixed32(C[q]);
          }
          function D(C, B) {
            for (var q = 0; q < C.length; q++) B.writeFixed64(C[q]);
          }
          function F(C, B) {
            for (var q = 0; q < C.length; q++) B.writeSFixed64(C[q]);
          }
          function Z(C, B) {
            return (C[B] | C[B + 1] << 8 | C[B + 2] << 16) + 16777216 * C[B + 3];
          }
          function Y(C, B, q) {
            C[q] = B, C[q + 1] = B >>> 8, C[q + 2] = B >>> 16, C[q + 3] = B >>> 24;
          }
          function $(C, B) {
            return (C[B] | C[B + 1] << 8 | C[B + 2] << 16) + (C[B + 3] << 24);
          }
          return t.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(C, B, q) {
            for (q = q || this.length; this.pos < q; ) {
              var ae = this.readVarint(), ve = ae >> 3, ce = this.pos;
              this.type = 7 & ae, C(ve, B, this), this.pos === ce && this.skip(ae);
            }
            return B;
          }, readMessage: function(C, B) {
            return this.readFields(C, B, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var C = Z(this.buf, this.pos);
            return this.pos += 4, C;
          }, readSFixed32: function() {
            var C = $(this.buf, this.pos);
            return this.pos += 4, C;
          }, readFixed64: function() {
            var C = Z(this.buf, this.pos) + Z(this.buf, this.pos + 4) * n;
            return this.pos += 8, C;
          }, readSFixed64: function() {
            var C = Z(this.buf, this.pos) + $(this.buf, this.pos + 4) * n;
            return this.pos += 8, C;
          }, readFloat: function() {
            var C = r.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, C;
          }, readDouble: function() {
            var C = r.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, C;
          }, readVarint: function(C) {
            var B, q, ae = this.buf;
            return B = 127 & (q = ae[this.pos++]), q < 128 ? B : (B |= (127 & (q = ae[this.pos++])) << 7, q < 128 ? B : (B |= (127 & (q = ae[this.pos++])) << 14, q < 128 ? B : (B |= (127 & (q = ae[this.pos++])) << 21, q < 128 ? B : function(ve, ce, de) {
              var Te, we, Pe = de.buf;
              if (Te = (112 & (we = Pe[de.pos++])) >> 4, we < 128 || (Te |= (127 & (we = Pe[de.pos++])) << 3, we < 128) || (Te |= (127 & (we = Pe[de.pos++])) << 10, we < 128) || (Te |= (127 & (we = Pe[de.pos++])) << 17, we < 128) || (Te |= (127 & (we = Pe[de.pos++])) << 24, we < 128) || (Te |= (1 & (we = Pe[de.pos++])) << 31, we < 128)) return p(ve, Te, ce);
              throw new Error("Expected varint not more than 10 bytes");
            }(B |= (15 & (q = ae[this.pos])) << 28, C, this))));
          }, readVarint64: function() {
            return this.readVarint(!0);
          }, readSVarint: function() {
            var C = this.readVarint();
            return C % 2 == 1 ? (C + 1) / -2 : C / 2;
          }, readBoolean: function() {
            return !!this.readVarint();
          }, readString: function() {
            var C = this.readVarint() + this.pos, B = this.pos;
            return this.pos = C, C - B >= 12 && l ? function(q, ae, ve) {
              return l.decode(q.subarray(ae, ve));
            }(this.buf, B, C) : function(q, ae, ve) {
              for (var ce = "", de = ae; de < ve; ) {
                var Te, we, Pe, ge = q[de], ze = null, Ze = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
                if (de + Ze > ve) break;
                Ze === 1 ? ge < 128 && (ze = ge) : Ze === 2 ? (192 & (Te = q[de + 1])) == 128 && (ze = (31 & ge) << 6 | 63 & Te) <= 127 && (ze = null) : Ze === 3 ? (we = q[de + 2], (192 & (Te = q[de + 1])) == 128 && (192 & we) == 128 && ((ze = (15 & ge) << 12 | (63 & Te) << 6 | 63 & we) <= 2047 || ze >= 55296 && ze <= 57343) && (ze = null)) : Ze === 4 && (we = q[de + 2], Pe = q[de + 3], (192 & (Te = q[de + 1])) == 128 && (192 & we) == 128 && (192 & Pe) == 128 && ((ze = (15 & ge) << 18 | (63 & Te) << 12 | (63 & we) << 6 | 63 & Pe) <= 65535 || ze >= 1114112) && (ze = null)), ze === null ? (ze = 65533, Ze = 1) : ze > 65535 && (ze -= 65536, ce += String.fromCharCode(ze >>> 10 & 1023 | 55296), ze = 56320 | 1023 & ze), ce += String.fromCharCode(ze), de += Ze;
              }
              return ce;
            }(this.buf, B, C);
          }, readBytes: function() {
            var C = this.readVarint() + this.pos, B = this.buf.subarray(this.pos, C);
            return this.pos = C, B;
          }, readPackedVarint: function(C, B) {
            if (this.type !== t.Bytes) return C.push(this.readVarint(B));
            var q = d(this);
            for (C = C || []; this.pos < q; ) C.push(this.readVarint(B));
            return C;
          }, readPackedSVarint: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readSVarint());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readSVarint());
            return C;
          }, readPackedBoolean: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readBoolean());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readBoolean());
            return C;
          }, readPackedFloat: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readFloat());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readFloat());
            return C;
          }, readPackedDouble: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readDouble());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readDouble());
            return C;
          }, readPackedFixed32: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readFixed32());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readFixed32());
            return C;
          }, readPackedSFixed32: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readSFixed32());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readSFixed32());
            return C;
          }, readPackedFixed64: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readFixed64());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readFixed64());
            return C;
          }, readPackedSFixed64: function(C) {
            if (this.type !== t.Bytes) return C.push(this.readSFixed64());
            var B = d(this);
            for (C = C || []; this.pos < B; ) C.push(this.readSFixed64());
            return C;
          }, skip: function(C) {
            var B = 7 & C;
            if (B === t.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (B === t.Bytes) this.pos = this.readVarint() + this.pos;
            else if (B === t.Fixed32) this.pos += 4;
            else {
              if (B !== t.Fixed64) throw new Error("Unimplemented type: " + B);
              this.pos += 8;
            }
          }, writeTag: function(C, B) {
            this.writeVarint(C << 3 | B);
          }, realloc: function(C) {
            for (var B = this.length || 16; B < this.pos + C; ) B *= 2;
            if (B !== this.length) {
              var q = new Uint8Array(B);
              q.set(this.buf), this.buf = q, this.length = B;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(C) {
            this.realloc(4), Y(this.buf, C, this.pos), this.pos += 4;
          }, writeSFixed32: function(C) {
            this.realloc(4), Y(this.buf, C, this.pos), this.pos += 4;
          }, writeFixed64: function(C) {
            this.realloc(8), Y(this.buf, -1 & C, this.pos), Y(this.buf, Math.floor(C * s), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(C) {
            this.realloc(8), Y(this.buf, -1 & C, this.pos), Y(this.buf, Math.floor(C * s), this.pos + 4), this.pos += 8;
          }, writeVarint: function(C) {
            (C = +C || 0) > 268435455 || C < 0 ? function(B, q) {
              var ae, ve;
              if (B >= 0 ? (ae = B % 4294967296 | 0, ve = B / 4294967296 | 0) : (ve = ~(-B / 4294967296), 4294967295 ^ (ae = ~(-B % 4294967296)) ? ae = ae + 1 | 0 : (ae = 0, ve = ve + 1 | 0)), B >= 18446744073709552e3 || B < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              q.realloc(10), function(ce, de, Te) {
                Te.buf[Te.pos++] = 127 & ce | 128, ce >>>= 7, Te.buf[Te.pos++] = 127 & ce | 128, ce >>>= 7, Te.buf[Te.pos++] = 127 & ce | 128, ce >>>= 7, Te.buf[Te.pos++] = 127 & ce | 128, Te.buf[Te.pos] = 127 & (ce >>>= 7);
              }(ae, 0, q), function(ce, de) {
                var Te = (7 & ce) << 4;
                de.buf[de.pos++] |= Te | ((ce >>>= 3) ? 128 : 0), ce && (de.buf[de.pos++] = 127 & ce | ((ce >>>= 7) ? 128 : 0), ce && (de.buf[de.pos++] = 127 & ce | ((ce >>>= 7) ? 128 : 0), ce && (de.buf[de.pos++] = 127 & ce | ((ce >>>= 7) ? 128 : 0), ce && (de.buf[de.pos++] = 127 & ce | ((ce >>>= 7) ? 128 : 0), ce && (de.buf[de.pos++] = 127 & ce)))));
              }(ve, q);
            }(C, this) : (this.realloc(4), this.buf[this.pos++] = 127 & C | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = 127 & (C >>>= 7) | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = 127 & (C >>>= 7) | (C > 127 ? 128 : 0), C <= 127 || (this.buf[this.pos++] = C >>> 7 & 127))));
          }, writeSVarint: function(C) {
            this.writeVarint(C < 0 ? 2 * -C - 1 : 2 * C);
          }, writeBoolean: function(C) {
            this.writeVarint(!!C);
          }, writeString: function(C) {
            C = String(C), this.realloc(4 * C.length), this.pos++;
            var B = this.pos;
            this.pos = function(ae, ve, ce) {
              for (var de, Te, we = 0; we < ve.length; we++) {
                if ((de = ve.charCodeAt(we)) > 55295 && de < 57344) {
                  if (!Te) {
                    de > 56319 || we + 1 === ve.length ? (ae[ce++] = 239, ae[ce++] = 191, ae[ce++] = 189) : Te = de;
                    continue;
                  }
                  if (de < 56320) {
                    ae[ce++] = 239, ae[ce++] = 191, ae[ce++] = 189, Te = de;
                    continue;
                  }
                  de = Te - 55296 << 10 | de - 56320 | 65536, Te = null;
                } else Te && (ae[ce++] = 239, ae[ce++] = 191, ae[ce++] = 189, Te = null);
                de < 128 ? ae[ce++] = de : (de < 2048 ? ae[ce++] = de >> 6 | 192 : (de < 65536 ? ae[ce++] = de >> 12 | 224 : (ae[ce++] = de >> 18 | 240, ae[ce++] = de >> 12 & 63 | 128), ae[ce++] = de >> 6 & 63 | 128), ae[ce++] = 63 & de | 128);
              }
              return ce;
            }(this.buf, C, this.pos);
            var q = this.pos - B;
            q >= 128 && m(B, q, this), this.pos = B - 1, this.writeVarint(q), this.pos += q;
          }, writeFloat: function(C) {
            this.realloc(4), r.write(this.buf, C, this.pos, !0, 23, 4), this.pos += 4;
          }, writeDouble: function(C) {
            this.realloc(8), r.write(this.buf, C, this.pos, !0, 52, 8), this.pos += 8;
          }, writeBytes: function(C) {
            var B = C.length;
            this.writeVarint(B), this.realloc(B);
            for (var q = 0; q < B; q++) this.buf[this.pos++] = C[q];
          }, writeRawMessage: function(C, B) {
            this.pos++;
            var q = this.pos;
            C(B, this);
            var ae = this.pos - q;
            ae >= 128 && m(q, ae, this), this.pos = q - 1, this.writeVarint(ae), this.pos += ae;
          }, writeMessage: function(C, B, q) {
            this.writeTag(C, t.Bytes), this.writeRawMessage(B, q);
          }, writePackedVarint: function(C, B) {
            B.length && this.writeMessage(C, g, B);
          }, writePackedSVarint: function(C, B) {
            B.length && this.writeMessage(C, x, B);
          }, writePackedBoolean: function(C, B) {
            B.length && this.writeMessage(C, I, B);
          }, writePackedFloat: function(C, B) {
            B.length && this.writeMessage(C, b, B);
          }, writePackedDouble: function(C, B) {
            B.length && this.writeMessage(C, w, B);
          }, writePackedFixed32: function(C, B) {
            B.length && this.writeMessage(C, E, B);
          }, writePackedSFixed32: function(C, B) {
            B.length && this.writeMessage(C, A, B);
          }, writePackedFixed64: function(C, B) {
            B.length && this.writeMessage(C, D, B);
          }, writePackedSFixed64: function(C, B) {
            B.length && this.writeMessage(C, F, B);
          }, writeBytesField: function(C, B) {
            this.writeTag(C, t.Bytes), this.writeBytes(B);
          }, writeFixed32Field: function(C, B) {
            this.writeTag(C, t.Fixed32), this.writeFixed32(B);
          }, writeSFixed32Field: function(C, B) {
            this.writeTag(C, t.Fixed32), this.writeSFixed32(B);
          }, writeFixed64Field: function(C, B) {
            this.writeTag(C, t.Fixed64), this.writeFixed64(B);
          }, writeSFixed64Field: function(C, B) {
            this.writeTag(C, t.Fixed64), this.writeSFixed64(B);
          }, writeVarintField: function(C, B) {
            this.writeTag(C, t.Varint), this.writeVarint(B);
          }, writeSVarintField: function(C, B) {
            this.writeTag(C, t.Varint), this.writeSVarint(B);
          }, writeStringField: function(C, B) {
            this.writeTag(C, t.Bytes), this.writeString(B);
          }, writeFloatField: function(C, B) {
            this.writeTag(C, t.Fixed32), this.writeFloat(B);
          }, writeDoubleField: function(C, B) {
            this.writeTag(C, t.Fixed64), this.writeDouble(B);
          }, writeBooleanField: function(C, B) {
            this.writeVarintField(C, !!B);
          } }, ph;
        }
        var mh = fi(wu());
        const _h = 3;
        function _p(r, t, n) {
          r === 1 && n.readMessage(gp, t);
        }
        function gp(r, t, n) {
          if (r === 3) {
            const { id: s, bitmap: l, width: d, height: p, left: m, top: g, advance: x } = n.readMessage(yp, {});
            t.push({ id: s, bitmap: new Ho({ width: d + 2 * _h, height: p + 2 * _h }, l), metrics: { width: d, height: p, left: m, top: g, advance: x } });
          }
        }
        function yp(r, t, n) {
          r === 1 ? t.id = n.readVarint() : r === 2 ? t.bitmap = n.readBytes() : r === 3 ? t.width = n.readVarint() : r === 4 ? t.height = n.readVarint() : r === 5 ? t.left = n.readSVarint() : r === 6 ? t.top = n.readSVarint() : r === 7 && (t.advance = n.readVarint());
        }
        const xp = _h;
        function Tu(r) {
          let t = 0, n = 0;
          for (const p of r) t += p.w * p.h, n = Math.max(n, p.w);
          r.sort((p, m) => m.h - p.h);
          const s = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let l = 0, d = 0;
          for (const p of r) for (let m = s.length - 1; m >= 0; m--) {
            const g = s[m];
            if (!(p.w > g.w || p.h > g.h)) {
              if (p.x = g.x, p.y = g.y, d = Math.max(d, p.y + p.h), l = Math.max(l, p.x + p.w), p.w === g.w && p.h === g.h) {
                const x = s.pop();
                m < s.length && (s[m] = x);
              } else p.h === g.h ? (g.x += p.w, g.w -= p.w) : p.w === g.w ? (g.y += p.h, g.h -= p.h) : (s.push({ x: g.x + p.w, y: g.y, w: g.w - p.w, h: p.h }), g.y += p.h, g.h -= p.h);
              break;
            }
          }
          return { w: l, h: d, fill: t / (l * d) || 0 };
        }
        const Ei = 1;
        class gh {
          constructor(t, { pixelRatio: n, version: s, stretchX: l, stretchY: d, content: p, textFitWidth: m, textFitHeight: g }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = l, this.stretchY = d, this.content = p, this.version = s, this.textFitWidth = m, this.textFitHeight = g;
          }
          get tl() {
            return [this.paddedRect.x + Ei, this.paddedRect.y + Ei];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Ei, this.paddedRect.y + this.paddedRect.h - Ei];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Ei) / this.pixelRatio, (this.paddedRect.h - 2 * Ei) / this.pixelRatio];
          }
        }
        class Pu {
          constructor(t, n) {
            const s = {}, l = {};
            this.haveRenderCallbacks = [];
            const d = [];
            this.addImages(t, s, d), this.addImages(n, l, d);
            const { w: p, h: m } = Tu(d), g = new Qi({ width: p || 1, height: m || 1 });
            for (const x in t) {
              const b = t[x], w = s[x].paddedRect;
              Qi.copy(b.data, g, { x: 0, y: 0 }, { x: w.x + Ei, y: w.y + Ei }, b.data);
            }
            for (const x in n) {
              const b = n[x], w = l[x].paddedRect, I = w.x + Ei, E = w.y + Ei, A = b.data.width, D = b.data.height;
              Qi.copy(b.data, g, { x: 0, y: 0 }, { x: I, y: E }, b.data), Qi.copy(b.data, g, { x: 0, y: D - 1 }, { x: I, y: E - 1 }, { width: A, height: 1 }), Qi.copy(b.data, g, { x: 0, y: 0 }, { x: I, y: E + D }, { width: A, height: 1 }), Qi.copy(b.data, g, { x: A - 1, y: 0 }, { x: I - 1, y: E }, { width: 1, height: D }), Qi.copy(b.data, g, { x: 0, y: 0 }, { x: I + A, y: E }, { width: 1, height: D });
            }
            this.image = g, this.iconPositions = s, this.patternPositions = l;
          }
          addImages(t, n, s) {
            for (const l in t) {
              const d = t[l], p = { x: 0, y: 0, w: d.data.width + 2 * Ei, h: d.data.height + 2 * Ei };
              s.push(p), n[l] = new gh(p, d), d.hasRenderCallback && this.haveRenderCallbacks.push(l);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const s in t.updatedImages) this.patchUpdatedImage(this.iconPositions[s], t.getImage(s), n), this.patchUpdatedImage(this.patternPositions[s], t.getImage(s), n);
          }
          patchUpdatedImage(t, n, s) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [l, d] = t.tl;
            s.update(n.data, void 0, { x: l, y: d });
          }
        }
        var Qn;
        Ae("ImagePosition", gh), Ae("ImageAtlas", Pu), z.ag = void 0, (Qn = z.ag || (z.ag = {}))[Qn.none = 0] = "none", Qn[Qn.horizontal = 1] = "horizontal", Qn[Qn.vertical = 2] = "vertical", Qn[Qn.horizontalOnly = 3] = "horizontalOnly";
        const pc = -17;
        class sl {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, s) {
            const l = new sl();
            return l.scale = t || 1, l.fontStack = n, l.verticalAlign = s || "bottom", l;
          }
          static forImage(t, n) {
            const s = new sl();
            return s.imageName = t, s.verticalAlign = n || "bottom", s;
          }
        }
        class Ra {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const s = new Ra();
            for (let l = 0; l < t.sections.length; l++) {
              const d = t.sections[l];
              d.image ? s.addImageSection(d) : s.addTextSection(d, n);
            }
            return s;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = function(t) {
              let n = "";
              for (let s = 0; s < t.length; s++) {
                const l = t.charCodeAt(s + 1) || null, d = t.charCodeAt(s - 1) || null;
                n += l && Bo(l) && !nl[t[s + 1]] || d && Bo(d) && !nl[t[s - 1]] || !nl[t[s]] ? t[s] : nl[t[s]];
              }
              return n;
            }(this.text);
          }
          trim() {
            let t = 0;
            for (let s = 0; s < this.text.length && mc[this.text.charCodeAt(s)]; s++) t++;
            let n = this.text.length;
            for (let s = this.text.length - 1; s >= 0 && s >= t && mc[this.text.charCodeAt(s)]; s--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const s = new Ra();
            return s.text = this.text.substring(t, n), s.sectionIndex = this.sectionIndex.slice(t, n), s.sections = this.sections, s;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t, n) => Math.max(t, this.sections[n].scale), 0);
          }
          getMaxImageSize(t) {
            let n = 0, s = 0;
            for (let l = 0; l < this.length(); l++) {
              const d = this.getSection(l);
              if (d.imageName) {
                const p = t[d.imageName];
                if (!p) continue;
                const m = p.displaySize;
                n = Math.max(n, m[0]), s = Math.max(s, m[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: s };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(sl.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const s = this.sections.length - 1;
            for (let l = 0; l < t.text.length; ++l) this.sectionIndex.push(s);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void ci("Can't add FormattedSection with an empty image.");
            const s = this.getNextImageSectionCharCode();
            s ? (this.text += String.fromCharCode(s), this.sections.push(sl.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : ci("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function fc(r, t, n, s, l, d, p, m, g, x, b, w, I, E, A) {
          const D = Ra.fromFeature(r, l);
          let F;
          w === z.ag.vertical && D.verticalizePunctuation();
          const { processBidirectionalText: Z, processStyledBidirectionalText: Y } = Zr;
          if (Z && D.sections.length === 1) {
            F = [];
            const B = Z(D.toString(), yh(D, x, d, t, s, E));
            for (const q of B) {
              const ae = new Ra();
              ae.text = q, ae.sections = D.sections;
              for (let ve = 0; ve < q.length; ve++) ae.sectionIndex.push(0);
              F.push(ae);
            }
          } else if (Y) {
            F = [];
            const B = Y(D.text, D.sectionIndex, yh(D, x, d, t, s, E));
            for (const q of B) {
              const ae = new Ra();
              ae.text = q[0], ae.sectionIndex = q[1], ae.sections = D.sections, F.push(ae);
            }
          } else F = function(B, q) {
            const ae = [], ve = B.text;
            let ce = 0;
            for (const de of q) ae.push(B.substring(ce, de)), ce = de;
            return ce < ve.length && ae.push(B.substring(ce, ve.length)), ae;
          }(D, yh(D, x, d, t, s, E));
          const $ = [], C = { positionedLines: $, text: D.toString(), top: b[1], bottom: b[1], left: b[0], right: b[0], writingMode: w, iconsInText: !1, verticalizable: !1 };
          return function(B, q, ae, ve, ce, de, Te, we, Pe, ge, ze, Ze) {
            let Ve = 0, Le = 0, Qe = 0, At = 0;
            const qt = we === "right" ? 1 : we === "left" ? 0 : 0.5, pi = $t / Ze;
            let tr = 0;
            for (const St of ce) {
              St.trim();
              const Yt = St.getMaxScale(), ai = { positionedGlyphs: [], lineOffset: 0 };
              B.positionedLines[tr] = ai;
              const oi = ai.positionedGlyphs;
              let Ti = 0;
              if (!St.length()) {
                Le += de, ++tr;
                continue;
              }
              const ir = Tp(ve, St, pi);
              for (let zi = 0; zi < St.length(); zi++) {
                const Wt = St.getSection(zi), ei = St.getSectionIndex(zi), ti = St.getCharCode(zi), jt = Pp(Pe, ze, ti);
                let vt;
                if (Wt.imageName) {
                  if (B.iconsInText = !0, Wt.scale = Wt.scale * pi, vt = Mp(Wt, jt, Yt, ir, ve), !vt) continue;
                  Ti = Math.max(Ti, vt.imageOffset);
                } else if (vt = Sp(Wt, ti, jt, ir, q, ae), !vt) continue;
                const { rect: wr, metrics: Oa, baselineOffset: Tr } = vt;
                oi.push({ glyph: ti, imageName: Wt.imageName, x: Ve, y: Le + Tr + pc, vertical: jt, scale: Wt.scale, fontStack: Wt.fontStack, sectionIndex: ei, metrics: Oa, rect: wr }), jt ? (B.verticalizable = !0, Ve += (Wt.imageName ? Oa.advance : $t) * Wt.scale + ge) : Ve += Oa.advance * Wt.scale + ge;
              }
              oi.length !== 0 && (Qe = Math.max(Ve - ge, Qe), Ip(oi, 0, oi.length - 1, qt)), Ve = 0, ai.lineOffset = Math.max(Ti, (Yt - 1) * $t);
              const Qt = de * Yt + Ti;
              Le += Qt, At = Math.max(Qt, At), ++tr;
            }
            const { horizontalAlign: Ai, verticalAlign: si } = xh(Te);
            (function(St, Yt, ai, oi, Ti, ir, Qt, zi, Wt) {
              const ei = (Yt - ai) * Ti;
              let ti = 0;
              ti = ir !== Qt ? -zi * oi - pc : -oi * Wt * Qt + 0.5 * Qt;
              for (const jt of St) for (const vt of jt.positionedGlyphs) vt.x += ei, vt.y += ti;
            })(B.positionedLines, qt, Ai, si, Qe, At, de, Le, ce.length), B.top += -si * Le, B.bottom = B.top + Le, B.left += -Ai * Qe, B.right = B.left + Qe;
          }(C, t, n, s, F, p, m, g, w, x, I, A), !function(B) {
            for (const q of B) if (q.positionedGlyphs.length !== 0) return !1;
            return !0;
          }($) && C;
        }
        const mc = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, vp = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, bp = { 40: !0 };
        function Su(r, t, n, s, l, d) {
          if (t.imageName) {
            const p = s[t.imageName];
            return p ? p.displaySize[0] * t.scale * $t / d + l : 0;
          }
          {
            const p = n[t.fontStack], m = p && p[r];
            return m ? m.metrics.advance * t.scale + l : 0;
          }
        }
        function Mu(r, t, n, s) {
          const l = Math.pow(r - t, 2);
          return s ? r < t ? l / 2 : 2 * l : l + Math.abs(n) * n;
        }
        function wp(r, t, n) {
          let s = 0;
          return r === 10 && (s -= 1e4), n && (s += 150), r !== 40 && r !== 65288 || (s += 50), t !== 41 && t !== 65289 || (s += 50), s;
        }
        function Iu(r, t, n, s, l, d) {
          let p = null, m = Mu(t, n, l, d);
          for (const g of s) {
            const x = Mu(t - g.x, n, l, d) + g.badness;
            x <= m && (p = g, m = x);
          }
          return { index: r, x: t, priorBreak: p, badness: m };
        }
        function Cu(r) {
          return r ? Cu(r.priorBreak).concat(r.index) : [];
        }
        function yh(r, t, n, s, l, d) {
          if (!r) return [];
          const p = [], m = function(w, I, E, A, D, F) {
            let Z = 0;
            for (let Y = 0; Y < w.length(); Y++) {
              const $ = w.getSection(Y);
              Z += Su(w.getCharCode(Y), $, A, D, I, F);
            }
            return Z / Math.max(1, Math.ceil(Z / E));
          }(r, t, n, s, l, d), g = r.text.indexOf("") >= 0;
          let x = 0;
          for (let w = 0; w < r.length(); w++) {
            const I = r.getSection(w), E = r.getCharCode(w);
            if (mc[E] || (x += Su(E, I, s, l, t, d)), w < r.length() - 1) {
              const A = !((b = E) < 11904) && (!!Ye["CJK Compatibility Forms"](b) || !!Ye["CJK Compatibility"](b) || !!Ye["CJK Strokes"](b) || !!Ye["CJK Symbols and Punctuation"](b) || !!Ye["Enclosed CJK Letters and Months"](b) || !!Ye["Halfwidth and Fullwidth Forms"](b) || !!Ye["Ideographic Description Characters"](b) || !!Ye["Vertical Forms"](b) || Ro.test(String.fromCodePoint(b)));
              (vp[E] || A || I.imageName || w !== r.length() - 2 && bp[r.getCharCode(w + 1)]) && p.push(Iu(w + 1, x, m, p, wp(E, r.getCharCode(w + 1), A && g), !1));
            }
          }
          var b;
          return Cu(Iu(r.length(), x, m, p, 0, !0));
        }
        function xh(r) {
          let t = 0.5, n = 0.5;
          switch (r) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (r) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function Tp(r, t, n) {
          const s = t.getMaxScale() * $t, { maxImageWidth: l, maxImageHeight: d } = t.getMaxImageSize(r), p = Math.max(s, d * n);
          return { verticalLineContentWidth: Math.max(s, l * n), horizontalLineContentHeight: p };
        }
        function Eu(r) {
          switch (r) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function Pp(r, t, n) {
          return !(r === z.ag.horizontal || !t && !Lo(n) || t && (mc[n] || (s = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(s)))));
          var s;
        }
        function Sp(r, t, n, s, l, d) {
          const p = d[r.fontStack], m = function(x, b, w, I) {
            if (x && x.rect) return x;
            const E = b[w.fontStack], A = E && E[I];
            return A ? { rect: null, metrics: A.metrics } : null;
          }(p && p[t], l, r, t);
          if (m === null) return null;
          let g;
          if (n) g = s.verticalLineContentWidth - r.scale * $t;
          else {
            const x = Eu(r.verticalAlign);
            g = (s.horizontalLineContentHeight - r.scale * $t) * x;
          }
          return { rect: m.rect, metrics: m.metrics, baselineOffset: g };
        }
        function Mp(r, t, n, s, l) {
          const d = l[r.imageName];
          if (!d) return null;
          const p = d.paddedRect, m = d.displaySize, g = { width: m[0], height: m[1], left: Ei, top: -3, advance: t ? m[1] : m[0] };
          let x;
          if (t) x = s.verticalLineContentWidth - m[1] * r.scale;
          else {
            const b = Eu(r.verticalAlign);
            x = (s.horizontalLineContentHeight - m[1] * r.scale) * b;
          }
          return { rect: p, metrics: g, baselineOffset: x, imageOffset: (t ? m[0] : m[1]) * r.scale - $t * n };
        }
        function Ip(r, t, n, s) {
          if (s === 0) return;
          const l = r[n], d = (r[n].x + l.metrics.advance * l.scale) * s;
          for (let p = t; p <= n; p++) r[p].x -= d;
        }
        function Cp(r, t, n) {
          const { horizontalAlign: s, verticalAlign: l } = xh(n), d = t[0] - r.displaySize[0] * s, p = t[1] - r.displaySize[1] * l;
          return { image: r, top: p, bottom: p + r.displaySize[1], left: d, right: d + r.displaySize[0] };
        }
        function Au(r) {
          var t, n;
          let s = r.left, l = r.top, d = r.right - s, p = r.bottom - l;
          const m = (t = r.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", g = (n = r.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", x = (r.image.content[2] - r.image.content[0]) / (r.image.content[3] - r.image.content[1]);
          if (g === "proportional") {
            if (m === "stretchOnly" && d / p < x || m === "proportional") {
              const b = Math.ceil(p * x);
              s *= b / d, d = b;
            }
          } else if (m === "proportional" && g === "stretchOnly" && x !== 0 && d / p > x) {
            const b = Math.ceil(d / x);
            l *= b / p, p = b;
          }
          return { x1: s, y1: l, x2: s + d, y2: l + p };
        }
        function zu(r, t, n, s, l, d) {
          const p = r.image;
          let m;
          if (p.content) {
            const F = p.content, Z = p.pixelRatio || 1;
            m = [F[0] / Z, F[1] / Z, p.displaySize[0] - F[2] / Z, p.displaySize[1] - F[3] / Z];
          }
          const g = t.left * d, x = t.right * d;
          let b, w, I, E;
          n === "width" || n === "both" ? (E = l[0] + g - s[3], w = l[0] + x + s[1]) : (E = l[0] + (g + x - p.displaySize[0]) / 2, w = E + p.displaySize[0]);
          const A = t.top * d, D = t.bottom * d;
          return n === "height" || n === "both" ? (b = l[1] + A - s[0], I = l[1] + D + s[2]) : (b = l[1] + (A + D - p.displaySize[1]) / 2, I = b + p.displaySize[1]), { image: p, top: b, right: w, bottom: I, left: E, collisionPadding: m };
        }
        const al = 255, Gr = 128, es = al * Gr;
        function ku(r, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Tt(r + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: s, interpolationType: l } = n;
            let d = 0;
            for (; d < s.length && s[d] <= r; ) d++;
            d = Math.max(0, d - 1);
            let p = d;
            for (; p < s.length && s[p] < r + 1; ) p++;
            p = Math.min(s.length - 1, p);
            const m = s[d], g = s[p];
            return n.kind === "composite" ? { kind: "composite", minZoom: m, maxZoom: g, interpolationType: l } : { kind: "camera", minZoom: m, maxZoom: g, minSize: n.evaluate(new Tt(m)), maxSize: n.evaluate(new Tt(g)), interpolationType: l };
          }
        }
        function vh(r, t, n) {
          let s = "never";
          const l = r.get(t);
          return l ? s = l : r.get(n) && (s = "always"), s;
        }
        const Ep = tl.VectorTileFeature.types, Ap = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function _c(r, t, n, s, l, d, p, m, g, x, b, w, I) {
          const E = m ? Math.min(es, Math.round(m[0])) : 0, A = m ? Math.min(es, Math.round(m[1])) : 0;
          r.emplaceBack(t, n, Math.round(32 * s), Math.round(32 * l), d, p, (E << 1) + (g ? 1 : 0), A, 16 * x, 16 * b, 256 * w, 256 * I);
        }
        function bh(r, t, n) {
          r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n);
        }
        function zp(r) {
          for (const t of r.sections) if (Ql(t.text)) return !0;
          return !1;
        }
        class wh {
          constructor(t) {
            this.layoutVertexArray = new se(), this.indexArray = new Ie(), this.programConfigurations = t, this.segments = new Oe(), this.dynamicLayoutVertexArray = new oe(), this.opacityVertexArray = new fe(), this.hasVisibleVertices = !1, this.placedSymbolArray = new y();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, s, l) {
            this.isEmpty() || (s && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, hp.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, up.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Ap, !0), this.opacityVertexBuffer.itemSize = 1), (s || l) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Ae("SymbolBuffers", wh);
        class Th {
          constructor(t, n, s) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new s(), this.segments = new Oe(), this.collisionVertexArray = new pe();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, dp.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Ae("CollisionBuffers", Th);
        class La {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((p) => p.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = ku(this.zoom, n["text-size"]), this.iconSizeData = ku(this.zoom, n["icon-size"]);
            const s = this.layers[0].layout, l = s.get("symbol-sort-key"), d = s.get("symbol-z-order");
            this.canOverlap = vh(s, "text-overlap", "text-allow-overlap") !== "never" || vh(s, "icon-overlap", "icon-allow-overlap") !== "never" || s.get("text-ignore-placement") || s.get("icon-ignore-placement"), this.sortFeaturesByKey = d !== "viewport-y" && !l.isConstant(), this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap, s.get("symbol-placement") === "point" && (this.writingModes = s.get("text-writing-mode").map((p) => z.ag[p])), this.stateDependentLayerIds = this.layers.filter((p) => p.isStateDependent()).map((p) => p.id), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new wh(new Sn(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new wh(new Sn(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new S(), this.lineVertexArray = new M(), this.symbolInstances = new T(), this.textAnchorOffsets = new R();
          }
          calculateGlyphDependencies(t, n, s, l, d) {
            for (let p = 0; p < t.length; p++) if (n[t.charCodeAt(p)] = !0, (s || l) && d) {
              const m = nl[t.charAt(p)];
              m && (n[m.charCodeAt(0)] = !0);
            }
          }
          populate(t, n, s) {
            const l = this.layers[0], d = l.layout, p = d.get("text-font"), m = d.get("text-field"), g = d.get("icon-image"), x = (m.value.kind !== "constant" || m.value.value instanceof ri && !m.value.value.isEmpty() || m.value.value.toString().length > 0) && (p.value.kind !== "constant" || p.value.value.length > 0), b = g.value.kind !== "constant" || !!g.value.value || Object.keys(g.parameters).length > 0, w = d.get("symbol-sort-key");
            if (this.features = [], !x && !b) return;
            const I = n.iconDependencies, E = n.glyphDependencies, A = n.availableImages, D = new Tt(this.zoom);
            for (const { feature: F, id: Z, index: Y, sourceLayerIndex: $ } of t) {
              const C = l._featureFilter.needGeometry, B = Ci(F, C);
              if (!l._featureFilter.filter(D, B, s)) continue;
              let q, ae;
              if (C || (B.geometry = Mn(F)), x) {
                const ce = l.getValueAndResolveTokens("text-field", B, s, A), de = ri.factory(ce), Te = this.hasRTLText = this.hasRTLText || zp(de);
                (!Te || Zr.getRTLTextPluginStatus() === "unavailable" || Te && Zr.isParsed()) && (q = fp(de, l, B));
              }
              if (b) {
                const ce = l.getValueAndResolveTokens("icon-image", B, s, A);
                ae = ce instanceof _i ? ce : _i.fromString(ce);
              }
              if (!q && !ae) continue;
              const ve = this.sortFeaturesByKey ? w.evaluate(B, {}, s) : void 0;
              if (this.features.push({ id: Z, text: q, icon: ae, index: Y, sourceLayerIndex: $, geometry: B.geometry, properties: F.properties, type: Ep[F.type], sortKey: ve }), ae && (I[ae.name] = !0), q) {
                const ce = p.evaluate(B, {}, s).join(","), de = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(z.ag.vertical) >= 0;
                for (const Te of q.sections) if (Te.image) I[Te.image.name] = !0;
                else {
                  const we = ma(q.toString()), Pe = Te.fontStack || ce, ge = E[Pe] = E[Pe] || {};
                  this.calculateGlyphDependencies(Te.text, ge, de, this.allowVerticalPlacement, we);
                }
              }
            }
            d.get("symbol-placement") === "line" && (this.features = function(F) {
              const Z = {}, Y = {}, $ = [];
              let C = 0;
              function B(ce) {
                $.push(F[ce]), C++;
              }
              function q(ce, de, Te) {
                const we = Y[ce];
                return delete Y[ce], Y[de] = we, $[we].geometry[0].pop(), $[we].geometry[0] = $[we].geometry[0].concat(Te[0]), we;
              }
              function ae(ce, de, Te) {
                const we = Z[de];
                return delete Z[de], Z[ce] = we, $[we].geometry[0].shift(), $[we].geometry[0] = Te[0].concat($[we].geometry[0]), we;
              }
              function ve(ce, de, Te) {
                const we = Te ? de[0][de[0].length - 1] : de[0][0];
                return `${ce}:${we.x}:${we.y}`;
              }
              for (let ce = 0; ce < F.length; ce++) {
                const de = F[ce], Te = de.geometry, we = de.text ? de.text.toString() : null;
                if (!we) {
                  B(ce);
                  continue;
                }
                const Pe = ve(we, Te), ge = ve(we, Te, !0);
                if (Pe in Y && ge in Z && Y[Pe] !== Z[ge]) {
                  const ze = ae(Pe, ge, Te), Ze = q(Pe, ge, $[ze].geometry);
                  delete Z[Pe], delete Y[ge], Y[ve(we, $[Ze].geometry, !0)] = Ze, $[ze].geometry = null;
                } else Pe in Y ? q(Pe, ge, Te) : ge in Z ? ae(Pe, ge, Te) : (B(ce), Z[Pe] = C - 1, Y[ge] = C - 1);
              }
              return $.filter((ce) => ce.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((F, Z) => F.sortKey - Z.sortKey);
          }
          update(t, n, s) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, s), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, s));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const s = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let l = t.dist(n[t.segment + 1]), d = t.dist(n[t.segment]);
              const p = {};
              for (let m = t.segment + 1; m < n.length; m++) p[m] = { x: n[m].x, y: n[m].y, tileUnitDistanceFromAnchor: l }, m < n.length - 1 && (l += n[m + 1].dist(n[m]));
              for (let m = t.segment || 0; m >= 0; m--) p[m] = { x: n[m].x, y: n[m].y, tileUnitDistanceFromAnchor: d }, m > 0 && (d += n[m - 1].dist(n[m]));
              for (let m = 0; m < n.length; m++) {
                const g = p[m];
                this.lineVertexArray.emplaceBack(g.x, g.y, g.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: s, lineLength: this.lineVertexArray.length - s };
          }
          addSymbols(t, n, s, l, d, p, m, g, x, b, w, I) {
            const E = t.indexArray, A = t.layoutVertexArray, D = t.segments.prepareSegment(4 * n.length, A, E, this.canOverlap ? p.sortKey : void 0), F = this.glyphOffsetArray.length, Z = D.vertexLength, Y = this.allowVerticalPlacement && m === z.ag.vertical ? Math.PI / 2 : 0, $ = p.text && p.text.sections;
            for (let C = 0; C < n.length; C++) {
              const { tl: B, tr: q, bl: ae, br: ve, tex: ce, pixelOffsetTL: de, pixelOffsetBR: Te, minFontScaleX: we, minFontScaleY: Pe, glyphOffset: ge, isSDF: ze, sectionIndex: Ze } = n[C], Ve = D.vertexLength, Le = ge[1];
              _c(A, g.x, g.y, B.x, Le + B.y, ce.x, ce.y, s, ze, de.x, de.y, we, Pe), _c(A, g.x, g.y, q.x, Le + q.y, ce.x + ce.w, ce.y, s, ze, Te.x, de.y, we, Pe), _c(A, g.x, g.y, ae.x, Le + ae.y, ce.x, ce.y + ce.h, s, ze, de.x, Te.y, we, Pe), _c(A, g.x, g.y, ve.x, Le + ve.y, ce.x + ce.w, ce.y + ce.h, s, ze, Te.x, Te.y, we, Pe), bh(t.dynamicLayoutVertexArray, g, Y), E.emplaceBack(Ve, Ve + 2, Ve + 1), E.emplaceBack(Ve + 1, Ve + 2, Ve + 3), D.vertexLength += 4, D.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ge[0]), C !== n.length - 1 && Ze === n[C + 1].sectionIndex || t.programConfigurations.populatePaintArrays(A.length, p, p.index, {}, I, $ && $[Ze]);
            }
            t.placedSymbolArray.emplaceBack(g.x, g.y, F, this.glyphOffsetArray.length - F, Z, x, b, g.segment, s ? s[0] : 0, s ? s[1] : 0, l[0], l[1], m, 0, !1, 0, w);
          }
          _addCollisionDebugVertex(t, n, s, l, d, p) {
            return n.emplaceBack(0, 0), t.emplaceBack(s.x, s.y, l, d, Math.round(p.x), Math.round(p.y));
          }
          addCollisionDebugVertices(t, n, s, l, d, p, m) {
            const g = d.segments.prepareSegment(4, d.layoutVertexArray, d.indexArray), x = g.vertexLength, b = d.layoutVertexArray, w = d.collisionVertexArray, I = m.anchorX, E = m.anchorY;
            this._addCollisionDebugVertex(b, w, p, I, E, new Ue(t, n)), this._addCollisionDebugVertex(b, w, p, I, E, new Ue(s, n)), this._addCollisionDebugVertex(b, w, p, I, E, new Ue(s, l)), this._addCollisionDebugVertex(b, w, p, I, E, new Ue(t, l)), g.vertexLength += 4;
            const A = d.indexArray;
            A.emplaceBack(x, x + 1), A.emplaceBack(x + 1, x + 2), A.emplaceBack(x + 2, x + 3), A.emplaceBack(x + 3, x), g.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, s, l) {
            for (let d = t; d < n; d++) {
              const p = this.collisionBoxArray.get(d);
              this.addCollisionDebugVertices(p.x1, p.y1, p.x2, p.y2, l ? this.textCollisionBox : this.iconCollisionBox, p.anchorPoint, s);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Th(_e, xu.members, Se), this.iconCollisionBox = new Th(_e, xu.members, Se);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, s, l, d, p, m, g, x) {
            const b = {};
            for (let w = n; w < s; w++) {
              const I = t.get(w);
              b.textBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.textFeatureIndex = I.featureIndex;
              break;
            }
            for (let w = l; w < d; w++) {
              const I = t.get(w);
              b.verticalTextBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.verticalTextFeatureIndex = I.featureIndex;
              break;
            }
            for (let w = p; w < m; w++) {
              const I = t.get(w);
              b.iconBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.iconFeatureIndex = I.featureIndex;
              break;
            }
            for (let w = g; w < x; w++) {
              const I = t.get(w);
              b.verticalIconBox = { x1: I.x1, y1: I.y1, x2: I.x2, y2: I.y2, anchorPointX: I.anchorPointX, anchorPointY: I.anchorPointY }, b.verticalIconFeatureIndex = I.featureIndex;
              break;
            }
            return b;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const s = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, s.textBoxStartIndex, s.textBoxEndIndex, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const s = t.placedSymbolArray.get(n), l = s.vertexStartIndex + 4 * s.numGlyphs;
            for (let d = s.vertexStartIndex; d < l; d += 4) t.indexArray.emplaceBack(d, d + 2, d + 1), t.indexArray.emplaceBack(d + 1, d + 2, d + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), s = Math.cos(t), l = [], d = [], p = [];
            for (let m = 0; m < this.symbolInstances.length; ++m) {
              p.push(m);
              const g = this.symbolInstances.get(m);
              l.push(0 | Math.round(n * g.anchorX + s * g.anchorY)), d.push(g.featureIndex);
            }
            return p.sort((m, g) => l[m] - l[g] || d[g] - d[m]), p;
          }
          addToSortKeyRanges(t, n) {
            const s = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            s && s.sortKey === n ? s.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const s = this.symbolInstances.get(n);
                this.featureSortOrder.push(s.featureIndex), [s.rightJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.leftJustifiedTextSymbolIndex].forEach((l, d, p) => {
                  l >= 0 && p.indexOf(l) === d && this.addIndicesForPlacedSymbol(this.text, l);
                }), s.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, s.verticalPlacedTextSymbolIndex), s.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.placedIconSymbolIndex), s.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Du, Ru;
        Ae("SymbolBucket", La, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), La.MAX_GLYPHS = 65535, La.addDynamicAttributes = bh;
        var Ph = { get paint() {
          return Ru = Ru || new wi({ "icon-opacity": new Ge(P.paint_symbol["icon-opacity"]), "icon-color": new Ge(P.paint_symbol["icon-color"]), "icon-halo-color": new Ge(P.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ge(P.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ge(P.paint_symbol["icon-halo-blur"]), "icon-translate": new Fe(P.paint_symbol["icon-translate"]), "icon-translate-anchor": new Fe(P.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ge(P.paint_symbol["text-opacity"]), "text-color": new Ge(P.paint_symbol["text-color"], { runtimeType: Ke, getOverride: (r) => r.textColor, hasOverride: (r) => !!r.textColor }), "text-halo-color": new Ge(P.paint_symbol["text-halo-color"]), "text-halo-width": new Ge(P.paint_symbol["text-halo-width"]), "text-halo-blur": new Ge(P.paint_symbol["text-halo-blur"]), "text-translate": new Fe(P.paint_symbol["text-translate"]), "text-translate-anchor": new Fe(P.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Du = Du || new wi({ "symbol-placement": new Fe(P.layout_symbol["symbol-placement"]), "symbol-spacing": new Fe(P.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Fe(P.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ge(P.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Fe(P.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Fe(P.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Fe(P.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Fe(P.layout_symbol["icon-ignore-placement"]), "icon-optional": new Fe(P.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Fe(P.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ge(P.layout_symbol["icon-size"]), "icon-text-fit": new Fe(P.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Fe(P.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ge(P.layout_symbol["icon-image"]), "icon-rotate": new Ge(P.layout_symbol["icon-rotate"]), "icon-padding": new Ge(P.layout_symbol["icon-padding"]), "icon-keep-upright": new Fe(P.layout_symbol["icon-keep-upright"]), "icon-offset": new Ge(P.layout_symbol["icon-offset"]), "icon-anchor": new Ge(P.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Fe(P.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Fe(P.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Fe(P.layout_symbol["text-rotation-alignment"]), "text-field": new Ge(P.layout_symbol["text-field"]), "text-font": new Ge(P.layout_symbol["text-font"]), "text-size": new Ge(P.layout_symbol["text-size"]), "text-max-width": new Ge(P.layout_symbol["text-max-width"]), "text-line-height": new Fe(P.layout_symbol["text-line-height"]), "text-letter-spacing": new Ge(P.layout_symbol["text-letter-spacing"]), "text-justify": new Ge(P.layout_symbol["text-justify"]), "text-radial-offset": new Ge(P.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Fe(P.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ge(P.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ge(P.layout_symbol["text-anchor"]), "text-max-angle": new Fe(P.layout_symbol["text-max-angle"]), "text-writing-mode": new Fe(P.layout_symbol["text-writing-mode"]), "text-rotate": new Ge(P.layout_symbol["text-rotate"]), "text-padding": new Fe(P.layout_symbol["text-padding"]), "text-keep-upright": new Fe(P.layout_symbol["text-keep-upright"]), "text-transform": new Ge(P.layout_symbol["text-transform"]), "text-offset": new Ge(P.layout_symbol["text-offset"]), "text-allow-overlap": new Fe(P.layout_symbol["text-allow-overlap"]), "text-overlap": new Fe(P.layout_symbol["text-overlap"]), "text-ignore-placement": new Fe(P.layout_symbol["text-ignore-placement"]), "text-optional": new Fe(P.layout_symbol["text-optional"]) });
        } };
        class Lu {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : $e, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        Ae("FormatSectionOverride", Lu, { omit: ["defaultValue"] });
        class gc extends cr {
          constructor(t) {
            super(t, Ph);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const s = this.layout.get("text-writing-mode");
              if (s) {
                const l = [];
                for (const d of s) l.indexOf(d) < 0 && l.push(d);
                this.layout._values["text-writing-mode"] = l;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, s, l) {
            const d = this.layout.get(t).evaluate(n, {}, s, l), p = this._unevaluatedLayout._values[t];
            return p.isDataDriven() || oa(p.value) || !d ? d : function(m, g) {
              return g.replace(/{([^{}]+)}/g, (x, b) => m && b in m ? String(m[b]) : "");
            }(n.properties, d);
          }
          createBucket(t) {
            return new La(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of Ph.paint.overridableProperties) {
              if (!gc.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), s = new Lu(n), l = new xo(s, n.property.specification);
              let d = null;
              d = n.value.kind === "constant" || n.value.kind === "source" ? new la("source", l) : new vo("composite", l, n.value.zoomStops), this.paint._values[t] = new Zi(n.property, d, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, s) {
            return !(!this.layout || n.isDataDriven() || s.isDataDriven()) && gc.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const s = t.get("text-field"), l = Ph.paint.properties[n];
            let d = !1;
            const p = (m) => {
              for (const g of m) if (l.overrides && l.overrides.hasOverride(g)) return void (d = !0);
            };
            if (s.value.kind === "constant" && s.value.value instanceof ri) p(s.value.value.sections);
            else if (s.value.kind === "source") {
              const m = (x) => {
                d || (x instanceof Fi && Ot(x.value) === Ft ? p(x.value.sections) : x instanceof hn ? p(x.sections) : x.eachChild(m));
              }, g = s.value;
              g._styleExpression && m(g._styleExpression.expression);
            }
            return d;
          }
        }
        let Bu;
        var kp = { get paint() {
          return Bu = Bu || new wi({ "background-color": new Fe(P.paint_background["background-color"]), "background-pattern": new xa(P.paint_background["background-pattern"]), "background-opacity": new Fe(P.paint_background["background-opacity"]) });
        } };
        class Dp extends cr {
          constructor(t) {
            super(t, kp);
          }
        }
        let Fu;
        var Rp = { get paint() {
          return Fu = Fu || new wi({ "raster-opacity": new Fe(P.paint_raster["raster-opacity"]), "raster-hue-rotate": new Fe(P.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Fe(P.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Fe(P.paint_raster["raster-brightness-max"]), "raster-saturation": new Fe(P.paint_raster["raster-saturation"]), "raster-contrast": new Fe(P.paint_raster["raster-contrast"]), "raster-resampling": new Fe(P.paint_raster["raster-resampling"]), "raster-fade-duration": new Fe(P.paint_raster["raster-fade-duration"]) });
        } };
        class Lp extends cr {
          constructor(t) {
            super(t, Rp);
          }
        }
        class Bp extends cr {
          constructor(t) {
            super(t, {}), this.onAdd = (n) => {
              this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
            }, this.onRemove = (n) => {
              this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Fp {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Op = { once: !0 }, Sh = 63710088e-1;
        class ts {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ts(Ri(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, s = this.lat * n, l = t.lat * n, d = Math.sin(s) * Math.sin(l) + Math.cos(s) * Math.cos(l) * Math.cos((t.lng - this.lng) * n);
            return Sh * Math.acos(Math.min(d, 1));
          }
          static convert(t) {
            if (t instanceof ts) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new ts(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new ts(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Ou = 2 * Math.PI * Sh;
        function ju(r) {
          return Ou * Math.cos(r * Math.PI / 180);
        }
        function Vu(r) {
          return (180 + r) / 360;
        }
        function Nu(r) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
        }
        function Zu(r, t) {
          return r / ju(t);
        }
        function Mh(r) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
        }
        function Uu(r, t) {
          return r * ju(Mh(t));
        }
        class ol {
          constructor(t, n, s = 0) {
            this.x = +t, this.y = +n, this.z = +s;
          }
          static fromLngLat(t, n = 0) {
            const s = ts.convert(t);
            return new ol(Vu(s.lng), Nu(s.lat), Zu(n, s.lat));
          }
          toLngLat() {
            return new ts(360 * this.x - 180, Mh(this.y));
          }
          toAltitude() {
            return Uu(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Ou * (t = Mh(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function Gu(r, t, n) {
          var s = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [r * s - 2 * Math.PI * 6378137 / 2, t * s - 2 * Math.PI * 6378137 / 2];
        }
        class Ih {
          constructor(t, n, s) {
            if (!function(l, d, p) {
              return !(l < 0 || l > 25 || p < 0 || p >= Math.pow(2, l) || d < 0 || d >= Math.pow(2, l));
            }(t, n, s)) throw new Error(`x=${n}, y=${s}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = s, this.key = Ba(0, t, t, n, s);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, s) {
            const l = (p = this.y, m = this.z, g = Gu(256 * (d = this.x), 256 * (p = Math.pow(2, m) - p - 1), m), x = Gu(256 * (d + 1), 256 * (p + 1), m), g[0] + "," + g[1] + "," + x[0] + "," + x[1]);
            var d, p, m, g, x;
            const b = function(w, I, E) {
              let A, D = "";
              for (let F = w; F > 0; F--) A = 1 << F - 1, D += (I & A ? 1 : 0) + (E & A ? 2 : 0);
              return D;
            }(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(s === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, b).replace(/{bbox-epsg-3857}/g, l);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new Ue((t.x * n - this.x) * ht, (t.y * n - this.y) * ht);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class $u {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Ba(t, n.z, n.z, n.x, n.y);
          }
        }
        class er {
          constructor(t, n, s, l, d) {
            if (this.terrainRttPosMatrix32f = null, t < s) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${s}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new Ih(s, +l, +d), this.key = Ba(n, t, s, l, d);
          }
          clone() {
            return new er(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new er(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new er(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const s = this.canonical.z - t;
            return t > this.canonical.z ? Ba(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Ba(this.wrap * +n, t, t, this.canonical.x >> s, this.canonical.y >> s);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap) return !1;
            const n = this.canonical.z - t.canonical.z;
            return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new er(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, s = 2 * this.canonical.x, l = 2 * this.canonical.y;
            return [new er(n, this.wrap, n, s, l), new er(n, this.wrap, n, s + 1, l), new er(n, this.wrap, n, s, l + 1), new er(n, this.wrap, n, s + 1, l + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new er(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new er(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new $u(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new ol(t.x - this.wrap, t.y));
          }
        }
        function Ba(r, t, n, s, l) {
          (r *= 2) < 0 && (r = -1 * r - 1);
          const d = 1 << n;
          return (d * d * r + d * l + s).toString(36) + n.toString(36) + t.toString(36);
        }
        Ae("CanonicalTileID", Ih), Ae("OverscaledTileID", er, { omit: ["terrainRttPosMatrix32f"] });
        class qu {
          constructor(t, n, s, l = 1, d = 1, p = 1, m = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (s && !["mapbox", "terrarium", "custom"].includes(s)) return void ci(`"${s}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const g = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), s) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = l, this.greenFactor = d, this.blueFactor = p, this.baseShift = m;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let x = 0; x < g; x++) this.data[this._idx(-1, x)] = this.data[this._idx(0, x)], this.data[this._idx(g, x)] = this.data[this._idx(g - 1, x)], this.data[this._idx(x, -1)] = this.data[this._idx(x, 0)], this.data[this._idx(x, g)] = this.data[this._idx(x, g - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(g, -1)] = this.data[this._idx(g - 1, 0)], this.data[this._idx(-1, g)] = this.data[this._idx(0, g - 1)], this.data[this._idx(g, g)] = this.data[this._idx(g - 1, g - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let x = 0; x < g; x++) for (let b = 0; b < g; b++) {
              const w = this.get(x, b);
              w > this.max && (this.max = w), w < this.min && (this.min = w);
            }
          }
          get(t, n) {
            const s = new Uint8Array(this.data.buffer), l = 4 * this._idx(t, n);
            return this.unpack(s[l], s[l + 1], s[l + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, s) {
            return t * this.redFactor + n * this.greenFactor + s * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Qi({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, s) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let l = n * this.dim, d = n * this.dim + this.dim, p = s * this.dim, m = s * this.dim + this.dim;
            switch (n) {
              case -1:
                l = d - 1;
                break;
              case 1:
                d = l + 1;
            }
            switch (s) {
              case -1:
                p = m - 1;
                break;
              case 1:
                m = p + 1;
            }
            const g = -n * this.dim, x = -s * this.dim;
            for (let b = p; b < m; b++) for (let w = l; w < d; w++) this.data[this._idx(w, b)] = t.data[this._idx(w + g, b + x)];
          }
        }
        Ae("DEMData", qu);
        class Wu {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const s = t[n];
              this._stringToNumber[s] = n, this._numberToString[n] = s;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class Hu {
          constructor(t, n, s, l, d) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = s, t._y = l, this.properties = t.properties, this.id = d;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class Xu {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ps(ht, 16, 0), this.grid3D = new Ps(ht, 16, 0), this.featureIndexArray = new j(), this.promoteId = n;
          }
          insert(t, n, s, l, d, p) {
            const m = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(s, l, d);
            const g = p ? this.grid3D : this.grid;
            for (let x = 0; x < n.length; x++) {
              const b = n[x], w = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let I = 0; I < b.length; I++) {
                const E = b[I];
                w[0] = Math.min(w[0], E.x), w[1] = Math.min(w[1], E.y), w[2] = Math.max(w[2], E.x), w[3] = Math.max(w[3], E.y);
              }
              w[0] < ht && w[1] < ht && w[2] >= 0 && w[3] >= 0 && g.insert(m, w[0], w[1], w[2], w[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new tl.VectorTile(new mh(this.rawTileData)).layers, this.sourceLayerCoder = new Wu(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, s, l) {
            this.loadVTLayers();
            const d = t.params, p = ht / t.tileSize / t.scale, m = ua(d.filter), g = t.queryGeometry, x = t.queryPadding * p, b = Ju(g), w = this.grid.query(b.minX - x, b.minY - x, b.maxX + x, b.maxY + x), I = Ju(t.cameraQueryGeometry), E = this.grid3D.query(I.minX - x, I.minY - x, I.maxX + x, I.maxY + x, (F, Z, Y, $) => function(C, B, q, ae, ve) {
              for (const de of C) if (B <= de.x && q <= de.y && ae >= de.x && ve >= de.y) return !0;
              const ce = [new Ue(B, q), new Ue(B, ve), new Ue(ae, ve), new Ue(ae, q)];
              if (C.length > 2) {
                for (const de of ce) if (Aa(C, de)) return !0;
              }
              for (let de = 0; de < C.length - 1; de++) if (Md(C[de], C[de + 1], ce)) return !0;
              return !1;
            }(t.cameraQueryGeometry, F - x, Z - x, Y + x, $ + x));
            for (const F of E) w.push(F);
            w.sort(jp);
            const A = {};
            let D;
            for (let F = 0; F < w.length; F++) {
              const Z = w[F];
              if (Z === D) continue;
              D = Z;
              const Y = this.featureIndexArray.get(Z);
              let $ = null;
              this.loadMatchingFeature(A, Y.bucketIndex, Y.sourceLayerIndex, Y.featureIndex, m, d.layers, d.availableImages, n, s, l, (C, B, q) => ($ || ($ = Mn(C)), B.queryIntersectsFeature({ queryGeometry: g, feature: C, featureState: q, geometry: $, zoom: this.z, transform: t.transform, pixelsToTileUnits: p, pixelPosMatrix: t.pixelPosMatrix })));
            }
            return A;
          }
          loadMatchingFeature(t, n, s, l, d, p, m, g, x, b, w) {
            const I = this.bucketLayerIDs[n];
            if (p && !I.some((F) => p.has(F))) return;
            const E = this.sourceLayerCoder.decode(s), A = this.vtLayers[E].feature(l);
            if (d.needGeometry) {
              const F = Ci(A, !0);
              if (!d.filter(new Tt(this.tileID.overscaledZ), F, this.tileID.canonical)) return;
            } else if (!d.filter(new Tt(this.tileID.overscaledZ), A)) return;
            const D = this.getId(A, E);
            for (let F = 0; F < I.length; F++) {
              const Z = I[F];
              if (p && !p.has(Z)) continue;
              const Y = g[Z];
              if (!Y) continue;
              let $ = {};
              D && b && ($ = b.getState(Y.sourceLayer || "_geojsonTileLayer", D));
              const C = ii({}, x[Z]);
              C.paint = Ku(C.paint, Y.paint, A, $, m), C.layout = Ku(C.layout, Y.layout, A, $, m);
              const B = !w || w(A, Y, $);
              if (!B) continue;
              const q = new Hu(A, this.z, this.x, this.y, D);
              q.layer = C;
              let ae = t[Z];
              ae === void 0 && (ae = t[Z] = []), ae.push({ featureIndex: l, feature: q, intersectionZ: B });
            }
          }
          lookupSymbolFeatures(t, n, s, l, d, p, m, g) {
            const x = {};
            this.loadVTLayers();
            const b = ua(d);
            for (const w of t) this.loadMatchingFeature(x, s, l, w, b, p, m, g, n);
            return x;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const s of n) if (t === s) return !0;
            return !1;
          }
          getId(t, n) {
            var s;
            let l = t.id;
            return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof l == "boolean" && (l = Number(l)), l === void 0 && (!((s = t.properties) === null || s === void 0) && s.cluster) && this.promoteId && (l = Number(t.properties.cluster_id))), l;
          }
        }
        function Ku(r, t, n, s, l) {
          return Qr(r, (d, p) => {
            const m = t instanceof ya ? t.get(p) : null;
            return m && m.evaluate ? m.evaluate(n, s, l) : m;
          });
        }
        function Ju(r) {
          let t = 1 / 0, n = 1 / 0, s = -1 / 0, l = -1 / 0;
          for (const d of r) t = Math.min(t, d.x), n = Math.min(n, d.y), s = Math.max(s, d.x), l = Math.max(l, d.y);
          return { minX: t, minY: n, maxX: s, maxY: l };
        }
        function jp(r, t) {
          return t - r;
        }
        function Yu(r, t, n, s, l) {
          const d = [];
          for (let p = 0; p < r.length; p++) {
            const m = r[p];
            let g;
            for (let x = 0; x < m.length - 1; x++) {
              let b = m[x], w = m[x + 1];
              b.x < t && w.x < t || (b.x < t ? b = new Ue(t, b.y + (t - b.x) / (w.x - b.x) * (w.y - b.y))._round() : w.x < t && (w = new Ue(t, b.y + (t - b.x) / (w.x - b.x) * (w.y - b.y))._round()), b.y < n && w.y < n || (b.y < n ? b = new Ue(b.x + (n - b.y) / (w.y - b.y) * (w.x - b.x), n)._round() : w.y < n && (w = new Ue(b.x + (n - b.y) / (w.y - b.y) * (w.x - b.x), n)._round()), b.x >= s && w.x >= s || (b.x >= s ? b = new Ue(s, b.y + (s - b.x) / (w.x - b.x) * (w.y - b.y))._round() : w.x >= s && (w = new Ue(s, b.y + (s - b.x) / (w.x - b.x) * (w.y - b.y))._round()), b.y >= l && w.y >= l || (b.y >= l ? b = new Ue(b.x + (l - b.y) / (w.y - b.y) * (w.x - b.x), l)._round() : w.y >= l && (w = new Ue(b.x + (l - b.y) / (w.y - b.y) * (w.x - b.x), l)._round()), g && b.equals(g[g.length - 1]) || (g = [b], d.push(g)), g.push(w)))));
            }
          }
          return d;
        }
        Ae("FeatureIndex", Xu, { omit: ["rawTileData", "sourceLayerCoder"] });
        class is extends Ue {
          constructor(t, n, s, l) {
            super(t, n), this.angle = s, l !== void 0 && (this.segment = l);
          }
          clone() {
            return new is(this.x, this.y, this.angle, this.segment);
          }
        }
        function Qu(r, t, n, s, l) {
          if (t.segment === void 0 || n === 0) return !0;
          let d = t, p = t.segment + 1, m = 0;
          for (; m > -n / 2; ) {
            if (p--, p < 0) return !1;
            m -= r[p].dist(d), d = r[p];
          }
          m += r[p].dist(r[p + 1]), p++;
          const g = [];
          let x = 0;
          for (; m < n / 2; ) {
            const b = r[p], w = r[p + 1];
            if (!w) return !1;
            let I = r[p - 1].angleTo(b) - b.angleTo(w);
            for (I = Math.abs((I + 3 * Math.PI) % (2 * Math.PI) - Math.PI), g.push({ distance: m, angleDelta: I }), x += I; m - g[0].distance > s; ) x -= g.shift().angleDelta;
            if (x > l) return !1;
            p++, m += b.dist(w);
          }
          return !0;
        }
        function ed(r) {
          let t = 0;
          for (let n = 0; n < r.length - 1; n++) t += r[n].dist(r[n + 1]);
          return t;
        }
        function td(r, t, n) {
          return r ? 0.6 * t * n : 0;
        }
        function id(r, t) {
          return Math.max(r ? r.right - r.left : 0, t ? t.right - t.left : 0);
        }
        function Vp(r, t, n, s, l, d) {
          const p = td(n, l, d), m = id(n, s) * d;
          let g = 0;
          const x = ed(r) / 2;
          for (let b = 0; b < r.length - 1; b++) {
            const w = r[b], I = r[b + 1], E = w.dist(I);
            if (g + E > x) {
              const A = (x - g) / E, D = Mi.number(w.x, I.x, A), F = Mi.number(w.y, I.y, A), Z = new is(D, F, I.angleTo(w), b);
              return Z._round(), !p || Qu(r, Z, m, p, t) ? Z : void 0;
            }
            g += E;
          }
        }
        function Np(r, t, n, s, l, d, p, m, g) {
          const x = td(s, d, p), b = id(s, l), w = b * p, I = r[0].x === 0 || r[0].x === g || r[0].y === 0 || r[0].y === g;
          return t - w < t / 4 && (t = w + t / 4), rd(r, I ? t / 2 * m % t : (b / 2 + 2 * d) * p * m % t, t, x, n, w, I, !1, g);
        }
        function rd(r, t, n, s, l, d, p, m, g) {
          const x = d / 2, b = ed(r);
          let w = 0, I = t - n, E = [];
          for (let A = 0; A < r.length - 1; A++) {
            const D = r[A], F = r[A + 1], Z = D.dist(F), Y = F.angleTo(D);
            for (; I + n < w + Z; ) {
              I += n;
              const $ = (I - w) / Z, C = Mi.number(D.x, F.x, $), B = Mi.number(D.y, F.y, $);
              if (C >= 0 && C < g && B >= 0 && B < g && I - x >= 0 && I + x <= b) {
                const q = new is(C, B, Y, A);
                q._round(), s && !Qu(r, q, d, s, l) || E.push(q);
              }
            }
            w += Z;
          }
          return m || E.length || p || (E = rd(r, w / 2, n, s, l, d, p, !0, g)), E;
        }
        Ae("Anchor", is);
        const ll = Ei;
        function nd(r, t, n, s) {
          const l = [], d = r.image, p = d.pixelRatio, m = d.paddedRect.w - 2 * ll, g = d.paddedRect.h - 2 * ll;
          let x = { x1: r.left, y1: r.top, x2: r.right, y2: r.bottom };
          const b = d.stretchX || [[0, m]], w = d.stretchY || [[0, g]], I = (ge, ze) => ge + ze[1] - ze[0], E = b.reduce(I, 0), A = w.reduce(I, 0), D = m - E, F = g - A;
          let Z = 0, Y = E, $ = 0, C = A, B = 0, q = D, ae = 0, ve = F;
          if (d.content && s) {
            const ge = d.content, ze = ge[2] - ge[0], Ze = ge[3] - ge[1];
            (d.textFitWidth || d.textFitHeight) && (x = Au(r)), Z = yc(b, 0, ge[0]), $ = yc(w, 0, ge[1]), Y = yc(b, ge[0], ge[2]), C = yc(w, ge[1], ge[3]), B = ge[0] - Z, ae = ge[1] - $, q = ze - Y, ve = Ze - C;
          }
          const ce = x.x1, de = x.y1, Te = x.x2 - ce, we = x.y2 - de, Pe = (ge, ze, Ze, Ve) => {
            const Le = xc(ge.stretch - Z, Y, Te, ce), Qe = vc(ge.fixed - B, q, ge.stretch, E), At = xc(ze.stretch - $, C, we, de), qt = vc(ze.fixed - ae, ve, ze.stretch, A), pi = xc(Ze.stretch - Z, Y, Te, ce), tr = vc(Ze.fixed - B, q, Ze.stretch, E), Ai = xc(Ve.stretch - $, C, we, de), si = vc(Ve.fixed - ae, ve, Ve.stretch, A), St = new Ue(Le, At), Yt = new Ue(pi, At), ai = new Ue(pi, Ai), oi = new Ue(Le, Ai), Ti = new Ue(Qe / p, qt / p), ir = new Ue(tr / p, si / p), Qt = t * Math.PI / 180;
            if (Qt) {
              const ei = Math.sin(Qt), ti = Math.cos(Qt), jt = [ti, -ei, ei, ti];
              St._matMult(jt), Yt._matMult(jt), oi._matMult(jt), ai._matMult(jt);
            }
            const zi = ge.stretch + ge.fixed, Wt = ze.stretch + ze.fixed;
            return { tl: St, tr: Yt, bl: oi, br: ai, tex: { x: d.paddedRect.x + ll + zi, y: d.paddedRect.y + ll + Wt, w: Ze.stretch + Ze.fixed - zi, h: Ve.stretch + Ve.fixed - Wt }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Ti, pixelOffsetBR: ir, minFontScaleX: q / p / Te, minFontScaleY: ve / p / we, isSDF: n };
          };
          if (s && (d.stretchX || d.stretchY)) {
            const ge = sd(b, D, E), ze = sd(w, F, A);
            for (let Ze = 0; Ze < ge.length - 1; Ze++) {
              const Ve = ge[Ze], Le = ge[Ze + 1];
              for (let Qe = 0; Qe < ze.length - 1; Qe++) l.push(Pe(Ve, ze[Qe], Le, ze[Qe + 1]));
            }
          } else l.push(Pe({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: m + 1 }, { fixed: 0, stretch: g + 1 }));
          return l;
        }
        function yc(r, t, n) {
          let s = 0;
          for (const l of r) s += Math.max(t, Math.min(n, l[1])) - Math.max(t, Math.min(n, l[0]));
          return s;
        }
        function sd(r, t, n) {
          const s = [{ fixed: -1, stretch: 0 }];
          for (const [l, d] of r) {
            const p = s[s.length - 1];
            s.push({ fixed: l - p.stretch, stretch: p.stretch }), s.push({ fixed: l - p.stretch, stretch: p.stretch + (d - l) });
          }
          return s.push({ fixed: t + ll, stretch: n }), s;
        }
        function xc(r, t, n, s) {
          return r / t * n + s;
        }
        function vc(r, t, n, s) {
          return r - t * n / s;
        }
        class bc {
          constructor(t, n, s, l, d, p, m, g, x, b) {
            var w;
            if (this.boxStartIndex = t.length, x) {
              let I = p.top, E = p.bottom;
              const A = p.collisionPadding;
              A && (I -= A[1], E += A[3]);
              let D = E - I;
              D > 0 && (D = Math.max(10, D), this.circleDiameter = D);
            } else {
              const I = !((w = p.image) === null || w === void 0) && w.content && (p.image.textFitWidth || p.image.textFitHeight) ? Au(p) : { x1: p.left, y1: p.top, x2: p.right, y2: p.bottom };
              I.y1 = I.y1 * m - g[0], I.y2 = I.y2 * m + g[2], I.x1 = I.x1 * m - g[3], I.x2 = I.x2 * m + g[1];
              const E = p.collisionPadding;
              if (E && (I.x1 -= E[0] * m, I.y1 -= E[1] * m, I.x2 += E[2] * m, I.y2 += E[3] * m), b) {
                const A = new Ue(I.x1, I.y1), D = new Ue(I.x2, I.y1), F = new Ue(I.x1, I.y2), Z = new Ue(I.x2, I.y2), Y = b * Math.PI / 180;
                A._rotate(Y), D._rotate(Y), F._rotate(Y), Z._rotate(Y), I.x1 = Math.min(A.x, D.x, F.x, Z.x), I.x2 = Math.max(A.x, D.x, F.x, Z.x), I.y1 = Math.min(A.y, D.y, F.y, Z.y), I.y2 = Math.max(A.y, D.y, F.y, Z.y);
              }
              t.emplaceBack(n.x, n.y, I.x1, I.y1, I.x2, I.y2, s, l, d);
            }
            this.boxEndIndex = t.length;
          }
        }
        class Zp {
          constructor(t = [], n = (s, l) => s < l ? -1 : s > l ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: s } = this, l = n[t];
            for (; t > 0; ) {
              const d = t - 1 >> 1, p = n[d];
              if (s(l, p) >= 0) break;
              n[t] = p, t = d;
            }
            n[t] = l;
          }
          _down(t) {
            const { data: n, compare: s } = this, l = this.length >> 1, d = n[t];
            for (; t < l; ) {
              let p = 1 + (t << 1);
              const m = p + 1;
              if (m < this.length && s(n[m], n[p]) < 0 && (p = m), s(n[p], d) >= 0) break;
              n[t] = n[p], t = p;
            }
            n[t] = d;
          }
        }
        function Up(r, t = 1, n = !1) {
          let s = 1 / 0, l = 1 / 0, d = -1 / 0, p = -1 / 0;
          const m = r[0];
          for (let E = 0; E < m.length; E++) {
            const A = m[E];
            (!E || A.x < s) && (s = A.x), (!E || A.y < l) && (l = A.y), (!E || A.x > d) && (d = A.x), (!E || A.y > p) && (p = A.y);
          }
          const g = Math.min(d - s, p - l);
          let x = g / 2;
          const b = new Zp([], Gp);
          if (g === 0) return new Ue(s, l);
          for (let E = s; E < d; E += g) for (let A = l; A < p; A += g) b.push(new Fa(E + x, A + x, x, r));
          let w = function(E) {
            let A = 0, D = 0, F = 0;
            const Z = E[0];
            for (let Y = 0, $ = Z.length, C = $ - 1; Y < $; C = Y++) {
              const B = Z[Y], q = Z[C], ae = B.x * q.y - q.x * B.y;
              D += (B.x + q.x) * ae, F += (B.y + q.y) * ae, A += 3 * ae;
            }
            return new Fa(D / A, F / A, 0, E);
          }(r), I = b.length;
          for (; b.length; ) {
            const E = b.pop();
            (E.d > w.d || !w.d) && (w = E, n && console.log("found best %d after %d probes", Math.round(1e4 * E.d) / 1e4, I)), E.max - w.d <= t || (x = E.h / 2, b.push(new Fa(E.p.x - x, E.p.y - x, x, r)), b.push(new Fa(E.p.x + x, E.p.y - x, x, r)), b.push(new Fa(E.p.x - x, E.p.y + x, x, r)), b.push(new Fa(E.p.x + x, E.p.y + x, x, r)), I += 4);
          }
          return n && (console.log(`num probes: ${I}`), console.log(`best distance: ${w.d}`)), w.p;
        }
        function Gp(r, t) {
          return t.max - r.max;
        }
        function Fa(r, t, n, s) {
          this.p = new Ue(r, t), this.h = n, this.d = function(l, d) {
            let p = !1, m = 1 / 0;
            for (let g = 0; g < d.length; g++) {
              const x = d[g];
              for (let b = 0, w = x.length, I = w - 1; b < w; I = b++) {
                const E = x[b], A = x[I];
                E.y > l.y != A.y > l.y && l.x < (A.x - E.x) * (l.y - E.y) / (A.y - E.y) + E.x && (p = !p), m = Math.min(m, jh(l, E, A));
              }
            }
            return (p ? 1 : -1) * Math.sqrt(m);
          }(this.p, s), this.max = this.d + this.h * Math.SQRT2;
        }
        var di;
        z.ax = void 0, (di = z.ax || (z.ax = {}))[di.center = 1] = "center", di[di.left = 2] = "left", di[di.right = 3] = "right", di[di.top = 4] = "top", di[di.bottom = 5] = "bottom", di[di["top-left"] = 6] = "top-left", di[di["top-right"] = 7] = "top-right", di[di["bottom-left"] = 8] = "bottom-left", di[di["bottom-right"] = 9] = "bottom-right";
        const rs = 7, Ch = Number.POSITIVE_INFINITY;
        function ad(r, t) {
          return t[1] !== Ch ? function(n, s, l) {
            let d = 0, p = 0;
            switch (s = Math.abs(s), l = Math.abs(l), n) {
              case "top-right":
              case "top-left":
              case "top":
                p = l - rs;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                p = -l + rs;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                d = -s;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                d = s;
            }
            return [d, p];
          }(r, t[0], t[1]) : function(n, s) {
            let l = 0, d = 0;
            s < 0 && (s = 0);
            const p = s / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                d = p - rs;
                break;
              case "bottom-right":
              case "bottom-left":
                d = -p + rs;
                break;
              case "bottom":
                d = -s + rs;
                break;
              case "top":
                d = s - rs;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                l = -p;
                break;
              case "top-left":
              case "bottom-left":
                l = p;
                break;
              case "left":
                l = s;
                break;
              case "right":
                l = -s;
            }
            return [l, d];
          }(r, t[0]);
        }
        function od(r, t, n) {
          var s;
          const l = r.layout, d = (s = l.get("text-variable-anchor-offset")) === null || s === void 0 ? void 0 : s.evaluate(t, {}, n);
          if (d) {
            const m = d.values, g = [];
            for (let x = 0; x < m.length; x += 2) {
              const b = g[x] = m[x], w = m[x + 1].map((I) => I * $t);
              b.startsWith("top") ? w[1] -= rs : b.startsWith("bottom") && (w[1] += rs), g[x + 1] = w;
            }
            return new Xt(g);
          }
          const p = l.get("text-variable-anchor");
          if (p) {
            let m;
            m = r._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [l.get("text-radial-offset").evaluate(t, {}, n) * $t, Ch] : l.get("text-offset").evaluate(t, {}, n).map((x) => x * $t);
            const g = [];
            for (const x of p) g.push(x, ad(x, m));
            return new Xt(g);
          }
          return null;
        }
        function Eh(r) {
          switch (r) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function $p(r, t, n, s, l, d, p, m, g, x, b, w) {
          let I = d.textMaxSize.evaluate(t, {});
          I === void 0 && (I = p);
          const E = r.layers[0].layout, A = E.get("icon-offset").evaluate(t, {}, b), D = cd(n.horizontal), F = p / 24, Z = r.tilePixelRatio * F, Y = r.tilePixelRatio * I / 24, $ = r.tilePixelRatio * m, C = r.tilePixelRatio * E.get("symbol-spacing"), B = E.get("text-padding") * r.tilePixelRatio, q = function(Ze, Ve, Le, Qe = 1) {
            const At = Ze.get("icon-padding").evaluate(Ve, {}, Le), qt = At && At.values;
            return [qt[0] * Qe, qt[1] * Qe, qt[2] * Qe, qt[3] * Qe];
          }(E, t, b, r.tilePixelRatio), ae = E.get("text-max-angle") / 180 * Math.PI, ve = E.get("text-rotation-alignment") !== "viewport" && E.get("symbol-placement") !== "point", ce = E.get("icon-rotation-alignment") === "map" && E.get("symbol-placement") !== "point", de = E.get("symbol-placement"), Te = C / 2, we = E.get("icon-text-fit");
          let Pe;
          s && we !== "none" && (r.allowVerticalPlacement && n.vertical && (Pe = zu(s, n.vertical, we, E.get("icon-text-fit-padding"), A, F)), D && (s = zu(s, D, we, E.get("icon-text-fit-padding"), A, F)));
          const ge = b ? w.line.getGranularityForZoomLevel(b.z) : 1, ze = (Ze, Ve) => {
            Ve.x < 0 || Ve.x >= ht || Ve.y < 0 || Ve.y >= ht || function(Le, Qe, At, qt, pi, tr, Ai, si, St, Yt, ai, oi, Ti, ir, Qt, zi, Wt, ei, ti, jt, vt, wr, Oa, Tr, Hp) {
              const ja = Le.addToLineVertexArray(Qe, At);
              let Ds, Va, Na, Za, pd = 0, fd = 0, md = 0, _d = 0, Fh = -1, Oh = -1;
              const In = {};
              let gd = Zt("");
              if (Le.allowVerticalPlacement && qt.vertical) {
                const gi = si.layout.get("text-rotate").evaluate(vt, {}, Tr) + 90;
                Na = new bc(St, Qe, Yt, ai, oi, qt.vertical, Ti, ir, Qt, gi), Ai && (Za = new bc(St, Qe, Yt, ai, oi, Ai, Wt, ei, Qt, gi));
              }
              if (pi) {
                const gi = si.layout.get("icon-rotate").evaluate(vt, {}), rr = si.layout.get("icon-text-fit") !== "none", Rs = nd(pi, gi, Oa, rr), Sr = Ai ? nd(Ai, gi, Oa, rr) : void 0;
                Va = new bc(St, Qe, Yt, ai, oi, pi, Wt, ei, !1, gi), pd = 4 * Rs.length;
                const Ls = Le.iconSizeData;
                let $r = null;
                Ls.kind === "source" ? ($r = [Gr * si.layout.get("icon-size").evaluate(vt, {})], $r[0] > es && ci(`${Le.layerIds[0]}: Value for "icon-size" is >= ${al}. Reduce your "icon-size".`)) : Ls.kind === "composite" && ($r = [Gr * wr.compositeIconSizes[0].evaluate(vt, {}, Tr), Gr * wr.compositeIconSizes[1].evaluate(vt, {}, Tr)], ($r[0] > es || $r[1] > es) && ci(`${Le.layerIds[0]}: Value for "icon-size" is >= ${al}. Reduce your "icon-size".`)), Le.addSymbols(Le.icon, Rs, $r, jt, ti, vt, z.ag.none, Qe, ja.lineStartIndex, ja.lineLength, -1, Tr), Fh = Le.icon.placedSymbolArray.length - 1, Sr && (fd = 4 * Sr.length, Le.addSymbols(Le.icon, Sr, $r, jt, ti, vt, z.ag.vertical, Qe, ja.lineStartIndex, ja.lineLength, -1, Tr), Oh = Le.icon.placedSymbolArray.length - 1);
              }
              const yd = Object.keys(qt.horizontal);
              for (const gi of yd) {
                const rr = qt.horizontal[gi];
                if (!Ds) {
                  gd = Zt(rr.text);
                  const Sr = si.layout.get("text-rotate").evaluate(vt, {}, Tr);
                  Ds = new bc(St, Qe, Yt, ai, oi, rr, Ti, ir, Qt, Sr);
                }
                const Rs = rr.positionedLines.length === 1;
                if (md += ld(Le, Qe, rr, tr, si, Qt, vt, zi, ja, qt.vertical ? z.ag.horizontal : z.ag.horizontalOnly, Rs ? yd : [gi], In, Fh, wr, Tr), Rs) break;
              }
              qt.vertical && (_d += ld(Le, Qe, qt.vertical, tr, si, Qt, vt, zi, ja, z.ag.vertical, ["vertical"], In, Oh, wr, Tr));
              const Xp = Ds ? Ds.boxStartIndex : Le.collisionBoxArray.length, Kp = Ds ? Ds.boxEndIndex : Le.collisionBoxArray.length, Jp = Na ? Na.boxStartIndex : Le.collisionBoxArray.length, Yp = Na ? Na.boxEndIndex : Le.collisionBoxArray.length, Qp = Va ? Va.boxStartIndex : Le.collisionBoxArray.length, ef = Va ? Va.boxEndIndex : Le.collisionBoxArray.length, tf = Za ? Za.boxStartIndex : Le.collisionBoxArray.length, rf = Za ? Za.boxEndIndex : Le.collisionBoxArray.length;
              let Pr = -1;
              const Tc = (gi, rr) => gi && gi.circleDiameter ? Math.max(gi.circleDiameter, rr) : rr;
              Pr = Tc(Ds, Pr), Pr = Tc(Na, Pr), Pr = Tc(Va, Pr), Pr = Tc(Za, Pr);
              const xd = Pr > -1 ? 1 : 0;
              xd && (Pr *= Hp / $t), Le.glyphOffsetArray.length >= La.MAX_GLYPHS && ci("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), vt.sortKey !== void 0 && Le.addToSortKeyRanges(Le.symbolInstances.length, vt.sortKey);
              const nf = od(si, vt, Tr), [sf, af] = function(gi, rr) {
                const Rs = gi.length, Sr = rr == null ? void 0 : rr.values;
                if ((Sr == null ? void 0 : Sr.length) > 0) for (let Ls = 0; Ls < Sr.length; Ls += 2) {
                  const $r = Sr[Ls + 1];
                  gi.emplaceBack(z.ax[Sr[Ls]], $r[0], $r[1]);
                }
                return [Rs, gi.length];
              }(Le.textAnchorOffsets, nf);
              Le.symbolInstances.emplaceBack(Qe.x, Qe.y, In.right >= 0 ? In.right : -1, In.center >= 0 ? In.center : -1, In.left >= 0 ? In.left : -1, In.vertical || -1, Fh, Oh, gd, Xp, Kp, Jp, Yp, Qp, ef, tf, rf, Yt, md, _d, pd, fd, xd, 0, Ti, Pr, sf, af);
            }(r, Ve, Ze, n, s, l, Pe, r.layers[0], r.collisionBoxArray, t.index, t.sourceLayerIndex, r.index, Z, [B, B, B, B], ve, g, $, q, ce, A, t, d, x, b, p);
          };
          if (de === "line") for (const Ze of Yu(t.geometry, 0, 0, ht, ht)) {
            const Ve = ks(Ze, ge), Le = Np(Ve, C, ae, n.vertical || D, s, 24, Y, r.overscaling, ht);
            for (const Qe of Le) D && qp(r, D.text, Te, Qe) || ze(Ve, Qe);
          }
          else if (de === "line-center") {
            for (const Ze of t.geometry) if (Ze.length > 1) {
              const Ve = ks(Ze, ge), Le = Vp(Ve, ae, n.vertical || D, s, 24, Y);
              Le && ze(Ve, Le);
            }
          } else if (t.type === "Polygon") for (const Ze of Ks(t.geometry, 0)) {
            const Ve = Up(Ze, 16);
            ze(ks(Ze[0], ge, !0), new is(Ve.x, Ve.y, 0));
          }
          else if (t.type === "LineString") for (const Ze of t.geometry) {
            const Ve = ks(Ze, ge);
            ze(Ve, new is(Ve[0].x, Ve[0].y, 0));
          }
          else if (t.type === "Point") for (const Ze of t.geometry) for (const Ve of Ze) ze([Ve], new is(Ve.x, Ve.y, 0));
        }
        function ld(r, t, n, s, l, d, p, m, g, x, b, w, I, E, A) {
          const D = function(Y, $, C, B, q, ae, ve, ce) {
            const de = B.layout.get("text-rotate").evaluate(ae, {}) * Math.PI / 180, Te = [];
            for (const we of $.positionedLines) for (const Pe of we.positionedGlyphs) {
              if (!Pe.rect) continue;
              const ge = Pe.rect || {};
              let ze = xp + 1, Ze = !0, Ve = 1, Le = 0;
              const Qe = (q || ce) && Pe.vertical, At = Pe.metrics.advance * Pe.scale / 2;
              if (ce && $.verticalizable && (Le = we.lineOffset / 2 - (Pe.imageName ? -($t - Pe.metrics.width * Pe.scale) / 2 : (Pe.scale - 1) * $t)), Pe.imageName) {
                const ei = ve[Pe.imageName];
                Ze = ei.sdf, Ve = ei.pixelRatio, ze = Ei / Ve;
              }
              const qt = q ? [Pe.x + At, Pe.y] : [0, 0];
              let pi = q ? [0, 0] : [Pe.x + At + C[0], Pe.y + C[1] - Le], tr = [0, 0];
              Qe && (tr = pi, pi = [0, 0]);
              const Ai = Pe.metrics.isDoubleResolution ? 2 : 1, si = (Pe.metrics.left - ze) * Pe.scale - At + pi[0], St = (-Pe.metrics.top - ze) * Pe.scale + pi[1], Yt = si + ge.w / Ai * Pe.scale / Ve, ai = St + ge.h / Ai * Pe.scale / Ve, oi = new Ue(si, St), Ti = new Ue(Yt, St), ir = new Ue(si, ai), Qt = new Ue(Yt, ai);
              if (Qe) {
                const ei = new Ue(-At, At - pc), ti = -Math.PI / 2, jt = $t / 2 - At, vt = new Ue(5 - pc - jt, -(Pe.imageName ? jt : 0)), wr = new Ue(...tr);
                oi._rotateAround(ti, ei)._add(vt)._add(wr), Ti._rotateAround(ti, ei)._add(vt)._add(wr), ir._rotateAround(ti, ei)._add(vt)._add(wr), Qt._rotateAround(ti, ei)._add(vt)._add(wr);
              }
              if (de) {
                const ei = Math.sin(de), ti = Math.cos(de), jt = [ti, -ei, ei, ti];
                oi._matMult(jt), Ti._matMult(jt), ir._matMult(jt), Qt._matMult(jt);
              }
              const zi = new Ue(0, 0), Wt = new Ue(0, 0);
              Te.push({ tl: oi, tr: Ti, bl: ir, br: Qt, tex: ge, writingMode: $.writingMode, glyphOffset: qt, sectionIndex: Pe.sectionIndex, isSDF: Ze, pixelOffsetTL: zi, pixelOffsetBR: Wt, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Te;
          }(0, n, m, l, d, p, s, r.allowVerticalPlacement), F = r.textSizeData;
          let Z = null;
          F.kind === "source" ? (Z = [Gr * l.layout.get("text-size").evaluate(p, {})], Z[0] > es && ci(`${r.layerIds[0]}: Value for "text-size" is >= ${al}. Reduce your "text-size".`)) : F.kind === "composite" && (Z = [Gr * E.compositeTextSizes[0].evaluate(p, {}, A), Gr * E.compositeTextSizes[1].evaluate(p, {}, A)], (Z[0] > es || Z[1] > es) && ci(`${r.layerIds[0]}: Value for "text-size" is >= ${al}. Reduce your "text-size".`)), r.addSymbols(r.text, D, Z, m, d, p, x, t, g.lineStartIndex, g.lineLength, I, A);
          for (const Y of b) w[Y] = r.text.placedSymbolArray.length - 1;
          return 4 * D.length;
        }
        function cd(r) {
          for (const t in r) return r[t];
          return null;
        }
        function qp(r, t, n, s) {
          const l = r.compareText;
          if (t in l) {
            const d = l[t];
            for (let p = d.length - 1; p >= 0; p--) if (s.dist(d[p]) < n) return !0;
          } else l[t] = [];
          return l[t].push(s), !1;
        }
        const hd = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Ah {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, s] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const l = s >> 4;
            if (l !== 1) throw new Error(`Got v${l} data when expected v1.`);
            const d = hd[15 & s];
            if (!d) throw new Error("Unrecognized array type.");
            const [p] = new Uint16Array(t, 2, 1), [m] = new Uint32Array(t, 4, 1);
            return new Ah(m, p, d, t);
          }
          constructor(t, n = 64, s = Float64Array, l) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = s, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const d = hd.indexOf(this.ArrayType), p = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, m = t * this.IndexArrayType.BYTES_PER_ELEMENT, g = (8 - m % 8) % 8;
            if (d < 0) throw new Error(`Unexpected typed array class: ${s}.`);
            l && l instanceof ArrayBuffer ? (this.data = l, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + m + g, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + p + m + g), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + m + g, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + d]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const s = this._pos >> 1;
            return this.ids[s] = s, this.coords[this._pos++] = t, this.coords[this._pos++] = n, s;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return zh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(t, n, s, l) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: d, coords: p, nodeSize: m } = this, g = [0, d.length - 1, 0], x = [];
            for (; g.length; ) {
              const b = g.pop() || 0, w = g.pop() || 0, I = g.pop() || 0;
              if (w - I <= m) {
                for (let F = I; F <= w; F++) {
                  const Z = p[2 * F], Y = p[2 * F + 1];
                  Z >= t && Z <= s && Y >= n && Y <= l && x.push(d[F]);
                }
                continue;
              }
              const E = I + w >> 1, A = p[2 * E], D = p[2 * E + 1];
              A >= t && A <= s && D >= n && D <= l && x.push(d[E]), (b === 0 ? t <= A : n <= D) && (g.push(I), g.push(E - 1), g.push(1 - b)), (b === 0 ? s >= A : l >= D) && (g.push(E + 1), g.push(w), g.push(1 - b));
            }
            return x;
          }
          within(t, n, s) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: l, coords: d, nodeSize: p } = this, m = [0, l.length - 1, 0], g = [], x = s * s;
            for (; m.length; ) {
              const b = m.pop() || 0, w = m.pop() || 0, I = m.pop() || 0;
              if (w - I <= p) {
                for (let F = I; F <= w; F++) dd(d[2 * F], d[2 * F + 1], t, n) <= x && g.push(l[F]);
                continue;
              }
              const E = I + w >> 1, A = d[2 * E], D = d[2 * E + 1];
              dd(A, D, t, n) <= x && g.push(l[E]), (b === 0 ? t - s <= A : n - s <= D) && (m.push(I), m.push(E - 1), m.push(1 - b)), (b === 0 ? t + s >= A : n + s >= D) && (m.push(E + 1), m.push(w), m.push(1 - b));
            }
            return g;
          }
        }
        function zh(r, t, n, s, l, d) {
          if (l - s <= n) return;
          const p = s + l >> 1;
          ud(r, t, p, s, l, d), zh(r, t, n, s, p - 1, 1 - d), zh(r, t, n, p + 1, l, 1 - d);
        }
        function ud(r, t, n, s, l, d) {
          for (; l > s; ) {
            if (l - s > 600) {
              const x = l - s + 1, b = n - s + 1, w = Math.log(x), I = 0.5 * Math.exp(2 * w / 3), E = 0.5 * Math.sqrt(w * I * (x - I) / x) * (b - x / 2 < 0 ? -1 : 1);
              ud(r, t, n, Math.max(s, Math.floor(n - b * I / x + E)), Math.min(l, Math.floor(n + (x - b) * I / x + E)), d);
            }
            const p = t[2 * n + d];
            let m = s, g = l;
            for (cl(r, t, s, n), t[2 * l + d] > p && cl(r, t, s, l); m < g; ) {
              for (cl(r, t, m, g), m++, g--; t[2 * m + d] < p; ) m++;
              for (; t[2 * g + d] > p; ) g--;
            }
            t[2 * s + d] === p ? cl(r, t, s, g) : (g++, cl(r, t, g, l)), g <= n && (s = g + 1), n <= g && (l = g - 1);
          }
        }
        function cl(r, t, n, s) {
          kh(r, n, s), kh(t, 2 * n, 2 * s), kh(t, 2 * n + 1, 2 * s + 1);
        }
        function kh(r, t, n) {
          const s = r[t];
          r[t] = r[n], r[n] = s;
        }
        function dd(r, t, n, s) {
          const l = r - n, d = t - s;
          return l * l + d * d;
        }
        var Dh;
        z.cg = void 0, (Dh = z.cg || (z.cg = {})).create = "create", Dh.load = "load", Dh.fullLoad = "fullLoad";
        let wc = null, hl = [];
        const Rh = 1e3 / 60, Lh = "loadTime", Bh = "fullLoadTime", Wp = { mark(r) {
          performance.mark(r);
        }, frame(r) {
          const t = r;
          wc != null && hl.push(t - wc), wc = t;
        }, clearMetrics() {
          wc = null, hl = [], performance.clearMeasures(Lh), performance.clearMeasures(Bh);
          for (const r in z.cg) performance.clearMarks(z.cg[r]);
        }, getPerformanceMetrics() {
          performance.measure(Lh, z.cg.create, z.cg.load), performance.measure(Bh, z.cg.create, z.cg.fullLoad);
          const r = performance.getEntriesByName(Lh)[0].duration, t = performance.getEntriesByName(Bh)[0].duration, n = hl.length, s = 1 / (hl.reduce((d, p) => d + p, 0) / n / 1e3), l = hl.filter((d) => d > Rh).reduce((d, p) => d + (p - Rh) / Rh, 0);
          return { loadTime: r, fullLoadTime: t, fps: s, percentDroppedFrames: l / (n + l) * 100, totalFrames: n };
        } };
        z.$ = ol, z.A = bt, z.B = Mi, z.C = Tt, z.D = Fe, z.E = ie, z.F = Hl, z.G = function(r) {
          if (Dt == null) {
            const t = r.navigator ? r.navigator.userAgent : null;
            Dt = !!r.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Dt;
        }, z.H = class {
          constructor(r, t) {
            this.target = r, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Fp(() => this.process()), this.subscription = ar(this.target, "message", (n) => this.receive(n), !1), this.globalScope = mr(self) ? r : window;
          }
          registerMessageHandler(r, t) {
            this.messageHandlers[r] = t;
          }
          sendAsync(r, t) {
            return new Promise((n, s) => {
              const l = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), d = t ? ar(t.signal, "abort", () => {
                d == null || d.unsubscribe(), delete this.resolveRejects[l];
                const g = { id: l, type: "<cancel>", origin: location.origin, targetMapId: r.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(g);
              }, Op) : null;
              this.resolveRejects[l] = { resolve: (g) => {
                d == null || d.unsubscribe(), n(g);
              }, reject: (g) => {
                d == null || d.unsubscribe(), s(g);
              } };
              const p = [], m = Object.assign(Object.assign({}, r), { id: l, sourceMapId: this.mapId, origin: location.origin, data: Nr(r.data, p) });
              this.target.postMessage(m, { transfer: p });
            });
          }
          receive(r) {
            const t = r.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const s = this.abortControllers[n];
                return delete this.abortControllers[n], void (s && s.abort());
              }
              if (mr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const r = this.taskQueue.shift(), t = this.tasks[r];
            delete this.tasks[r], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(r, t);
          }
          processTask(r, t) {
            return c(this, void 0, void 0, function* () {
              if (t.type === "<response>") {
                const l = this.resolveRejects[r];
                return delete this.resolveRejects[r], l ? void (t.error ? l.reject(Ss(t.error)) : l.resolve(Ss(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(r, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = Ss(t.data), s = new AbortController();
              this.abortControllers[r] = s;
              try {
                const l = yield this.messageHandlers[t.type](t.sourceMapId, n, s);
                this.completeTask(r, null, l);
              } catch (l) {
                this.completeTask(r, l);
              }
            });
          }
          completeTask(r, t, n) {
            const s = [];
            delete this.abortControllers[r];
            const l = { id: r, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Nr(t) : null, data: Nr(n, s) };
            this.target.postMessage(l, { transfer: s });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, z.I = gh, z.J = an, z.K = function() {
          var r = new bt(16);
          return bt != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
        }, z.L = function(r, t, n) {
          var s, l, d, p, m, g, x, b, w, I, E, A, D = n[0], F = n[1], Z = n[2];
          return t === r ? (r[12] = t[0] * D + t[4] * F + t[8] * Z + t[12], r[13] = t[1] * D + t[5] * F + t[9] * Z + t[13], r[14] = t[2] * D + t[6] * F + t[10] * Z + t[14], r[15] = t[3] * D + t[7] * F + t[11] * Z + t[15]) : (l = t[1], d = t[2], p = t[3], m = t[4], g = t[5], x = t[6], b = t[7], w = t[8], I = t[9], E = t[10], A = t[11], r[0] = s = t[0], r[1] = l, r[2] = d, r[3] = p, r[4] = m, r[5] = g, r[6] = x, r[7] = b, r[8] = w, r[9] = I, r[10] = E, r[11] = A, r[12] = s * D + m * F + w * Z + t[12], r[13] = l * D + g * F + I * Z + t[13], r[14] = d * D + x * F + E * Z + t[14], r[15] = p * D + b * F + A * Z + t[15]), r;
        }, z.M = function(r, t, n) {
          var s = n[0], l = n[1], d = n[2];
          return r[0] = t[0] * s, r[1] = t[1] * s, r[2] = t[2] * s, r[3] = t[3] * s, r[4] = t[4] * l, r[5] = t[5] * l, r[6] = t[6] * l, r[7] = t[7] * l, r[8] = t[8] * d, r[9] = t[9] * d, r[10] = t[10] * d, r[11] = t[11] * d, r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r;
        }, z.N = function(r, t, n) {
          var s = t[0], l = t[1], d = t[2], p = t[3], m = t[4], g = t[5], x = t[6], b = t[7], w = t[8], I = t[9], E = t[10], A = t[11], D = t[12], F = t[13], Z = t[14], Y = t[15], $ = n[0], C = n[1], B = n[2], q = n[3];
          return r[0] = $ * s + C * m + B * w + q * D, r[1] = $ * l + C * g + B * I + q * F, r[2] = $ * d + C * x + B * E + q * Z, r[3] = $ * p + C * b + B * A + q * Y, r[4] = ($ = n[4]) * s + (C = n[5]) * m + (B = n[6]) * w + (q = n[7]) * D, r[5] = $ * l + C * g + B * I + q * F, r[6] = $ * d + C * x + B * E + q * Z, r[7] = $ * p + C * b + B * A + q * Y, r[8] = ($ = n[8]) * s + (C = n[9]) * m + (B = n[10]) * w + (q = n[11]) * D, r[9] = $ * l + C * g + B * I + q * F, r[10] = $ * d + C * x + B * E + q * Z, r[11] = $ * p + C * b + B * A + q * Y, r[12] = ($ = n[12]) * s + (C = n[13]) * m + (B = n[14]) * w + (q = n[15]) * D, r[13] = $ * l + C * g + B * I + q * F, r[14] = $ * d + C * x + B * E + q * Z, r[15] = $ * p + C * b + B * A + q * Y, r;
        }, z.O = function(r, t) {
          const n = {};
          for (let s = 0; s < t.length; s++) {
            const l = t[s];
            l in r && (n[l] = r[l]);
          }
          return n;
        }, z.P = Ue, z.Q = ts, z.R = Qi, z.S = Nu, z.T = Oo, z.U = Vu, z.V = ns, z.W = mi, z.X = Wi, z.Y = er, z.Z = ht, z._ = c, z.a = sn, z.a$ = function() {
          const r = new Float32Array(16);
          return ss(r), r;
        }, z.a0 = Ih, z.a1 = (r) => {
          const t = window.document.createElement("video");
          return t.muted = !0, new Promise((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const s of r) {
              const l = window.document.createElement("source");
              Lr(s) || (t.crossOrigin = "Anonymous"), l.src = s, t.appendChild(l);
            }
          });
        }, z.a2 = ne, z.a3 = function() {
          return Yr++;
        }, z.a4 = f, z.a5 = La, z.a6 = ua, z.a7 = Ci, z.a8 = Hu, z.a9 = function(r) {
          const t = {};
          if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, s, l, d) => {
            const p = l || d;
            return t[s] = !p || p.toLowerCase(), "";
          }), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, z.aA = xh, z.aB = Ah, z.aC = Lt, z.aD = hc, z.aE = N, z.aF = Oe, z.aG = Ie, z.aH = function(r) {
          return Math.pow(2, r);
        }, z.aI = 85.051129, z.aJ = Zu, z.aK = Ri, z.aL = Hi, z.aM = Uu, z.aN = function(r, t, n) {
          return r[0] = t[0] * n, r[1] = t[1] * n, r[2] = t[2] * n, r;
        }, z.aO = function(r, t, n) {
          return r[0] = t[0] + n[0], r[1] = t[1] + n[1], r[2] = t[2] + n[2], r;
        }, z.aP = function(r) {
          var t = new bt(3);
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t;
        }, z.aQ = function(r, t, n) {
          return r[0] = t[0] * n[0], r[1] = t[1] * n[1], r[2] = t[2] * n[2], r[3] = t[3] * n[3], r;
        }, z.aR = function(r, t, n) {
          return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], r;
        }, z.aS = function(r, t) {
          var n = t[0], s = t[1], l = t[2], d = n * n + s * s + l * l;
          return d > 0 && (d = 1 / Math.sqrt(d)), r[0] = t[0] * d, r[1] = t[1] * d, r[2] = t[2] * d, r;
        }, z.aT = function(r, t, n) {
          var s = t[0], l = t[1], d = t[2], p = n[0], m = n[1], g = n[2];
          return r[0] = l * g - d * m, r[1] = d * p - s * g, r[2] = s * m - l * p, r;
        }, z.aU = function(r, t) {
          return r[0] * t[0] + r[1] * t[1] + r[2] * t[2];
        }, z.aV = $u, z.aW = Ba, z.aX = function(r, t, n, s, l) {
          var d, p = 1 / Math.tan(t / 2);
          return r[0] = p / n, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = p, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, l != null && l !== 1 / 0 ? (r[10] = (l + s) * (d = 1 / (s - l)), r[14] = 2 * l * s * d) : (r[10] = -1, r[14] = -2 * s), r;
        }, z.aY = function(r) {
          var t = new bt(16);
          return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], t;
        }, z.aZ = function(r, t, n) {
          var s = Math.sin(n), l = Math.cos(n), d = t[0], p = t[1], m = t[2], g = t[3], x = t[4], b = t[5], w = t[6], I = t[7];
          return t !== r && (r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = d * l + x * s, r[1] = p * l + b * s, r[2] = m * l + w * s, r[3] = g * l + I * s, r[4] = x * l - d * s, r[5] = b * l - p * s, r[6] = w * l - m * s, r[7] = I * l - g * s, r;
        }, z.a_ = function(r, t, n) {
          var s = Math.sin(n), l = Math.cos(n), d = t[4], p = t[5], m = t[6], g = t[7], x = t[8], b = t[9], w = t[10], I = t[11];
          return t !== r && (r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[4] = d * l + x * s, r[5] = p * l + b * s, r[6] = m * l + w * s, r[7] = g * l + I * s, r[8] = x * l - d * s, r[9] = b * l - p * s, r[10] = w * l - m * s, r[11] = I * l - g * s, r;
        }, z.aa = function(r) {
          return Math.log(r) / Math.LN2;
        }, z.ab = function(r) {
          var t = r[0], n = r[1];
          return t * t + n * n;
        }, z.ac = function(r) {
          return r * Math.PI / 180;
        }, z.ad = qi, z.ae = function(r, t) {
          const n = [];
          for (const s in r) s in t || n.push(s);
          return n;
        }, z.af = function(r, t) {
          let n = 0, s = 0;
          if (r.kind === "constant") s = r.layoutSize;
          else if (r.kind !== "source") {
            const { interpolationType: l, minZoom: d, maxZoom: p } = r, m = l ? qi(ui.interpolationFactor(l, t, d, p), 0, 1) : 0;
            r.kind === "camera" ? s = Mi.number(r.minSize, r.maxSize, m) : n = m;
          }
          return { uSizeT: n, uSize: s };
        }, z.ah = function(r, { uSize: t, uSizeT: n }, { lowerSize: s, upperSize: l }) {
          return r.kind === "source" ? s / Gr : r.kind === "composite" ? Mi.number(s / Gr, l / Gr, n) : t;
        }, z.ai = function(r, t) {
          var n = t[0], s = t[1], l = t[2], d = t[3], p = t[4], m = t[5], g = t[6], x = t[7], b = t[8], w = t[9], I = t[10], E = t[11], A = t[12], D = t[13], F = t[14], Z = t[15], Y = n * m - s * p, $ = n * g - l * p, C = n * x - d * p, B = s * g - l * m, q = s * x - d * m, ae = l * x - d * g, ve = b * D - w * A, ce = b * F - I * A, de = b * Z - E * A, Te = w * F - I * D, we = w * Z - E * D, Pe = I * Z - E * F, ge = Y * Pe - $ * we + C * Te + B * de - q * ce + ae * ve;
          return ge ? (r[0] = (m * Pe - g * we + x * Te) * (ge = 1 / ge), r[1] = (l * we - s * Pe - d * Te) * ge, r[2] = (D * ae - F * q + Z * B) * ge, r[3] = (I * q - w * ae - E * B) * ge, r[4] = (g * de - p * Pe - x * ce) * ge, r[5] = (n * Pe - l * de + d * ce) * ge, r[6] = (F * C - A * ae - Z * $) * ge, r[7] = (b * ae - I * C + E * $) * ge, r[8] = (p * we - m * de + x * ve) * ge, r[9] = (s * de - n * we - d * ve) * ge, r[10] = (A * q - D * C + Z * Y) * ge, r[11] = (w * C - b * q - E * Y) * ge, r[12] = (m * ce - p * Te - g * ve) * ge, r[13] = (n * Te - s * ce + l * ve) * ge, r[14] = (D * $ - A * B - F * Y) * ge, r[15] = (b * B - w * $ + I * Y) * ge, r) : null;
        }, z.aj = li, z.ak = function(r) {
          return Math.hypot(r[0], r[1]);
        }, z.al = function(r) {
          return r[0] = 0, r[1] = 0, r;
        }, z.am = function(r, t, n) {
          return r[0] = t[0] * n, r[1] = t[1] * n, r;
        }, z.an = bh, z.ao = fr, z.ap = function(r, t, n, s) {
          const l = t.y - r.y, d = t.x - r.x, p = s.y - n.y, m = s.x - n.x, g = p * d - m * l;
          if (g === 0) return null;
          const x = (m * (r.y - n.y) - p * (r.x - n.x)) / g;
          return new Ue(r.x + x * d, r.y + x * l);
        }, z.aq = Yu, z.ar = Ca, z.as = ss, z.at = function(r) {
          let t = 1 / 0, n = 1 / 0, s = -1 / 0, l = -1 / 0;
          for (const d of r) t = Math.min(t, d.x), n = Math.min(n, d.y), s = Math.max(s, d.x), l = Math.max(l, d.y);
          return [t, n, s, l];
        }, z.au = $t, z.av = Cn, z.aw = function(r, t, n, s, l = !1) {
          if (!n[0] && !n[1]) return [0, 0];
          const d = l ? s === "map" ? -r.bearingInRadians : 0 : s === "viewport" ? r.bearingInRadians : 0;
          if (d) {
            const p = Math.sin(d), m = Math.cos(d);
            n = [n[0] * m - n[1] * p, n[0] * p + n[1] * m];
          }
          return [l ? n[0] : Cn(t, n[0], r.zoom), l ? n[1] : Cn(t, n[1], r.zoom)];
        }, z.ay = vh, z.az = Eh, z.b = tn, z.b$ = (r) => r.type === "circle", z.b0 = function() {
          const r = new Float64Array(16);
          return ss(r), r;
        }, z.b1 = function() {
          return new Float64Array(16);
        }, z.b2 = function(r, t, n) {
          const s = new Float64Array(4);
          return function(l, d, p, m) {
            var g = 0.5 * Math.PI / 180;
            d *= g, p *= g, m *= g;
            var x = Math.sin(d), b = Math.cos(d), w = Math.sin(p), I = Math.cos(p), E = Math.sin(m), A = Math.cos(m);
            l[0] = x * I * A - b * w * E, l[1] = b * w * A + x * I * E, l[2] = b * I * E - x * w * A, l[3] = b * I * A + x * w * E;
          }(s, r, t - 90, n), s;
        }, z.b3 = function(r, t, n, s) {
          var l, d, p, m, g, x = t[0], b = t[1], w = t[2], I = t[3], E = n[0], A = n[1], D = n[2], F = n[3];
          return (d = x * E + b * A + w * D + I * F) < 0 && (d = -d, E = -E, A = -A, D = -D, F = -F), 1 - d > Mt ? (l = Math.acos(d), p = Math.sin(l), m = Math.sin((1 - s) * l) / p, g = Math.sin(s * l) / p) : (m = 1 - s, g = s), r[0] = m * x + g * E, r[1] = m * b + g * A, r[2] = m * w + g * D, r[3] = m * I + g * F, r;
        }, z.b4 = function(r) {
          const t = new Float64Array(9);
          var n, s, l, d, p, m, g, x, b, w, I, E, A, D, F, Z, Y, $;
          w = (l = (s = r)[0]) * (g = l + l), I = (d = s[1]) * g, A = (p = s[2]) * g, D = p * (x = d + d), Z = (m = s[3]) * g, Y = m * x, $ = m * (b = p + p), (n = t)[0] = 1 - (E = d * x) - (F = p * b), n[3] = I - $, n[6] = A + Y, n[1] = I + $, n[4] = 1 - w - F, n[7] = D - Z, n[2] = A - Y, n[5] = D + Z, n[8] = 1 - w - E;
          const C = Hi(-Math.asin(qi(t[2], -1, 1)));
          let B, q;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (B = 0, q = -Hi(Math.atan2(t[3], t[4]))) : (B = Hi(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), q = Hi(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: B, pitch: C + 90, bearing: q };
        }, z.b5 = function(r, t) {
          return r.roll == t.roll && r.pitch == t.pitch && r.bearing == t.bearing;
        }, z.b6 = st, z.b7 = Tn, z.b8 = Da, z.b9 = Qo, z.bA = function(r) {
          const t = [], n = r.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), r.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, z.bB = function r(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return !1;
            for (let s = 0; s < t.length; s++) if (!r(t[s], n[s])) return !1;
            return !0;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
            for (const s in t) if (!r(t[s], n[s])) return !1;
            return !0;
          }
          return t === n;
        }, z.bC = Qr, z.bD = en, z.bE = class extends Ui {
          constructor(r, t) {
            super(r, t), this.current = 0;
          }
          set(r) {
            this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
          }
        }, z.bF = Pn, z.bG = class extends Ui {
          constructor(r, t) {
            super(r, t), this.current = Gi;
          }
          set(r) {
            if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
            for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {
              this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
              break;
            }
          }
        }, z.bH = As, z.bI = class extends Ui {
          constructor(r, t) {
            super(r, t), this.current = [0, 0, 0];
          }
          set(r) {
            r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2]));
          }
        }, z.bJ = class extends Ui {
          constructor(r, t) {
            super(r, t), this.current = [0, 0];
          }
          set(r) {
            r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1]));
          }
        }, z.bK = zt, z.bL = function(r, t) {
          var n = Math.sin(t), s = Math.cos(t);
          return r[0] = s, r[1] = n, r[2] = 0, r[3] = -n, r[4] = s, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r;
        }, z.bM = function(r, t, n) {
          var s = t[0], l = t[1], d = t[2];
          return r[0] = s * n[0] + l * n[3] + d * n[6], r[1] = s * n[1] + l * n[4] + d * n[7], r[2] = s * n[2] + l * n[5] + d * n[8], r;
        }, z.bN = function(r, t, n, s, l, d, p) {
          var m = 1 / (t - n), g = 1 / (s - l), x = 1 / (d - p);
          return r[0] = -2 * m, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * g, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * x, r[11] = 0, r[12] = (t + n) * m, r[13] = (l + s) * g, r[14] = (p + d) * x, r[15] = 1, r;
        }, z.bO = class extends Ta {
        }, z.bP = pp, z.bQ = class extends Pa {
        }, z.bR = th, z.bS = function(r) {
          return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
        }, z.bT = Wh, z.bU = function(r, t, n) {
          var s = t[0], l = t[1], d = t[2], p = n[3] * s + n[7] * l + n[11] * d + n[15];
          return r[0] = (n[0] * s + n[4] * l + n[8] * d + n[12]) / (p = p || 1), r[1] = (n[1] * s + n[5] * l + n[9] * d + n[13]) / p, r[2] = (n[2] * s + n[6] * l + n[10] * d + n[14]) / p, r;
        }, z.bV = class extends No {
        }, z.bW = class extends a {
        }, z.bX = function(r, t) {
          return r[0] === t[0] && r[1] === t[1] && r[2] === t[2] && r[3] === t[3] && r[4] === t[4] && r[5] === t[5] && r[6] === t[6] && r[7] === t[7] && r[8] === t[8] && r[9] === t[9] && r[10] === t[10] && r[11] === t[11] && r[12] === t[12] && r[13] === t[13] && r[14] === t[14] && r[15] === t[15];
        }, z.bY = function(r, t) {
          var n = r[0], s = r[1], l = r[2], d = r[3], p = r[4], m = r[5], g = r[6], x = r[7], b = r[8], w = r[9], I = r[10], E = r[11], A = r[12], D = r[13], F = r[14], Z = r[15], Y = t[0], $ = t[1], C = t[2], B = t[3], q = t[4], ae = t[5], ve = t[6], ce = t[7], de = t[8], Te = t[9], we = t[10], Pe = t[11], ge = t[12], ze = t[13], Ze = t[14], Ve = t[15];
          return Math.abs(n - Y) <= Mt * Math.max(1, Math.abs(n), Math.abs(Y)) && Math.abs(s - $) <= Mt * Math.max(1, Math.abs(s), Math.abs($)) && Math.abs(l - C) <= Mt * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(d - B) <= Mt * Math.max(1, Math.abs(d), Math.abs(B)) && Math.abs(p - q) <= Mt * Math.max(1, Math.abs(p), Math.abs(q)) && Math.abs(m - ae) <= Mt * Math.max(1, Math.abs(m), Math.abs(ae)) && Math.abs(g - ve) <= Mt * Math.max(1, Math.abs(g), Math.abs(ve)) && Math.abs(x - ce) <= Mt * Math.max(1, Math.abs(x), Math.abs(ce)) && Math.abs(b - de) <= Mt * Math.max(1, Math.abs(b), Math.abs(de)) && Math.abs(w - Te) <= Mt * Math.max(1, Math.abs(w), Math.abs(Te)) && Math.abs(I - we) <= Mt * Math.max(1, Math.abs(I), Math.abs(we)) && Math.abs(E - Pe) <= Mt * Math.max(1, Math.abs(E), Math.abs(Pe)) && Math.abs(A - ge) <= Mt * Math.max(1, Math.abs(A), Math.abs(ge)) && Math.abs(D - ze) <= Mt * Math.max(1, Math.abs(D), Math.abs(ze)) && Math.abs(F - Ze) <= Mt * Math.max(1, Math.abs(F), Math.abs(Ze)) && Math.abs(Z - Ve) <= Mt * Math.max(1, Math.abs(Z), Math.abs(Ve));
        }, z.bZ = function(r, t) {
          return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r;
        }, z.b_ = (r) => r.type === "symbol", z.ba = ka, z.bb = Kr, z.bc = Jr, z.bd = xi, z.be = function(r, t, n, s, l) {
          return Kr(s, l, qi((r - t) / (n - t), 0, 1));
        }, z.bf = zr, z.bg = function() {
          return new Float64Array(4);
        }, z.bh = function() {
          return new Float64Array(3);
        }, z.bi = function(r, t, n, s) {
          var l = [], d = [];
          return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[0] * Math.cos(s) - l[1] * Math.sin(s), d[1] = l[0] * Math.sin(s) + l[1] * Math.cos(s), d[2] = l[2], r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r;
        }, z.bj = function(r, t, n, s) {
          var l = [], d = [];
          return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[0], d[1] = l[1] * Math.cos(s) - l[2] * Math.sin(s), d[2] = l[1] * Math.sin(s) + l[2] * Math.cos(s), r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r;
        }, z.bk = function(r, t, n, s) {
          var l = [], d = [];
          return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[2] * Math.sin(s) + l[0] * Math.cos(s), d[1] = l[1], d[2] = l[2] * Math.cos(s) - l[0] * Math.sin(s), r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r;
        }, z.bl = function(r, t, n) {
          var s = Math.sin(n), l = Math.cos(n), d = t[0], p = t[1], m = t[2], g = t[3], x = t[8], b = t[9], w = t[10], I = t[11];
          return t !== r && (r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = d * l - x * s, r[1] = p * l - b * s, r[2] = m * l - w * s, r[3] = g * l - I * s, r[8] = d * s + x * l, r[9] = p * s + b * l, r[10] = m * s + w * l, r[11] = g * s + I * l, r;
        }, z.bm = function(r, t) {
          const n = zr(r, 360), s = zr(t, 360), l = s - n, d = s > n ? l - 360 : l + 360;
          return Math.abs(l) < Math.abs(d) ? l : d;
        }, z.bn = function(r) {
          return r[0] = 0, r[1] = 0, r[2] = 0, r;
        }, z.bo = function(r, t, n, s) {
          const l = Math.sqrt(r * r + t * t), d = Math.sqrt(n * n + s * s);
          r /= l, t /= l, n /= d, s /= d;
          const p = Math.acos(r * n + t * s);
          return -t * n + r * s > 0 ? p : -p;
        }, z.bp = function(r, t) {
          return r[0] * t[0] + r[1] * t[1] + r[2] * t[2] + r[3];
        }, z.bq = Sh, z.br = function(r, t) {
          const n = zr(r, 2 * Math.PI), s = zr(t, 2 * Math.PI);
          return Math.min(Math.abs(n - s), Math.abs(n - s + 2 * Math.PI), Math.abs(n - s - 2 * Math.PI));
        }, z.bs = function(r) {
          return Math.hypot(r[0], r[1], r[2]);
        }, z.bt = function() {
          const r = {}, t = P.$version;
          for (const n in P.$root) {
            const s = P.$root[n];
            if (s.required) {
              let l = null;
              l = n === "version" ? t : s.type === "array" ? [] : {}, l != null && (r[n] = l);
            }
          }
          return r;
        }, z.bu = fa, z.bv = gr, z.bw = function(r) {
          r = r.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < r.length; n++) t[r[n].id] = r[n];
          for (let n = 0; n < r.length; n++) "ref" in r[n] && (r[n] = O(r[n], t[r[n].ref]));
          return r;
        }, z.bx = function(r) {
          if (r.type === "custom") return new Bp(r);
          switch (r.type) {
            case "background":
              return new Dp(r);
            case "circle":
              return new Cd(r);
            case "fill":
              return new Wd(r);
            case "fill-extrusion":
              return new tp(r);
            case "heatmap":
              return new Ad(r);
            case "hillshade":
              return new kd(r);
            case "line":
              return new cp(r);
            case "raster":
              return new Lp(r);
            case "symbol":
              return new gc(r);
          }
        }, z.by = Pi, z.bz = function(r, t) {
          if (!r) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!U(r.version, t.version)) return [{ command: "setStyle", args: [t] }];
            U(r.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), U(r.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), U(r.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), U(r.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), U(r.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), U(r.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), U(r.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), U(r.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), U(r.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), U(r.light, t.light) || n.push({ command: "setLight", args: [t.light] }), U(r.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), U(r.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), U(r.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const s = {}, l = [];
            (function(p, m, g, x) {
              let b;
              for (b in m = m || {}, p = p || {}) Object.prototype.hasOwnProperty.call(p, b) && (Object.prototype.hasOwnProperty.call(m, b) || le(b, g, x));
              for (b in m) Object.prototype.hasOwnProperty.call(m, b) && (Object.prototype.hasOwnProperty.call(p, b) ? U(p[b], m[b]) || (p[b].type === "geojson" && m[b].type === "geojson" && me(p, m, b) ? X(g, { command: "setGeoJSONSourceData", args: [b, m[b].data] }) : ee(b, m, g, x)) : te(b, m, g));
            })(r.sources, t.sources, l, s);
            const d = [];
            r.layers && r.layers.forEach((p) => {
              "source" in p && s[p.source] ? n.push({ command: "removeLayer", args: [p.id] }) : d.push(p);
            }), n = n.concat(l), function(p, m, g) {
              m = m || [];
              const x = (p = p || []).map(re), b = m.map(re), w = p.reduce(xe, {}), I = m.reduce(xe, {}), E = x.slice(), A = /* @__PURE__ */ Object.create(null);
              let D, F, Z, Y, $;
              for (let C = 0, B = 0; C < x.length; C++) D = x[C], Object.prototype.hasOwnProperty.call(I, D) ? B++ : (X(g, { command: "removeLayer", args: [D] }), E.splice(E.indexOf(D, B), 1));
              for (let C = 0, B = 0; C < b.length; C++) D = b[b.length - 1 - C], E[E.length - 1 - C] !== D && (Object.prototype.hasOwnProperty.call(w, D) ? (X(g, { command: "removeLayer", args: [D] }), E.splice(E.lastIndexOf(D, E.length - B), 1)) : B++, Y = E[E.length - C], X(g, { command: "addLayer", args: [I[D], Y] }), E.splice(E.length - C, 0, D), A[D] = !0);
              for (let C = 0; C < b.length; C++) if (D = b[C], F = w[D], Z = I[D], !A[D] && !U(F, Z)) if (U(F.source, Z.source) && U(F["source-layer"], Z["source-layer"]) && U(F.type, Z.type)) {
                for ($ in he(F.layout, Z.layout, g, D, null, "setLayoutProperty"), he(F.paint, Z.paint, g, D, null, "setPaintProperty"), U(F.filter, Z.filter) || X(g, { command: "setFilter", args: [D, Z.filter] }), U(F.minzoom, Z.minzoom) && U(F.maxzoom, Z.maxzoom) || X(g, { command: "setLayerZoomRange", args: [D, Z.minzoom, Z.maxzoom] }), F) Object.prototype.hasOwnProperty.call(F, $) && $ !== "layout" && $ !== "paint" && $ !== "filter" && $ !== "metadata" && $ !== "minzoom" && $ !== "maxzoom" && ($.indexOf("paint.") === 0 ? he(F[$], Z[$], g, D, $.slice(6), "setPaintProperty") : U(F[$], Z[$]) || X(g, { command: "setLayerProperty", args: [D, $, Z[$]] }));
                for ($ in Z) Object.prototype.hasOwnProperty.call(Z, $) && !Object.prototype.hasOwnProperty.call(F, $) && $ !== "layout" && $ !== "paint" && $ !== "filter" && $ !== "metadata" && $ !== "minzoom" && $ !== "maxzoom" && ($.indexOf("paint.") === 0 ? he(F[$], Z[$], g, D, $.slice(6), "setPaintProperty") : U(F[$], Z[$]) || X(g, { command: "setLayerProperty", args: [D, $, Z[$]] }));
              } else X(g, { command: "removeLayer", args: [D] }), Y = E[E.lastIndexOf(D) + 1], X(g, { command: "addLayer", args: [Z, Y] });
            }(d, t.layers, n);
          } catch (s) {
            console.warn("Unable to compute style diff:", s), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, z.c = nn, z.c0 = (r) => r.type === "heatmap", z.c1 = (r) => r.type === "line", z.c2 = (r) => r.type === "fill", z.c3 = (r) => r.type === "fill-extrusion", z.c4 = (r) => r.type === "hillshade", z.c5 = (r) => r.type === "raster", z.c6 = (r) => r.type === "background", z.c7 = (r) => r.type === "custom", z.c8 = En, z.c9 = function(r, t, n) {
          const s = as(t.x - n.x, t.y - n.y), l = as(r.x - n.x, r.y - n.y);
          var d, p;
          return Hi(Math.atan2(s[0] * l[1] - s[1] * l[0], (d = s)[0] * (p = l)[0] + d[1] * p[1]));
        }, z.cA = Ir, z.cB = hu, z.cC = wu, z.cD = gn, z.cE = Zr, z.ca = sr, z.cb = function(r, t, n) {
          var s = t[0], l = t[1];
          return r[0] = n[0] * s + n[4] * l + n[12], r[1] = n[1] * s + n[5] * l + n[13], r;
        }, z.cc = function(r, t) {
          const { x: n, y: s } = ol.fromLngLat(t);
          return !(r < 0 || r > 25 || s < 0 || s >= 1 || n < 0 || n >= 1);
        }, z.cd = function(r, t) {
          return r[0] = t[0], r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t[1], r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = t[2], r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
        }, z.ce = class extends va {
        }, z.cf = Wp, z.ch = function(r) {
          return r.message === An;
        }, z.ci = _r, z.cj = function(r, t) {
          sn.REGISTERED_PROTOCOLS[r] = t;
        }, z.ck = function(r) {
          delete sn.REGISTERED_PROTOCOLS[r];
        }, z.cl = function(r, t) {
          const n = {};
          for (let l = 0; l < r.length; l++) {
            const d = t && t[r[l].id] || Po(r[l]);
            t && (t[r[l].id] = d);
            let p = n[d];
            p || (p = n[d] = []), p.push(r[l]);
          }
          const s = [];
          for (const l in n) s.push(n[l]);
          return s;
        }, z.cm = Ae, z.cn = Wu, z.co = Xu, z.cp = Pu, z.cq = function(r) {
          r.bucket.createArrays(), r.bucket.tilePixelRatio = ht / (512 * r.bucket.overscaling), r.bucket.compareText = {}, r.bucket.iconsNeedLinear = !1;
          const t = r.bucket.layers[0], n = t.layout, s = t._unevaluatedLayout._values, l = { layoutIconSize: s["icon-size"].possiblyEvaluate(new Tt(r.bucket.zoom + 1), r.canonical), layoutTextSize: s["text-size"].possiblyEvaluate(new Tt(r.bucket.zoom + 1), r.canonical), textMaxSize: s["text-size"].possiblyEvaluate(new Tt(18)) };
          if (r.bucket.textSizeData.kind === "composite") {
            const { minZoom: x, maxZoom: b } = r.bucket.textSizeData;
            l.compositeTextSizes = [s["text-size"].possiblyEvaluate(new Tt(x), r.canonical), s["text-size"].possiblyEvaluate(new Tt(b), r.canonical)];
          }
          if (r.bucket.iconSizeData.kind === "composite") {
            const { minZoom: x, maxZoom: b } = r.bucket.iconSizeData;
            l.compositeIconSizes = [s["icon-size"].possiblyEvaluate(new Tt(x), r.canonical), s["icon-size"].possiblyEvaluate(new Tt(b), r.canonical)];
          }
          const d = n.get("text-line-height") * $t, p = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", m = n.get("text-keep-upright"), g = n.get("text-size");
          for (const x of r.bucket.features) {
            const b = n.get("text-font").evaluate(x, {}, r.canonical).join(","), w = g.evaluate(x, {}, r.canonical), I = l.layoutTextSize.evaluate(x, {}, r.canonical), E = l.layoutIconSize.evaluate(x, {}, r.canonical), A = { horizontal: {}, vertical: void 0 }, D = x.text;
            let F, Z = [0, 0];
            if (D) {
              const C = D.toString(), B = n.get("text-letter-spacing").evaluate(x, {}, r.canonical) * $t, q = Kl(C) ? B : 0, ae = n.get("text-anchor").evaluate(x, {}, r.canonical), ve = od(t, x, r.canonical);
              if (!ve) {
                const we = n.get("text-radial-offset").evaluate(x, {}, r.canonical);
                Z = we ? ad(ae, [we * $t, Ch]) : n.get("text-offset").evaluate(x, {}, r.canonical).map((Pe) => Pe * $t);
              }
              let ce = p ? "center" : n.get("text-justify").evaluate(x, {}, r.canonical);
              const de = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(x, {}, r.canonical) * $t : 1 / 0, Te = () => {
                r.bucket.allowVerticalPlacement && ma(C) && (A.vertical = fc(D, r.glyphMap, r.glyphPositions, r.imagePositions, b, de, d, ae, "left", q, Z, z.ag.vertical, !0, I, w));
              };
              if (!p && ve) {
                const we = /* @__PURE__ */ new Set();
                if (ce === "auto") for (let ge = 0; ge < ve.values.length; ge += 2) we.add(Eh(ve.values[ge]));
                else we.add(ce);
                let Pe = !1;
                for (const ge of we) if (!A.horizontal[ge]) if (Pe) A.horizontal[ge] = A.horizontal[0];
                else {
                  const ze = fc(D, r.glyphMap, r.glyphPositions, r.imagePositions, b, de, d, "center", ge, q, Z, z.ag.horizontal, !1, I, w);
                  ze && (A.horizontal[ge] = ze, Pe = ze.positionedLines.length === 1);
                }
                Te();
              } else {
                ce === "auto" && (ce = Eh(ae));
                const we = fc(D, r.glyphMap, r.glyphPositions, r.imagePositions, b, de, d, ae, ce, q, Z, z.ag.horizontal, !1, I, w);
                we && (A.horizontal[ce] = we), Te(), ma(C) && p && m && (A.vertical = fc(D, r.glyphMap, r.glyphPositions, r.imagePositions, b, de, d, ae, ce, q, Z, z.ag.vertical, !1, I, w));
              }
            }
            let Y = !1;
            if (x.icon && x.icon.name) {
              const C = r.imageMap[x.icon.name];
              C && (F = Cp(r.imagePositions[x.icon.name], n.get("icon-offset").evaluate(x, {}, r.canonical), n.get("icon-anchor").evaluate(x, {}, r.canonical)), Y = !!C.sdf, r.bucket.sdfIcons === void 0 ? r.bucket.sdfIcons = Y : r.bucket.sdfIcons !== Y && ci("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (C.pixelRatio !== r.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (r.bucket.iconsNeedLinear = !0));
            }
            const $ = cd(A.horizontal) || A.vertical;
            r.bucket.iconsInText = !!$ && $.iconsInText, ($ || F) && $p(r.bucket, x, A, F, r.imageMap, l, I, E, Z, Y, r.canonical, r.subdivisionGranularity);
          }
          r.showCollisionBoxes && r.bucket.generateCollisionDebugBuffers();
        }, z.cr = dh, z.cs = ah, z.ct = uh, z.cu = tl, z.cv = mh, z.cw = class {
          constructor(r) {
            this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let r = performance.getEntriesByName(this._marks.measure);
            return r.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), r = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), r;
          }
        }, z.cx = function(r, t, n, s, l) {
          return c(this, void 0, void 0, function* () {
            if (mi()) try {
              return yield Wi(r, t, n, s, l);
            } catch {
            }
            return function(d, p, m, g, x) {
              const b = d.width, w = d.height;
              kr && Dr || (kr = new OffscreenCanvas(b, w), Dr = kr.getContext("2d", { willReadFrequently: !0 })), kr.width = b, kr.height = w, Dr.drawImage(d, 0, 0, b, w);
              const I = Dr.getImageData(p, m, g, x);
              return Dr.clearRect(0, 0, b, w), I.data;
            }(r, t, n, s, l);
          });
        }, z.cy = qu, z.cz = fi, z.d = Lr, z.e = ii, z.f = (r) => c(void 0, void 0, void 0, function* () {
          if (r.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(r)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), z.g = zn, z.h = (r) => new Promise((t, n) => {
          const s = new Image();
          s.onload = () => {
            t(s), URL.revokeObjectURL(s.src), s.onload = null, window.requestAnimationFrame(() => {
              s.src = rn;
            });
          }, s.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const l = new Blob([new Uint8Array(r)], { type: "image/png" });
          s.src = r.byteLength ? URL.createObjectURL(l) : rn;
        }), z.i = mr, z.j = (r, t) => Rr(ii(r, { type: "json" }), t), z.k = yr, z.l = cs, z.m = Rr, z.n = (r, t) => Rr(ii(r, { type: "arrayBuffer" }), t), z.o = function(r) {
          return new mh(r).readFields(_p, []);
        }, z.p = Tu, z.q = Ho, z.r = wi, z.s = ar, z.t = Ts, z.u = Ye, z.v = P, z.w = ci, z.x = pa, z.y = Xn, z.z = function([r, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: r * Math.cos(t) * Math.sin(n), y: r * Math.sin(t) * Math.sin(n), z: r * Math.cos(n) };
        };
      }), mt("worker", ["./shared"], function(z) {
        class c {
          constructor(P) {
            this.keyCache = {}, P && this.replace(P);
          }
          replace(P) {
            this._layerConfigs = {}, this._layers = {}, this.update(P, []);
          }
          update(P, L) {
            for (const U of P) {
              this._layerConfigs[U.id] = U;
              const X = this._layers[U.id] = z.bx(U);
              X._featureFilter = z.a6(X.filter), this.keyCache[U.id] && delete this.keyCache[U.id];
            }
            for (const U of L) delete this.keyCache[U], delete this._layerConfigs[U], delete this._layers[U];
            this.familiesBySource = {};
            const O = z.cl(Object.values(this._layerConfigs), this.keyCache);
            for (const U of O) {
              const X = U.map((re) => this._layers[re.id]), te = X[0];
              if (te.visibility === "none") continue;
              const le = te.source || "";
              let ee = this.familiesBySource[le];
              ee || (ee = this.familiesBySource[le] = {});
              const me = te.sourceLayer || "_geojsonTileLayer";
              let he = ee[me];
              he || (he = ee[me] = []), he.push(X);
            }
          }
        }
        class fi {
          constructor(P) {
            const L = {}, O = [];
            for (const le in P) {
              const ee = P[le], me = L[le] = {};
              for (const he in ee) {
                const re = ee[+he];
                if (!re || re.bitmap.width === 0 || re.bitmap.height === 0) continue;
                const xe = { x: 0, y: 0, w: re.bitmap.width + 2, h: re.bitmap.height + 2 };
                O.push(xe), me[he] = { rect: xe, metrics: re.metrics };
              }
            }
            const { w: U, h: X } = z.p(O), te = new z.q({ width: U || 1, height: X || 1 });
            for (const le in P) {
              const ee = P[le];
              for (const me in ee) {
                const he = ee[+me];
                if (!he || he.bitmap.width === 0 || he.bitmap.height === 0) continue;
                const re = L[le][me].rect;
                z.q.copy(he.bitmap, te, { x: 0, y: 0 }, { x: re.x + 1, y: re.y + 1 }, he.bitmap);
              }
            }
            this.image = te, this.positions = L;
          }
        }
        z.cm("GlyphAtlas", fi);
        class Mr {
          constructor(P) {
            this.tileID = new z.Y(P.tileID.overscaledZ, P.tileID.wrap, P.tileID.canonical.z, P.tileID.canonical.x, P.tileID.canonical.y), this.uid = P.uid, this.zoom = P.zoom, this.pixelRatio = P.pixelRatio, this.tileSize = P.tileSize, this.source = P.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = P.showCollisionBoxes, this.collectResourceTiming = !!P.collectResourceTiming, this.returnDependencies = !!P.returnDependencies, this.promoteId = P.promoteId, this.inFlightDependencies = [];
          }
          parse(P, L, O, U, X) {
            return z._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = P, this.collisionBoxArray = new z.a4();
              const te = new z.cn(Object.keys(P.layers).sort()), le = new z.co(this.tileID, this.promoteId);
              le.bucketLayerIDs = [];
              const ee = {}, me = { featureIndex: le, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: O, subdivisionGranularity: X }, he = L.familiesBySource[this.source];
              for (const qe in he) {
                const Je = P.layers[qe];
                if (!Je) continue;
                Je.version === 1 && z.w(`Vector tile source "${this.source}" layer "${qe}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const je = te.encode(qe), on = [];
                for (let Ft = 0; Ft < Je.length; Ft++) {
                  const Nt = Je.feature(Ft), yt = le.getId(Nt, qe);
                  on.push({ feature: Nt, id: yt, index: Ft, sourceLayerIndex: je });
                }
                for (const Ft of he[qe]) {
                  const Nt = Ft[0];
                  Nt.source !== this.source && z.w(`layer.source = ${Nt.source} does not equal this.source = ${this.source}`), Nt.minzoom && this.zoom < Math.floor(Nt.minzoom) || Nt.maxzoom && this.zoom >= Nt.maxzoom || Nt.visibility !== "none" && (ki(Ft, this.zoom, O), (ee[Nt.id] = Nt.createBucket({ index: le.bucketLayerIDs.length, layers: Ft, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: je, sourceID: this.source })).populate(on, me, this.tileID.canonical), le.bucketLayerIDs.push(Ft.map((yt) => yt.id)));
                }
              }
              const re = z.bC(me.glyphDependencies, (qe) => Object.keys(qe).map(Number));
              this.inFlightDependencies.forEach((qe) => qe == null ? void 0 : qe.abort()), this.inFlightDependencies = [];
              let xe = Promise.resolve({});
              if (Object.keys(re).length) {
                const qe = new AbortController();
                this.inFlightDependencies.push(qe), xe = U.sendAsync({ type: "GG", data: { stacks: re, source: this.source, tileID: this.tileID, type: "glyphs" } }, qe);
              }
              const ne = Object.keys(me.iconDependencies);
              let Ce = Promise.resolve({});
              if (ne.length) {
                const qe = new AbortController();
                this.inFlightDependencies.push(qe), Ce = U.sendAsync({ type: "GI", data: { icons: ne, source: this.source, tileID: this.tileID, type: "icons" } }, qe);
              }
              const Be = Object.keys(me.patternDependencies);
              let We = Promise.resolve({});
              if (Be.length) {
                const qe = new AbortController();
                this.inFlightDependencies.push(qe), We = U.sendAsync({ type: "GI", data: { icons: Be, source: this.source, tileID: this.tileID, type: "patterns" } }, qe);
              }
              const [$e, ye, De] = yield Promise.all([xe, Ce, We]), ke = new fi($e), Ke = new z.cp(ye, De);
              for (const qe in ee) {
                const Je = ee[qe];
                Je instanceof z.a5 ? (ki(Je.layers, this.zoom, O), z.cq({ bucket: Je, glyphMap: $e, glyphPositions: ke.positions, imageMap: ye, imagePositions: Ke.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: me.subdivisionGranularity })) : Je.hasPattern && (Je instanceof z.cr || Je instanceof z.cs || Je instanceof z.ct) && (ki(Je.layers, this.zoom, O), Je.addFeatures(me, this.tileID.canonical, Ke.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(ee).filter((qe) => !qe.isEmpty()), featureIndex: le, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ke.image, imageAtlas: Ke, glyphMap: this.returnDependencies ? $e : null, iconMap: this.returnDependencies ? ye : null, glyphPositions: this.returnDependencies ? ke.positions : null };
            });
          }
        }
        function ki(ie, P, L) {
          const O = new z.C(P);
          for (const U of ie) U.recalculate(O, L);
        }
        class Ir {
          constructor(P, L, O) {
            this.actor = P, this.layerIndex = L, this.availableImages = O, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(P, L) {
            return z._(this, void 0, void 0, function* () {
              const O = yield z.n(P.request, L);
              try {
                return { vectorTile: new z.cu.VectorTile(new z.cv(O.data)), rawData: O.data, cacheControl: O.cacheControl, expires: O.expires };
              } catch (U) {
                const X = new Uint8Array(O.data);
                let te = `Unable to parse the tile at ${P.request.url}, `;
                throw te += X[0] === 31 && X[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${U.message}`, new Error(te);
              }
            });
          }
          loadTile(P) {
            return z._(this, void 0, void 0, function* () {
              const L = P.uid, O = !!(P && P.request && P.request.collectResourceTiming) && new z.cw(P.request), U = new Mr(P);
              this.loading[L] = U;
              const X = new AbortController();
              U.abort = X;
              try {
                const te = yield this.loadVectorTile(P, X);
                if (delete this.loading[L], !te) return null;
                const le = te.rawData, ee = {};
                te.expires && (ee.expires = te.expires), te.cacheControl && (ee.cacheControl = te.cacheControl);
                const me = {};
                if (O) {
                  const re = O.finish();
                  re && (me.resourceTiming = JSON.parse(JSON.stringify(re)));
                }
                U.vectorTile = te.vectorTile;
                const he = U.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor, P.subdivisionGranularity);
                this.loaded[L] = U, this.fetching[L] = { rawTileData: le, cacheControl: ee, resourceTiming: me };
                try {
                  const re = yield he;
                  return z.e({ rawTileData: le.slice(0) }, re, ee, me);
                } finally {
                  delete this.fetching[L];
                }
              } catch (te) {
                throw delete this.loading[L], U.status = "done", this.loaded[L] = U, te;
              }
            });
          }
          reloadTile(P) {
            return z._(this, void 0, void 0, function* () {
              const L = P.uid;
              if (!this.loaded || !this.loaded[L]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const O = this.loaded[L];
              if (O.showCollisionBoxes = P.showCollisionBoxes, O.status === "parsing") {
                const U = yield O.parse(O.vectorTile, this.layerIndex, this.availableImages, this.actor, P.subdivisionGranularity);
                let X;
                if (this.fetching[L]) {
                  const { rawTileData: te, cacheControl: le, resourceTiming: ee } = this.fetching[L];
                  delete this.fetching[L], X = z.e({ rawTileData: te.slice(0) }, U, le, ee);
                } else X = U;
                return X;
              }
              if (O.status === "done" && O.vectorTile) return O.parse(O.vectorTile, this.layerIndex, this.availableImages, this.actor, P.subdivisionGranularity);
            });
          }
          abortTile(P) {
            return z._(this, void 0, void 0, function* () {
              const L = this.loading, O = P.uid;
              L && L[O] && L[O].abort && (L[O].abort.abort(), delete L[O]);
            });
          }
          removeTile(P) {
            return z._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[P.uid] && delete this.loaded[P.uid];
            });
          }
        }
        class He {
          constructor() {
            this.loaded = {};
          }
          loadTile(P) {
            return z._(this, void 0, void 0, function* () {
              const { uid: L, encoding: O, rawImageData: U, redFactor: X, greenFactor: te, blueFactor: le, baseShift: ee } = P, me = U.width + 2, he = U.height + 2, re = z.b(U) ? new z.R({ width: me, height: he }, yield z.cx(U, -1, -1, me, he)) : U, xe = new z.cy(L, re, O, X, te, le, ee);
              return this.loaded = this.loaded || {}, this.loaded[L] = xe, xe;
            });
          }
          removeTile(P) {
            const L = this.loaded, O = P.uid;
            L && L[O] && delete L[O];
          }
        }
        var ue, Ue, Wr = function() {
          if (Ue) return ue;
          function ie(L, O) {
            if (L.length !== 0) {
              P(L[0], O);
              for (var U = 1; U < L.length; U++) P(L[U], !O);
            }
          }
          function P(L, O) {
            for (var U = 0, X = 0, te = 0, le = L.length, ee = le - 1; te < le; ee = te++) {
              var me = (L[te][0] - L[ee][0]) * (L[ee][1] + L[te][1]), he = U + me;
              X += Math.abs(U) >= Math.abs(me) ? U - he + me : me - he + U, U = he;
            }
            U + X >= 0 != !!O && L.reverse();
          }
          return Ue = 1, ue = function L(O, U) {
            var X, te = O && O.type;
            if (te === "FeatureCollection") for (X = 0; X < O.features.length; X++) L(O.features[X], U);
            else if (te === "GeometryCollection") for (X = 0; X < O.geometries.length; X++) L(O.geometries[X], U);
            else if (te === "Feature") L(O.geometry, U);
            else if (te === "Polygon") ie(O.coordinates, U);
            else if (te === "MultiPolygon") for (X = 0; X < O.coordinates.length; X++) ie(O.coordinates[X], U);
            return O;
          };
        }(), Cr = z.cz(Wr);
        const Hr = z.cu.VectorTileFeature.prototype.toGeoJSON;
        class Xr {
          constructor(P) {
            this._feature = P, this.extent = z.Z, this.type = P.type, this.properties = P.tags, "id" in P && !isNaN(P.id) && (this.id = parseInt(P.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const P = [];
              for (const L of this._feature.geometry) P.push([new z.P(L[0], L[1])]);
              return P;
            }
            {
              const P = [];
              for (const L of this._feature.geometry) {
                const O = [];
                for (const U of L) O.push(new z.P(U[0], U[1]));
                P.push(O);
              }
              return P;
            }
          }
          toGeoJSON(P, L, O) {
            return Hr.call(this, P, L, O);
          }
        }
        class ns {
          constructor(P) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = z.Z, this.length = P.length, this._features = P;
          }
          feature(P) {
            return new Xr(this._features[P]);
          }
        }
        var mi, Er, Mt, bt = { exports: {} }, zt = function() {
          if (Mt) return bt.exports;
          Mt = 1;
          var ie = z.cC(), P = function() {
            if (Er) return mi;
            Er = 1;
            var he = z.cA(), re = z.cB().VectorTileFeature;
            function xe(Ce, Be) {
              this.options = Be || {}, this.features = Ce, this.length = Ce.length;
            }
            function ne(Ce, Be) {
              this.id = typeof Ce.id == "number" ? Ce.id : void 0, this.type = Ce.type, this.rawGeometry = Ce.type === 1 ? [Ce.geometry] : Ce.geometry, this.properties = Ce.tags, this.extent = Be || 4096;
            }
            return mi = xe, xe.prototype.feature = function(Ce) {
              return new ne(this.features[Ce], this.options.extent);
            }, ne.prototype.loadGeometry = function() {
              var Ce = this.rawGeometry;
              this.geometry = [];
              for (var Be = 0; Be < Ce.length; Be++) {
                for (var We = Ce[Be], $e = [], ye = 0; ye < We.length; ye++) $e.push(new he(We[ye][0], We[ye][1]));
                this.geometry.push($e);
              }
              return this.geometry;
            }, ne.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var Ce = this.geometry, Be = 1 / 0, We = -1 / 0, $e = 1 / 0, ye = -1 / 0, De = 0; De < Ce.length; De++) for (var ke = Ce[De], Ke = 0; Ke < ke.length; Ke++) {
                var qe = ke[Ke];
                Be = Math.min(Be, qe.x), We = Math.max(We, qe.x), $e = Math.min($e, qe.y), ye = Math.max(ye, qe.y);
              }
              return [Be, $e, We, ye];
            }, ne.prototype.toGeoJSON = re.prototype.toGeoJSON, mi;
          }();
          function L(he) {
            var re = new ie();
            return function(xe, ne) {
              for (var Ce in xe.layers) ne.writeMessage(3, O, xe.layers[Ce]);
            }(he, re), re.finish();
          }
          function O(he, re) {
            var xe;
            re.writeVarintField(15, he.version || 1), re.writeStringField(1, he.name || ""), re.writeVarintField(5, he.extent || 4096);
            var ne = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (xe = 0; xe < he.length; xe++) ne.feature = he.feature(xe), re.writeMessage(2, U, ne);
            var Ce = ne.keys;
            for (xe = 0; xe < Ce.length; xe++) re.writeStringField(3, Ce[xe]);
            var Be = ne.values;
            for (xe = 0; xe < Be.length; xe++) re.writeMessage(4, me, Be[xe]);
          }
          function U(he, re) {
            var xe = he.feature;
            xe.id !== void 0 && re.writeVarintField(1, xe.id), re.writeMessage(2, X, he), re.writeVarintField(3, xe.type), re.writeMessage(4, ee, xe);
          }
          function X(he, re) {
            var xe = he.feature, ne = he.keys, Ce = he.values, Be = he.keycache, We = he.valuecache;
            for (var $e in xe.properties) {
              var ye = xe.properties[$e], De = Be[$e];
              if (ye !== null) {
                De === void 0 && (ne.push($e), Be[$e] = De = ne.length - 1), re.writeVarint(De);
                var ke = typeof ye;
                ke !== "string" && ke !== "boolean" && ke !== "number" && (ye = JSON.stringify(ye));
                var Ke = ke + ":" + ye, qe = We[Ke];
                qe === void 0 && (Ce.push(ye), We[Ke] = qe = Ce.length - 1), re.writeVarint(qe);
              }
            }
          }
          function te(he, re) {
            return (re << 3) + (7 & he);
          }
          function le(he) {
            return he << 1 ^ he >> 31;
          }
          function ee(he, re) {
            for (var xe = he.loadGeometry(), ne = he.type, Ce = 0, Be = 0, We = xe.length, $e = 0; $e < We; $e++) {
              var ye = xe[$e], De = 1;
              ne === 1 && (De = ye.length), re.writeVarint(te(1, De));
              for (var ke = ne === 3 ? ye.length - 1 : ye.length, Ke = 0; Ke < ke; Ke++) {
                Ke === 1 && ne !== 1 && re.writeVarint(te(2, ke - 1));
                var qe = ye[Ke].x - Ce, Je = ye[Ke].y - Be;
                re.writeVarint(le(qe)), re.writeVarint(le(Je)), Ce += qe, Be += Je;
              }
              ne === 3 && re.writeVarint(te(7, 1));
            }
          }
          function me(he, re) {
            var xe = typeof he;
            xe === "string" ? re.writeStringField(1, he) : xe === "boolean" ? re.writeBooleanField(7, he) : xe === "number" && (he % 1 != 0 ? re.writeDoubleField(3, he) : he < 0 ? re.writeSVarintField(6, he) : re.writeVarintField(5, he));
          }
          return bt.exports = L, bt.exports.fromVectorTileJs = L, bt.exports.fromGeojsonVt = function(he, re) {
            re = re || {};
            var xe = {};
            for (var ne in he) xe[ne] = new P(he[ne].features, re), xe[ne].name = ne, xe[ne].version = re.version, xe[ne].extent = re.extent;
            return L({ layers: xe });
          }, bt.exports.GeoJSONWrapper = P, bt.exports;
        }(), ss = z.cz(zt);
        const Bs = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ie) => ie }, Ar = Math.fround || (fr = new Float32Array(1), (ie) => (fr[0] = +ie, fr[0]));
        var fr;
        const Di = 3, li = 5, as = 6;
        class ht {
          constructor(P) {
            this.options = Object.assign(Object.create(Bs), P), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(P) {
            const { log: L, minZoom: O, maxZoom: U } = this.options;
            L && console.time("total time");
            const X = `prepare ${P.length} points`;
            L && console.time(X), this.points = P;
            const te = [];
            for (let ee = 0; ee < P.length; ee++) {
              const me = P[ee];
              if (!me.geometry) continue;
              const [he, re] = me.geometry.coordinates, xe = Ar(Kr(he)), ne = Ar(Jr(re));
              te.push(xe, ne, 1 / 0, ee, -1, 1), this.options.reduce && te.push(0);
            }
            let le = this.trees[U + 1] = this._createTree(te);
            L && console.timeEnd(X);
            for (let ee = U; ee >= O; ee--) {
              const me = +Date.now();
              le = this.trees[ee] = this._createTree(this._cluster(le, ee)), L && console.log("z%d: %d clusters in %dms", ee, le.numItems, +Date.now() - me);
            }
            return L && console.timeEnd("total time"), this;
          }
          getClusters(P, L) {
            let O = ((P[0] + 180) % 360 + 360) % 360 - 180;
            const U = Math.max(-90, Math.min(90, P[1]));
            let X = P[2] === 180 ? 180 : ((P[2] + 180) % 360 + 360) % 360 - 180;
            const te = Math.max(-90, Math.min(90, P[3]));
            if (P[2] - P[0] >= 360) O = -180, X = 180;
            else if (O > X) {
              const re = this.getClusters([O, U, 180, te], L), xe = this.getClusters([-180, U, X, te], L);
              return re.concat(xe);
            }
            const le = this.trees[this._limitZoom(L)], ee = le.range(Kr(O), Jr(te), Kr(X), Jr(U)), me = le.data, he = [];
            for (const re of ee) {
              const xe = this.stride * re;
              he.push(me[xe + li] > 1 ? Cn(me, xe, this.clusterProps) : this.points[me[xe + Di]]);
            }
            return he;
          }
          getChildren(P) {
            const L = this._getOriginId(P), O = this._getOriginZoom(P), U = "No cluster with the specified id.", X = this.trees[O];
            if (!X) throw new Error(U);
            const te = X.data;
            if (L * this.stride >= te.length) throw new Error(U);
            const le = this.options.radius / (this.options.extent * Math.pow(2, O - 1)), ee = X.within(te[L * this.stride], te[L * this.stride + 1], le), me = [];
            for (const he of ee) {
              const re = he * this.stride;
              te[re + 4] === P && me.push(te[re + li] > 1 ? Cn(te, re, this.clusterProps) : this.points[te[re + Di]]);
            }
            if (me.length === 0) throw new Error(U);
            return me;
          }
          getLeaves(P, L, O) {
            const U = [];
            return this._appendLeaves(U, P, L = L || 10, O = O || 0, 0), U;
          }
          getTile(P, L, O) {
            const U = this.trees[this._limitZoom(P)], X = Math.pow(2, P), { extent: te, radius: le } = this.options, ee = le / te, me = (O - ee) / X, he = (O + 1 + ee) / X, re = { features: [] };
            return this._addTileFeatures(U.range((L - ee) / X, me, (L + 1 + ee) / X, he), U.data, L, O, X, re), L === 0 && this._addTileFeatures(U.range(1 - ee / X, me, 1, he), U.data, X, O, X, re), L === X - 1 && this._addTileFeatures(U.range(0, me, ee / X, he), U.data, -1, O, X, re), re.features.length ? re : null;
          }
          getClusterExpansionZoom(P) {
            let L = this._getOriginZoom(P) - 1;
            for (; L <= this.options.maxZoom; ) {
              const O = this.getChildren(P);
              if (L++, O.length !== 1) break;
              P = O[0].properties.cluster_id;
            }
            return L;
          }
          _appendLeaves(P, L, O, U, X) {
            const te = this.getChildren(L);
            for (const le of te) {
              const ee = le.properties;
              if (ee && ee.cluster ? X + ee.point_count <= U ? X += ee.point_count : X = this._appendLeaves(P, ee.cluster_id, O, U, X) : X < U ? X++ : P.push(le), P.length === O) break;
            }
            return X;
          }
          _createTree(P) {
            const L = new z.aB(P.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let O = 0; O < P.length; O += this.stride) L.add(P[O], P[O + 1]);
            return L.finish(), L.data = P, L;
          }
          _addTileFeatures(P, L, O, U, X, te) {
            for (const le of P) {
              const ee = le * this.stride, me = L[ee + li] > 1;
              let he, re, xe;
              if (me) he = zr(L, ee, this.clusterProps), re = L[ee], xe = L[ee + 1];
              else {
                const Be = this.points[L[ee + Di]];
                he = Be.properties;
                const [We, $e] = Be.geometry.coordinates;
                re = Kr(We), xe = Jr($e);
              }
              const ne = { type: 1, geometry: [[Math.round(this.options.extent * (re * X - O)), Math.round(this.options.extent * (xe * X - U))]], tags: he };
              let Ce;
              Ce = me || this.options.generateId ? L[ee + Di] : this.points[L[ee + Di]].id, Ce !== void 0 && (ne.id = Ce), te.features.push(ne);
            }
          }
          _limitZoom(P) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+P), this.options.maxZoom + 1));
          }
          _cluster(P, L) {
            const { radius: O, extent: U, reduce: X, minPoints: te } = this.options, le = O / (U * Math.pow(2, L)), ee = P.data, me = [], he = this.stride;
            for (let re = 0; re < ee.length; re += he) {
              if (ee[re + 2] <= L) continue;
              ee[re + 2] = L;
              const xe = ee[re], ne = ee[re + 1], Ce = P.within(ee[re], ee[re + 1], le), Be = ee[re + li];
              let We = Be;
              for (const $e of Ce) {
                const ye = $e * he;
                ee[ye + 2] > L && (We += ee[ye + li]);
              }
              if (We > Be && We >= te) {
                let $e, ye = xe * Be, De = ne * Be, ke = -1;
                const Ke = ((re / he | 0) << 5) + (L + 1) + this.points.length;
                for (const qe of Ce) {
                  const Je = qe * he;
                  if (ee[Je + 2] <= L) continue;
                  ee[Je + 2] = L;
                  const je = ee[Je + li];
                  ye += ee[Je] * je, De += ee[Je + 1] * je, ee[Je + 4] = Ke, X && ($e || ($e = this._map(ee, re, !0), ke = this.clusterProps.length, this.clusterProps.push($e)), X($e, this._map(ee, Je)));
                }
                ee[re + 4] = Ke, me.push(ye / We, De / We, 1 / 0, Ke, -1, We), X && me.push(ke);
              } else {
                for (let $e = 0; $e < he; $e++) me.push(ee[re + $e]);
                if (We > 1) for (const $e of Ce) {
                  const ye = $e * he;
                  if (!(ee[ye + 2] <= L)) {
                    ee[ye + 2] = L;
                    for (let De = 0; De < he; De++) me.push(ee[ye + De]);
                  }
                }
              }
            }
            return me;
          }
          _getOriginId(P) {
            return P - this.points.length >> 5;
          }
          _getOriginZoom(P) {
            return (P - this.points.length) % 32;
          }
          _map(P, L, O) {
            if (P[L + li] > 1) {
              const te = this.clusterProps[P[L + as]];
              return O ? Object.assign({}, te) : te;
            }
            const U = this.points[P[L + Di]].properties, X = this.options.map(U);
            return O && X === U ? Object.assign({}, X) : X;
          }
        }
        function Cn(ie, P, L) {
          return { type: "Feature", id: ie[P + Di], properties: zr(ie, P, L), geometry: { type: "Point", coordinates: [(O = ie[P], 360 * (O - 0.5)), En(ie[P + 1])] } };
          var O;
        }
        function zr(ie, P, L) {
          const O = ie[P + li], U = O >= 1e4 ? `${Math.round(O / 1e3)}k` : O >= 1e3 ? Math.round(O / 100) / 10 + "k" : O, X = ie[P + as], te = X === -1 ? {} : Object.assign({}, L[X]);
          return Object.assign(te, { cluster: !0, cluster_id: ie[P + Di], point_count: O, point_count_abbreviated: U });
        }
        function Kr(ie) {
          return ie / 360 + 0.5;
        }
        function Jr(ie) {
          const P = Math.sin(ie * Math.PI / 180), L = 0.5 - 0.25 * Math.log((1 + P) / (1 - P)) / Math.PI;
          return L < 0 ? 0 : L > 1 ? 1 : L;
        }
        function En(ie) {
          const P = (180 - 360 * ie) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(P)) / Math.PI - 90;
        }
        function sr(ie, P, L, O) {
          let U = O;
          const X = P + (L - P >> 1);
          let te, le = L - P;
          const ee = ie[P], me = ie[P + 1], he = ie[L], re = ie[L + 1];
          for (let xe = P + 3; xe < L; xe += 3) {
            const ne = qi(ie[xe], ie[xe + 1], ee, me, he, re);
            if (ne > U) te = xe, U = ne;
            else if (ne === U) {
              const Ce = Math.abs(xe - X);
              Ce < le && (te = xe, le = Ce);
            }
          }
          U > O && (te - P > 3 && sr(ie, P, te, O), ie[te + 2] = U, L - te > 3 && sr(ie, te, L, O));
        }
        function qi(ie, P, L, O, U, X) {
          let te = U - L, le = X - O;
          if (te !== 0 || le !== 0) {
            const ee = ((ie - L) * te + (P - O) * le) / (te * te + le * le);
            ee > 1 ? (L = U, O = X) : ee > 0 && (L += te * ee, O += le * ee);
          }
          return te = ie - L, le = P - O, te * te + le * le;
        }
        function Ri(ie, P, L, O) {
          const U = { id: ie ?? null, type: P, geometry: L, tags: O, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (P === "Point" || P === "MultiPoint" || P === "LineString") ii(U, L);
          else if (P === "Polygon") ii(U, L[0]);
          else if (P === "MultiLineString") for (const X of L) ii(U, X);
          else if (P === "MultiPolygon") for (const X of L) ii(U, X[0]);
          return U;
        }
        function ii(ie, P) {
          for (let L = 0; L < P.length; L += 3) ie.minX = Math.min(ie.minX, P[L]), ie.minY = Math.min(ie.minY, P[L + 1]), ie.maxX = Math.max(ie.maxX, P[L]), ie.maxY = Math.max(ie.maxY, P[L + 1]);
        }
        function Yr(ie, P, L, O) {
          if (!P.geometry) return;
          const U = P.geometry.coordinates;
          if (U && U.length === 0) return;
          const X = P.geometry.type, te = Math.pow(L.tolerance / ((1 << L.maxZoom) * L.extent), 2);
          let le = [], ee = P.id;
          if (L.promoteId ? ee = P.properties[L.promoteId] : L.generateId && (ee = O || 0), X === "Point") Qr(U, le);
          else if (X === "MultiPoint") for (const me of U) Qr(me, le);
          else if (X === "LineString") en(U, le, te, !1);
          else if (X === "MultiLineString") {
            if (L.lineMetrics) {
              for (const me of U) le = [], en(me, le, te, !1), ie.push(Ri(ee, "LineString", le, P.properties));
              return;
            }
            Pi(U, le, te, !1);
          } else if (X === "Polygon") Pi(U, le, te, !0);
          else {
            if (X !== "MultiPolygon") {
              if (X === "GeometryCollection") {
                for (const me of P.geometry.geometries) Yr(ie, { id: ee, geometry: me, properties: P.properties }, L, O);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const me of U) {
              const he = [];
              Pi(me, he, te, !0), le.push(he);
            }
          }
          ie.push(Ri(ee, X, le, P.properties));
        }
        function Qr(ie, P) {
          P.push(os(ie[0]), ci(ie[1]), 0);
        }
        function en(ie, P, L, O) {
          let U, X, te = 0;
          for (let ee = 0; ee < ie.length; ee++) {
            const me = os(ie[ee][0]), he = ci(ie[ee][1]);
            P.push(me, he, 0), ee > 0 && (te += O ? (U * he - me * X) / 2 : Math.sqrt(Math.pow(me - U, 2) + Math.pow(he - X, 2))), U = me, X = he;
          }
          const le = P.length - 3;
          P[2] = 1, sr(P, 0, le, L), P[le + 2] = 1, P.size = Math.abs(te), P.start = 0, P.end = P.size;
        }
        function Pi(ie, P, L, O) {
          for (let U = 0; U < ie.length; U++) {
            const X = [];
            en(ie[U], X, L, O), P.push(X);
          }
        }
        function os(ie) {
          return ie / 360 + 0.5;
        }
        function ci(ie) {
          const P = Math.sin(ie * Math.PI / 180), L = 0.5 - 0.25 * Math.log((1 + P) / (1 - P)) / Math.PI;
          return L < 0 ? 0 : L > 1 ? 1 : L;
        }
        function Vt(ie, P, L, O, U, X, te, le) {
          if (O /= P, X >= (L /= P) && te < O) return ie;
          if (te < L || X >= O) return null;
          const ee = [];
          for (const me of ie) {
            const he = me.geometry;
            let re = me.type;
            const xe = U === 0 ? me.minX : me.minY, ne = U === 0 ? me.maxX : me.maxY;
            if (xe >= L && ne < O) {
              ee.push(me);
              continue;
            }
            if (ne < L || xe >= O) continue;
            let Ce = [];
            if (re === "Point" || re === "MultiPoint") mr(he, Ce, L, O, U);
            else if (re === "LineString") Dt(he, Ce, L, O, U, !1, le.lineMetrics);
            else if (re === "MultiLineString") rn(he, Ce, L, O, U, !1);
            else if (re === "Polygon") rn(he, Ce, L, O, U, !0);
            else if (re === "MultiPolygon") for (const Be of he) {
              const We = [];
              rn(Be, We, L, O, U, !0), We.length && Ce.push(We);
            }
            if (Ce.length) {
              if (le.lineMetrics && re === "LineString") {
                for (const Be of Ce) ee.push(Ri(me.id, re, Be, me.tags));
                continue;
              }
              re !== "LineString" && re !== "MultiLineString" || (Ce.length === 1 ? (re = "LineString", Ce = Ce[0]) : re = "MultiLineString"), re !== "Point" && re !== "MultiPoint" || (re = Ce.length === 3 ? "Point" : "MultiPoint"), ee.push(Ri(me.id, re, Ce, me.tags));
            }
          }
          return ee.length ? ee : null;
        }
        function mr(ie, P, L, O, U) {
          for (let X = 0; X < ie.length; X += 3) {
            const te = ie[X + U];
            te >= L && te <= O && Wi(P, ie[X], ie[X + 1], ie[X + 2]);
          }
        }
        function Dt(ie, P, L, O, U, X, te) {
          let le = tn(ie);
          const ee = U === 0 ? kr : Dr;
          let me, he, re = ie.start;
          for (let We = 0; We < ie.length - 3; We += 3) {
            const $e = ie[We], ye = ie[We + 1], De = ie[We + 2], ke = ie[We + 3], Ke = ie[We + 4], qe = U === 0 ? $e : ye, Je = U === 0 ? ke : Ke;
            let je = !1;
            te && (me = Math.sqrt(Math.pow($e - ke, 2) + Math.pow(ye - Ke, 2))), qe < L ? Je > L && (he = ee(le, $e, ye, ke, Ke, L), te && (le.start = re + me * he)) : qe > O ? Je < O && (he = ee(le, $e, ye, ke, Ke, O), te && (le.start = re + me * he)) : Wi(le, $e, ye, De), Je < L && qe >= L && (he = ee(le, $e, ye, ke, Ke, L), je = !0), Je > O && qe <= O && (he = ee(le, $e, ye, ke, Ke, O), je = !0), !X && je && (te && (le.end = re + me * he), P.push(le), le = tn(ie)), te && (re += me);
          }
          let xe = ie.length - 3;
          const ne = ie[xe], Ce = ie[xe + 1], Be = U === 0 ? ne : Ce;
          Be >= L && Be <= O && Wi(le, ne, Ce, ie[xe + 2]), xe = le.length - 3, X && xe >= 3 && (le[xe] !== le[0] || le[xe + 1] !== le[1]) && Wi(le, le[0], le[1], le[2]), le.length && P.push(le);
        }
        function tn(ie) {
          const P = [];
          return P.size = ie.size, P.start = ie.start, P.end = ie.end, P;
        }
        function rn(ie, P, L, O, U, X) {
          for (const te of ie) Dt(te, P, L, O, U, X, !1);
        }
        function Wi(ie, P, L, O) {
          ie.push(P, L, O);
        }
        function kr(ie, P, L, O, U, X) {
          const te = (X - P) / (O - P);
          return Wi(ie, X, L + (U - L) * te, 1), te;
        }
        function Dr(ie, P, L, O, U, X) {
          const te = (X - L) / (U - L);
          return Wi(ie, P + (O - P) * te, X, 1), te;
        }
        function ar(ie, P) {
          const L = [];
          for (let O = 0; O < ie.length; O++) {
            const U = ie[O], X = U.type;
            let te;
            if (X === "Point" || X === "MultiPoint" || X === "LineString") te = Hi(U.geometry, P);
            else if (X === "MultiLineString" || X === "Polygon") {
              te = [];
              for (const le of U.geometry) te.push(Hi(le, P));
            } else if (X === "MultiPolygon") {
              te = [];
              for (const le of U.geometry) {
                const ee = [];
                for (const me of le) ee.push(Hi(me, P));
                te.push(ee);
              }
            }
            L.push(Ri(U.id, X, te, U.tags));
          }
          return L;
        }
        function Hi(ie, P) {
          const L = [];
          L.size = ie.size, ie.start !== void 0 && (L.start = ie.start, L.end = ie.end);
          for (let O = 0; O < ie.length; O += 3) L.push(ie[O] + P, ie[O + 1], ie[O + 2]);
          return L;
        }
        function An(ie, P) {
          if (ie.transformed) return ie;
          const L = 1 << ie.z, O = ie.x, U = ie.y;
          for (const X of ie.features) {
            const te = X.geometry, le = X.type;
            if (X.geometry = [], le === 1) for (let ee = 0; ee < te.length; ee += 2) X.geometry.push(nn(te[ee], te[ee + 1], P, L, O, U));
            else for (let ee = 0; ee < te.length; ee++) {
              const me = [];
              for (let he = 0; he < te[ee].length; he += 2) me.push(nn(te[ee][he], te[ee][he + 1], P, L, O, U));
              X.geometry.push(me);
            }
          }
          return ie.transformed = !0, ie;
        }
        function nn(ie, P, L, O, U, X) {
          return [Math.round(L * (ie * O - U)), Math.round(L * (P * O - X))];
        }
        function sn(ie, P, L, O, U) {
          const X = P === U.maxZoom ? 0 : U.tolerance / ((1 << P) * U.extent), te = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ie.length, source: null, x: L, y: O, z: P, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const le of ie) zn(te, le, X, U);
          return te;
        }
        function zn(ie, P, L, O) {
          const U = P.geometry, X = P.type, te = [];
          if (ie.minX = Math.min(ie.minX, P.minX), ie.minY = Math.min(ie.minY, P.minY), ie.maxX = Math.max(ie.maxX, P.maxX), ie.maxY = Math.max(ie.maxY, P.maxY), X === "Point" || X === "MultiPoint") for (let le = 0; le < U.length; le += 3) te.push(U[le], U[le + 1]), ie.numPoints++, ie.numSimplified++;
          else if (X === "LineString") an(te, U, ie, L, !1, !1);
          else if (X === "MultiLineString" || X === "Polygon") for (let le = 0; le < U.length; le++) an(te, U[le], ie, L, X === "Polygon", le === 0);
          else if (X === "MultiPolygon") for (let le = 0; le < U.length; le++) {
            const ee = U[le];
            for (let me = 0; me < ee.length; me++) an(te, ee[me], ie, L, !0, me === 0);
          }
          if (te.length) {
            let le = P.tags || null;
            if (X === "LineString" && O.lineMetrics) {
              le = {};
              for (const me in P.tags) le[me] = P.tags[me];
              le.mapbox_clip_start = U.start / U.size, le.mapbox_clip_end = U.end / U.size;
            }
            const ee = { geometry: te, type: X === "Polygon" || X === "MultiPolygon" ? 3 : X === "LineString" || X === "MultiLineString" ? 2 : 1, tags: le };
            P.id !== null && (ee.id = P.id), ie.features.push(ee);
          }
        }
        function an(ie, P, L, O, U, X) {
          const te = O * O;
          if (O > 0 && P.size < (U ? te : O)) return void (L.numPoints += P.length / 3);
          const le = [];
          for (let ee = 0; ee < P.length; ee += 3) (O === 0 || P[ee + 2] > te) && (L.numSimplified++, le.push(P[ee], P[ee + 1])), L.numPoints++;
          U && function(ee, me) {
            let he = 0;
            for (let re = 0, xe = ee.length, ne = xe - 2; re < xe; ne = re, re += 2) he += (ee[re] - ee[ne]) * (ee[re + 1] + ee[ne + 1]);
            if (he > 0 === me) for (let re = 0, xe = ee.length; re < xe / 2; re += 2) {
              const ne = ee[re], Ce = ee[re + 1];
              ee[re] = ee[xe - 2 - re], ee[re + 1] = ee[xe - 1 - re], ee[xe - 2 - re] = ne, ee[xe - 1 - re] = Ce;
            }
          }(le, X), ie.push(le);
        }
        const _r = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class gr {
          constructor(P, L) {
            const O = (L = this.options = function(X, te) {
              for (const le in te) X[le] = te[le];
              return X;
            }(Object.create(_r), L)).debug;
            if (O && console.time("preprocess data"), L.maxZoom < 0 || L.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (L.promoteId && L.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let U = function(X, te) {
              const le = [];
              if (X.type === "FeatureCollection") for (let ee = 0; ee < X.features.length; ee++) Yr(le, X.features[ee], te, ee);
              else Yr(le, X.type === "Feature" ? X : { geometry: X }, te);
              return le;
            }(P, L);
            this.tiles = {}, this.tileCoords = [], O && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", L.indexMaxZoom, L.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), U = function(X, te) {
              const le = te.buffer / te.extent;
              let ee = X;
              const me = Vt(X, 1, -1 - le, le, 0, -1, 2, te), he = Vt(X, 1, 1 - le, 2 + le, 0, -1, 2, te);
              return (me || he) && (ee = Vt(X, 1, -le, 1 + le, 0, -1, 2, te) || [], me && (ee = ar(me, 1).concat(ee)), he && (ee = ee.concat(ar(he, -1)))), ee;
            }(U, L), U.length && this.splitTile(U, 0, 0, 0), O && (U.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(P, L, O, U, X, te, le) {
            const ee = [P, L, O, U], me = this.options, he = me.debug;
            for (; ee.length; ) {
              U = ee.pop(), O = ee.pop(), L = ee.pop(), P = ee.pop();
              const re = 1 << L, xe = Rr(L, O, U);
              let ne = this.tiles[xe];
              if (!ne && (he > 1 && console.time("creation"), ne = this.tiles[xe] = sn(P, L, O, U, me), this.tileCoords.push({ z: L, x: O, y: U }), he)) {
                he > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", L, O, U, ne.numFeatures, ne.numPoints, ne.numSimplified), console.timeEnd("creation"));
                const je = `z${L}`;
                this.stats[je] = (this.stats[je] || 0) + 1, this.total++;
              }
              if (ne.source = P, X == null) {
                if (L === me.indexMaxZoom || ne.numPoints <= me.indexMaxPoints) continue;
              } else {
                if (L === me.maxZoom || L === X) continue;
                if (X != null) {
                  const je = X - L;
                  if (O !== te >> je || U !== le >> je) continue;
                }
              }
              if (ne.source = null, P.length === 0) continue;
              he > 1 && console.time("clipping");
              const Ce = 0.5 * me.buffer / me.extent, Be = 0.5 - Ce, We = 0.5 + Ce, $e = 1 + Ce;
              let ye = null, De = null, ke = null, Ke = null, qe = Vt(P, re, O - Ce, O + We, 0, ne.minX, ne.maxX, me), Je = Vt(P, re, O + Be, O + $e, 0, ne.minX, ne.maxX, me);
              P = null, qe && (ye = Vt(qe, re, U - Ce, U + We, 1, ne.minY, ne.maxY, me), De = Vt(qe, re, U + Be, U + $e, 1, ne.minY, ne.maxY, me), qe = null), Je && (ke = Vt(Je, re, U - Ce, U + We, 1, ne.minY, ne.maxY, me), Ke = Vt(Je, re, U + Be, U + $e, 1, ne.minY, ne.maxY, me), Je = null), he > 1 && console.timeEnd("clipping"), ee.push(ye || [], L + 1, 2 * O, 2 * U), ee.push(De || [], L + 1, 2 * O, 2 * U + 1), ee.push(ke || [], L + 1, 2 * O + 1, 2 * U), ee.push(Ke || [], L + 1, 2 * O + 1, 2 * U + 1);
            }
          }
          getTile(P, L, O) {
            P = +P, L = +L, O = +O;
            const U = this.options, { extent: X, debug: te } = U;
            if (P < 0 || P > 24) return null;
            const le = 1 << P, ee = Rr(P, L = L + le & le - 1, O);
            if (this.tiles[ee]) return An(this.tiles[ee], X);
            te > 1 && console.log("drilling down to z%d-%d-%d", P, L, O);
            let me, he = P, re = L, xe = O;
            for (; !me && he > 0; ) he--, re >>= 1, xe >>= 1, me = this.tiles[Rr(he, re, xe)];
            return me && me.source ? (te > 1 && (console.log("found parent tile z%d-%d-%d", he, re, xe), console.time("drilling down")), this.splitTile(me.source, he, re, xe, P, L, O), te > 1 && console.timeEnd("drilling down"), this.tiles[ee] ? An(this.tiles[ee], X) : null) : null;
          }
        }
        function Rr(ie, P, L) {
          return 32 * ((1 << ie) * L + P) + ie;
        }
        function Lr(ie, P) {
          return P ? ie.properties[P] : ie.id;
        }
        function ls(ie, P) {
          if (ie == null) return !0;
          if (ie.type === "Feature") return Lr(ie, P) != null;
          if (ie.type === "FeatureCollection") {
            const L = /* @__PURE__ */ new Set();
            for (const O of ie.features) {
              const U = Lr(O, P);
              if (U == null || L.has(U)) return !1;
              L.add(U);
            }
            return !0;
          }
          return !1;
        }
        function kn(ie, P) {
          const L = /* @__PURE__ */ new Map();
          if (ie != null) if (ie.type === "Feature") L.set(Lr(ie, P), ie);
          else for (const O of ie.features) L.set(Lr(O, P), O);
          return L;
        }
        class cs extends Ir {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(P, L) {
            return z._(this, void 0, void 0, function* () {
              const O = P.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const U = this._geoJSONIndex.getTile(O.z, O.x, O.y);
              if (!U) return null;
              const X = new ns(U.features);
              let te = ss(X);
              return te.byteOffset === 0 && te.byteLength === te.buffer.byteLength || (te = new Uint8Array(te)), { vectorTile: X, rawData: te.buffer };
            });
          }
          loadData(P) {
            return z._(this, void 0, void 0, function* () {
              var L;
              (L = this._pendingRequest) === null || L === void 0 || L.abort();
              const O = !!(P && P.request && P.request.collectResourceTiming) && new z.cw(P.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(P, this._pendingRequest), this._geoJSONIndex = P.cluster ? new ht(function({ superclusterOptions: te, clusterProperties: le }) {
                  if (!le || !te) return te;
                  const ee = {}, me = {}, he = { accumulated: null, zoom: 0 }, re = { properties: null }, xe = Object.keys(le);
                  for (const ne of xe) {
                    const [Ce, Be] = le[ne], We = z.cD(Be), $e = z.cD(typeof Ce == "string" ? [Ce, ["accumulated"], ["get", ne]] : Ce);
                    ee[ne] = We.value, me[ne] = $e.value;
                  }
                  return te.map = (ne) => {
                    re.properties = ne;
                    const Ce = {};
                    for (const Be of xe) Ce[Be] = ee[Be].evaluate(he, re);
                    return Ce;
                  }, te.reduce = (ne, Ce) => {
                    re.properties = Ce;
                    for (const Be of xe) he.accumulated = ne[Be], ne[Be] = me[Be].evaluate(he, re);
                  }, te;
                }(P)).load((yield this._pendingData).features) : (U = yield this._pendingData, new gr(U, P.geojsonVtOptions)), this.loaded = {};
                const X = {};
                if (O) {
                  const te = O.finish();
                  te && (X.resourceTiming = {}, X.resourceTiming[P.source] = JSON.parse(JSON.stringify(te)));
                }
                return X;
              } catch (X) {
                if (delete this._pendingRequest, z.ch(X)) return { abandoned: !0 };
                throw X;
              }
              var U;
            });
          }
          getData() {
            return z._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(P) {
            const L = this.loaded;
            return L && L[P.uid] ? super.reloadTile(P) : this.loadTile(P);
          }
          loadAndProcessGeoJSON(P, L) {
            return z._(this, void 0, void 0, function* () {
              let O = yield this.loadGeoJSON(P, L);
              if (delete this._pendingRequest, typeof O != "object") throw new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`);
              if (Cr(O, !0), P.filter) {
                const U = z.cD(P.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (U.result === "error") throw new Error(U.value.map((te) => `${te.key}: ${te.message}`).join(", "));
                O = { type: "FeatureCollection", features: O.features.filter((te) => U.value.evaluate({ zoom: 0 }, te)) };
              }
              return O;
            });
          }
          loadGeoJSON(P, L) {
            return z._(this, void 0, void 0, function* () {
              const { promoteId: O } = P;
              if (P.request) {
                const U = yield z.j(P.request, L);
                return this._dataUpdateable = ls(U.data, O) ? kn(U.data, O) : void 0, U.data;
              }
              if (typeof P.data == "string") try {
                const U = JSON.parse(P.data);
                return this._dataUpdateable = ls(U, O) ? kn(U, O) : void 0, U;
              } catch {
                throw new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`);
              }
              if (!P.dataDiff) throw new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${P.source}`);
              return function(U, X, te) {
                var le, ee, me, he;
                if (X.removeAll && U.clear(), X.remove) for (const re of X.remove) U.delete(re);
                if (X.add) for (const re of X.add) {
                  const xe = Lr(re, te);
                  xe != null && U.set(xe, re);
                }
                if (X.update) for (const re of X.update) {
                  let xe = U.get(re.id);
                  if (xe == null) continue;
                  const ne = !re.removeAllProperties && (((le = re.removeProperties) === null || le === void 0 ? void 0 : le.length) > 0 || ((ee = re.addOrUpdateProperties) === null || ee === void 0 ? void 0 : ee.length) > 0);
                  if ((re.newGeometry || re.removeAllProperties || ne) && (xe = Object.assign({}, xe), U.set(re.id, xe), ne && (xe.properties = Object.assign({}, xe.properties))), re.newGeometry && (xe.geometry = re.newGeometry), re.removeAllProperties) xe.properties = {};
                  else if (((me = re.removeProperties) === null || me === void 0 ? void 0 : me.length) > 0) for (const Ce of re.removeProperties) Object.prototype.hasOwnProperty.call(xe.properties, Ce) && delete xe.properties[Ce];
                  if (((he = re.addOrUpdateProperties) === null || he === void 0 ? void 0 : he.length) > 0) for (const { key: Ce, value: Be } of re.addOrUpdateProperties) xe.properties[Ce] = Be;
                }
              }(this._dataUpdateable, P.dataDiff, O), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(P) {
            return z._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(P) {
            return this._geoJSONIndex.getClusterExpansionZoom(P.clusterId);
          }
          getClusterChildren(P) {
            return this._geoJSONIndex.getChildren(P.clusterId);
          }
          getClusterLeaves(P) {
            return this._geoJSONIndex.getLeaves(P.clusterId, P.limit, P.offset);
          }
        }
        class yr {
          constructor(P) {
            this.self = P, this.actor = new z.H(P), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (L, O) => {
              if (this.externalWorkerSourceTypes[L]) throw new Error(`Worker source with name "${L}" already registered.`);
              this.externalWorkerSourceTypes[L] = O;
            }, this.self.addProtocol = z.cj, this.self.removeProtocol = z.ck, this.self.registerRTLTextPlugin = (L) => {
              z.cE.setMethods(L);
            }, this.actor.registerMessageHandler("LDT", (L, O) => this._getDEMWorkerSource(L, O.source).loadTile(O)), this.actor.registerMessageHandler("RDT", (L, O) => z._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(L, O.source).removeTile(O);
            })), this.actor.registerMessageHandler("GCEZ", (L, O) => z._(this, void 0, void 0, function* () {
              return this._getWorkerSource(L, O.type, O.source).getClusterExpansionZoom(O);
            })), this.actor.registerMessageHandler("GCC", (L, O) => z._(this, void 0, void 0, function* () {
              return this._getWorkerSource(L, O.type, O.source).getClusterChildren(O);
            })), this.actor.registerMessageHandler("GCL", (L, O) => z._(this, void 0, void 0, function* () {
              return this._getWorkerSource(L, O.type, O.source).getClusterLeaves(O);
            })), this.actor.registerMessageHandler("LD", (L, O) => this._getWorkerSource(L, O.type, O.source).loadData(O)), this.actor.registerMessageHandler("GD", (L, O) => this._getWorkerSource(L, O.type, O.source).getData()), this.actor.registerMessageHandler("LT", (L, O) => this._getWorkerSource(L, O.type, O.source).loadTile(O)), this.actor.registerMessageHandler("RT", (L, O) => this._getWorkerSource(L, O.type, O.source).reloadTile(O)), this.actor.registerMessageHandler("AT", (L, O) => this._getWorkerSource(L, O.type, O.source).abortTile(O)), this.actor.registerMessageHandler("RMT", (L, O) => this._getWorkerSource(L, O.type, O.source).removeTile(O)), this.actor.registerMessageHandler("RS", (L, O) => z._(this, void 0, void 0, function* () {
              if (!this.workerSources[L] || !this.workerSources[L][O.type] || !this.workerSources[L][O.type][O.source]) return;
              const U = this.workerSources[L][O.type][O.source];
              delete this.workerSources[L][O.type][O.source], U.removeSource !== void 0 && U.removeSource(O);
            })), this.actor.registerMessageHandler("RM", (L) => z._(this, void 0, void 0, function* () {
              delete this.layerIndexes[L], delete this.availableImages[L], delete this.workerSources[L], delete this.demWorkerSources[L];
            })), this.actor.registerMessageHandler("SR", (L, O) => z._(this, void 0, void 0, function* () {
              this.referrer = O;
            })), this.actor.registerMessageHandler("SRPS", (L, O) => this._syncRTLPluginState(L, O)), this.actor.registerMessageHandler("IS", (L, O) => z._(this, void 0, void 0, function* () {
              this.self.importScripts(O);
            })), this.actor.registerMessageHandler("SI", (L, O) => this._setImages(L, O)), this.actor.registerMessageHandler("UL", (L, O) => z._(this, void 0, void 0, function* () {
              this._getLayerIndex(L).update(O.layers, O.removedIds);
            })), this.actor.registerMessageHandler("SL", (L, O) => z._(this, void 0, void 0, function* () {
              this._getLayerIndex(L).replace(O);
            }));
          }
          _setImages(P, L) {
            return z._(this, void 0, void 0, function* () {
              this.availableImages[P] = L;
              for (const O in this.workerSources[P]) {
                const U = this.workerSources[P][O];
                for (const X in U) U[X].availableImages = L;
              }
            });
          }
          _syncRTLPluginState(P, L) {
            return z._(this, void 0, void 0, function* () {
              return yield z.cE.syncState(L, this.self.importScripts);
            });
          }
          _getAvailableImages(P) {
            let L = this.availableImages[P];
            return L || (L = []), L;
          }
          _getLayerIndex(P) {
            let L = this.layerIndexes[P];
            return L || (L = this.layerIndexes[P] = new c()), L;
          }
          _getWorkerSource(P, L, O) {
            if (this.workerSources[P] || (this.workerSources[P] = {}), this.workerSources[P][L] || (this.workerSources[P][L] = {}), !this.workerSources[P][L][O]) {
              const U = { sendAsync: (X, te) => (X.targetMapId = P, this.actor.sendAsync(X, te)) };
              switch (L) {
                case "vector":
                  this.workerSources[P][L][O] = new Ir(U, this._getLayerIndex(P), this._getAvailableImages(P));
                  break;
                case "geojson":
                  this.workerSources[P][L][O] = new cs(U, this._getLayerIndex(P), this._getAvailableImages(P));
                  break;
                default:
                  this.workerSources[P][L][O] = new this.externalWorkerSourceTypes[L](U, this._getLayerIndex(P), this._getAvailableImages(P));
              }
            }
            return this.workerSources[P][L][O];
          }
          _getDEMWorkerSource(P, L) {
            return this.demWorkerSources[P] || (this.demWorkerSources[P] = {}), this.demWorkerSources[P][L] || (this.demWorkerSources[P][L] = new He()), this.demWorkerSources[P][L];
          }
        }
        return z.i(self) && (self.worker = new yr(self)), yr;
      }), mt("index", ["exports", "./shared"], function(z, c) {
        var fi = "5.2.0";
        function Mr() {
          var h = new c.A(4);
          return c.A != Float32Array && (h[1] = 0, h[2] = 0), h[0] = 1, h[3] = 1, h;
        }
        let ki, Ir;
        const He = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(h, e, i) {
          const a = requestAnimationFrame((u) => {
            o(), e(u);
          }), { unsubscribe: o } = c.s(h.signal, "abort", () => {
            o(), cancelAnimationFrame(a), i(c.c());
          }, !1);
        }, frameAsync(h) {
          return new Promise((e, i) => {
            this.frame(h, e, i);
          });
        }, getImageData(h, e = 0) {
          return this.getImageCanvasContext(h).getImageData(-e, -e, h.width + 2 * e, h.height + 2 * e);
        }, getImageCanvasContext(h) {
          const e = window.document.createElement("canvas"), i = e.getContext("2d", { willReadFrequently: !0 });
          if (!i) throw new Error("failed to create canvas 2d context");
          return e.width = h.width, e.height = h.height, i.drawImage(h, 0, 0, h.width, h.height), i;
        }, resolveURL: (h) => (ki || (ki = document.createElement("a")), ki.href = h, ki.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (Ir == null && (Ir = matchMedia("(prefers-reduced-motion: reduce)")), Ir.matches);
        } };
        class ue {
          static testProp(e) {
            if (!ue.docStyle) return e[0];
            for (let i = 0; i < e.length; i++) if (e[i] in ue.docStyle) return e[i];
            return e[0];
          }
          static create(e, i, a) {
            const o = window.document.createElement(e);
            return i !== void 0 && (o.className = i), a && a.appendChild(o), o;
          }
          static createNS(e, i) {
            return window.document.createElementNS(e, i);
          }
          static disableDrag() {
            ue.docStyle && ue.selectProp && (ue.userSelect = ue.docStyle[ue.selectProp], ue.docStyle[ue.selectProp] = "none");
          }
          static enableDrag() {
            ue.docStyle && ue.selectProp && (ue.docStyle[ue.selectProp] = ue.userSelect);
          }
          static setTransform(e, i) {
            e.style[ue.transformProp] = i;
          }
          static addEventListener(e, i, a, o = {}) {
            e.addEventListener(i, a, "passive" in o ? o : o.capture);
          }
          static removeEventListener(e, i, a, o = {}) {
            e.removeEventListener(i, a, "passive" in o ? o : o.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", ue.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", ue.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", ue.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(e) {
            const i = e.getBoundingClientRect();
            return { x: i.width / e.offsetWidth || 1, y: i.height / e.offsetHeight || 1, boundingClientRect: i };
          }
          static getPoint(e, i, a) {
            const o = i.boundingClientRect;
            return new c.P((a.clientX - o.left) / i.x - e.clientLeft, (a.clientY - o.top) / i.y - e.clientTop);
          }
          static mousePos(e, i) {
            const a = ue.getScale(e);
            return ue.getPoint(e, a, i);
          }
          static touchPos(e, i) {
            const a = [], o = ue.getScale(e);
            for (let u = 0; u < i.length; u++) a.push(ue.getPoint(e, o, i[u]));
            return a;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), a = i.querySelectorAll("script");
            for (const o of a) o.remove();
            return ue.clean(i), i.innerHTML;
          }
          static isPossiblyDangerous(e, i) {
            const a = i.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !a.includes("javascript:") && !a.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const i = e.children;
            for (const a of i) ue.removeAttributes(a), ue.clean(a);
          }
          static removeAttributes(e) {
            for (const { name: i, value: a } of e.attributes) ue.isPossiblyDangerous(i, a) && e.removeAttribute(i);
          }
        }
        ue.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, ue.selectProp = ue.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), ue.transformProp = ue.testProp(["transform", "WebkitTransform"]);
        const Ue = { supported: !1, testSupport: function(h) {
          !Hr && Cr && (Xr ? ns(h) : Wr = h);
        } };
        let Wr, Cr, Hr = !1, Xr = !1;
        function ns(h) {
          const e = h.createTexture();
          h.bindTexture(h.TEXTURE_2D, e);
          try {
            if (h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, Cr), h.isContextLost()) return;
            Ue.supported = !0;
          } catch {
          }
          h.deleteTexture(e), Hr = !0;
        }
        var mi;
        typeof document < "u" && (Cr = document.createElement("img"), Cr.onload = () => {
          Wr && ns(Wr), Wr = null, Xr = !0;
        }, Cr.onerror = () => {
          Hr = !0, Wr = null;
        }, Cr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(h) {
          let e, i, a, o;
          h.resetRequestQueue = () => {
            e = [], i = 0, a = 0, o = {};
          }, h.addThrottleControl = (y) => {
            const v = a++;
            return o[v] = y, v;
          }, h.removeThrottleControl = (y) => {
            delete o[y], f();
          }, h.getImage = (y, v, T = !0) => new Promise((S, M) => {
            Ue.supported && (y.headers || (y.headers = {}), y.headers.accept = "image/webp,*/*"), c.e(y, { type: "image" }), e.push({ abortController: v, requestParameters: y, supportImageRefresh: T, state: "queued", onError: (k) => {
              M(k);
            }, onSuccess: (k) => {
              S(k);
            } }), f();
          });
          const u = (y) => c._(this, void 0, void 0, function* () {
            y.state = "running";
            const { requestParameters: v, supportImageRefresh: T, onError: S, onSuccess: M, abortController: k } = y, R = T === !1 && !c.i(self) && !c.g(v.url) && (!v.headers || Object.keys(v.headers).reduce((N, G) => N && G === "accept", !0));
            i++;
            const V = R ? _(v, k) : c.m(v, k);
            try {
              const N = yield V;
              delete y.abortController, y.state = "completed", N.data instanceof HTMLImageElement || c.b(N.data) ? M(N) : N.data && M({ data: yield (j = N.data, typeof createImageBitmap == "function" ? c.f(j) : c.h(j)), cacheControl: N.cacheControl, expires: N.expires });
            } catch (N) {
              delete y.abortController, S(N);
            } finally {
              i--, f();
            }
            var j;
          }), f = () => {
            const y = (() => {
              for (const v of Object.keys(o)) if (o[v]()) return !0;
              return !1;
            })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let v = i; v < y && e.length > 0; v++) {
              const T = e.shift();
              T.abortController.signal.aborted ? v-- : u(T);
            }
          }, _ = (y, v) => new Promise((T, S) => {
            const M = new Image(), k = y.url, R = y.credentials;
            R && R === "include" ? M.crossOrigin = "use-credentials" : (R && R === "same-origin" || !c.d(k)) && (M.crossOrigin = "anonymous"), v.signal.addEventListener("abort", () => {
              M.src = "", S(c.c());
            }), M.fetchPriority = "high", M.onload = () => {
              M.onerror = M.onload = null, T({ data: M });
            }, M.onerror = () => {
              M.onerror = M.onload = null, v.signal.aborted || S(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, M.src = k;
          });
        }(mi || (mi = {})), mi.resetRequestQueue();
        class Er {
          constructor(e) {
            this._transformRequestFn = e;
          }
          transformRequest(e, i) {
            return this._transformRequestFn && this._transformRequestFn(e, i) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function Mt(h) {
          const e = [];
          if (typeof h == "string") e.push({ id: "default", url: h });
          else if (h && h.length > 0) {
            const i = [];
            for (const { id: a, url: o } of h) {
              const u = `${a}${o}`;
              i.indexOf(u) === -1 && (i.push(u), e.push({ id: a, url: o }));
            }
          }
          return e;
        }
        function bt(h, e, i) {
          try {
            const a = new URL(h);
            return a.pathname += `${e}${i}`, a.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        class zt {
          constructor(e, i, a, o) {
            this.context = e, this.format = a, this.texture = e.gl.createTexture(), this.update(i, o);
          }
          update(e, i, a) {
            const { width: o, height: u } = e, f = !(this.size && this.size[0] === o && this.size[1] === u || a), { context: _ } = this, { gl: y } = _;
            if (this.useMipmap = !!(i && i.useMipmap), y.bindTexture(y.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === y.RGBA && (!i || i.premultiply !== !1)), f) this.size = [o, u], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? y.texImage2D(y.TEXTURE_2D, 0, this.format, this.format, y.UNSIGNED_BYTE, e) : y.texImage2D(y.TEXTURE_2D, 0, this.format, o, u, 0, this.format, y.UNSIGNED_BYTE, e.data);
            else {
              const { x: v, y: T } = a || { x: 0, y: 0 };
              e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? y.texSubImage2D(y.TEXTURE_2D, 0, v, T, y.RGBA, y.UNSIGNED_BYTE, e) : y.texSubImage2D(y.TEXTURE_2D, 0, v, T, o, u, y.RGBA, y.UNSIGNED_BYTE, e.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && y.generateMipmap(y.TEXTURE_2D);
          }
          bind(e, i, a) {
            const { context: o } = this, { gl: u } = o;
            u.bindTexture(u.TEXTURE_2D, this.texture), a !== u.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (a = u.LINEAR), e !== this.filter && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, a || e), this.filter = e), i !== this.wrap && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, i), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, i), this.wrap = i);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        function ss(h) {
          const { userImage: e } = h;
          return !!(e && e.render && e.render()) && (h.data.replace(new Uint8Array(e.data.buffer)), !0);
        }
        class Bs extends c.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: i, promiseResolve: a } of this.requestors) a(this._getImagesForIds(i));
              this.requestors = [];
            }
          }
          getImage(e) {
            const i = this.images[e];
            if (i && !i.data && i.spriteData) {
              const a = i.spriteData;
              i.data = new c.R({ width: a.width, height: a.height }, a.context.getImageData(a.x, a.y, a.width, a.height).data), i.spriteData = null;
            }
            return i;
          }
          addImage(e, i) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, i) && (this.images[e] = i);
          }
          _validate(e, i) {
            let a = !0;
            const o = i.data || i.spriteData;
            return this._validateStretch(i.stretchX, o && o.width) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchX" value`))), a = !1), this._validateStretch(i.stretchY, o && o.height) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchY" value`))), a = !1), this._validateContent(i.content, i) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "content" value`))), a = !1), a;
          }
          _validateStretch(e, i) {
            if (!e) return !0;
            let a = 0;
            for (const o of e) {
              if (o[0] < a || o[1] < o[0] || i < o[1]) return !1;
              a = o[1];
            }
            return !0;
          }
          _validateContent(e, i) {
            if (!e) return !0;
            if (e.length !== 4) return !1;
            const a = i.spriteData, o = a && a.width || i.data.width, u = a && a.height || i.data.height;
            return !(e[0] < 0 || o < e[0] || e[1] < 0 || u < e[1] || e[2] < 0 || o < e[2] || e[3] < 0 || u < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, i, a = !0) {
            const o = this.getImage(e);
            if (a && (o.data.width !== i.data.width || o.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${o.data.width}x${o.data.height}) and new image (${i.data.width}x${i.data.height}).`);
            i.version = o.version + 1, this.images[e] = i, this.updatedImages[e] = !0;
          }
          removeImage(e) {
            const i = this.images[e];
            delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise((i, a) => {
              let o = !0;
              if (!this.isLoaded()) for (const u of e) this.images[u] || (o = !1);
              this.isLoaded() || o ? i(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: i });
            });
          }
          _getImagesForIds(e) {
            const i = {};
            for (const a of e) {
              let o = this.getImage(a);
              o || (this.fire(new c.l("styleimagemissing", { id: a })), o = this.getImage(a)), o ? i[a] = { data: o.data.clone(), pixelRatio: o.pixelRatio, sdf: o.sdf, version: o.version, stretchX: o.stretchX, stretchY: o.stretchY, content: o.content, textFitWidth: o.textFitWidth, textFitHeight: o.textFitHeight, hasRenderCallback: !!(o.userImage && o.userImage.render) } : c.w(`Image "${a}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return i;
          }
          getPixelSize() {
            const { width: e, height: i } = this.atlasImage;
            return { width: e, height: i };
          }
          getPattern(e) {
            const i = this.patterns[e], a = this.getImage(e);
            if (!a) return null;
            if (i && i.position.version === a.version) return i.position;
            if (i) i.position.version = a.version;
            else {
              const o = { w: a.data.width + 2, h: a.data.height + 2, x: 0, y: 0 }, u = new c.I(o, a);
              this.patterns[e] = { bin: o, position: u };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const i = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new zt(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const u in this.patterns) e.push(this.patterns[u].bin);
            const { w: i, h: a } = c.p(e), o = this.atlasImage;
            o.resize({ width: i || 1, height: a || 1 });
            for (const u in this.patterns) {
              const { bin: f } = this.patterns[u], _ = f.x + 1, y = f.y + 1, v = this.getImage(u).data, T = v.width, S = v.height;
              c.R.copy(v, o, { x: 0, y: 0 }, { x: _, y }, { width: T, height: S }), c.R.copy(v, o, { x: 0, y: S - 1 }, { x: _, y: y - 1 }, { width: T, height: 1 }), c.R.copy(v, o, { x: 0, y: 0 }, { x: _, y: y + S }, { width: T, height: 1 }), c.R.copy(v, o, { x: T - 1, y: 0 }, { x: _ - 1, y }, { width: 1, height: S }), c.R.copy(v, o, { x: 0, y: 0 }, { x: _ + T, y }, { width: 1, height: S });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const i of e) {
              if (this.callbackDispatchedThisFrame[i]) continue;
              this.callbackDispatchedThisFrame[i] = !0;
              const a = this.getImage(i);
              a || c.w(`Image with ID: "${i}" was not found`), ss(a) && this.updateImage(i, a);
            }
          }
        }
        const Ar = 1e20;
        function fr(h, e, i, a, o, u, f, _, y) {
          for (let v = e; v < e + a; v++) Di(h, i * u + v, u, o, f, _, y);
          for (let v = i; v < i + o; v++) Di(h, v * u + e, 1, a, f, _, y);
        }
        function Di(h, e, i, a, o, u, f) {
          u[0] = 0, f[0] = -1e20, f[1] = Ar, o[0] = h[e];
          for (let _ = 1, y = 0, v = 0; _ < a; _++) {
            o[_] = h[e + _ * i];
            const T = _ * _;
            do {
              const S = u[y];
              v = (o[_] - o[S] + T - S * S) / (_ - S) / 2;
            } while (v <= f[y] && --y > -1);
            y++, u[y] = _, f[y] = v, f[y + 1] = Ar;
          }
          for (let _ = 0, y = 0; _ < a; _++) {
            for (; f[y + 1] < _; ) y++;
            const v = u[y], T = _ - v;
            h[e + _ * i] = o[v] + T * T;
          }
        }
        class li {
          constructor(e, i) {
            this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {};
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return c._(this, void 0, void 0, function* () {
              const i = [];
              for (const u in e) for (const f of e[u]) i.push(this._getAndCacheGlyphsPromise(u, f));
              const a = yield Promise.all(i), o = {};
              for (const { stack: u, id: f, glyph: _ } of a) o[u] || (o[u] = {}), o[u][f] = _ && { id: _.id, bitmap: _.bitmap.clone(), metrics: _.metrics };
              return o;
            });
          }
          _getAndCacheGlyphsPromise(e, i) {
            return c._(this, void 0, void 0, function* () {
              let a = this.entries[e];
              a || (a = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let o = a.glyphs[i];
              if (o !== void 0) return { stack: e, id: i, glyph: o };
              if (o = this._tinySDF(a, e, i), o) return a.glyphs[i] = o, { stack: e, id: i, glyph: o };
              const u = Math.floor(i / 256);
              if (256 * u > 65535) throw new Error("glyphs > 65535 not supported");
              if (a.ranges[u]) return { stack: e, id: i, glyph: o };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!a.requests[u]) {
                const _ = li.loadGlyphRange(e, u, this.url, this.requestManager);
                a.requests[u] = _;
              }
              const f = yield a.requests[u];
              for (const _ in f) this._doesCharSupportLocalGlyph(+_) || (a.glyphs[+_] = f[+_]);
              return a.ranges[u] = !0, { stack: e, id: i, glyph: f[i] || null };
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || c.u["CJK Unified Ideographs"](e) || c.u["Hangul Syllables"](e) || c.u.Hiragana(e) || c.u.Katakana(e) || c.u["CJK Symbols and Punctuation"](e) || c.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, i, a) {
            const o = this.localIdeographFontFamily;
            if (!o || !this._doesCharSupportLocalGlyph(a)) return;
            let u = e.tinySDF;
            if (!u) {
              let _ = "400";
              /bold/i.test(i) ? _ = "900" : /medium/i.test(i) ? _ = "500" : /light/i.test(i) && (_ = "200"), u = e.tinySDF = new li.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o, fontWeight: _ });
            }
            const f = u.draw(String.fromCharCode(a));
            return { id: a, bitmap: new c.q({ width: f.width || 60, height: f.height || 60 }, f.data), metrics: { width: f.glyphWidth / 2 || 24, height: f.glyphHeight / 2 || 24, left: f.glyphLeft / 2 + 0.5 || 0, top: f.glyphTop / 2 - 27.5 || -8, advance: f.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        li.loadGlyphRange = function(h, e, i, a) {
          return c._(this, void 0, void 0, function* () {
            const o = 256 * e, u = o + 255, f = a.transformRequest(i.replace("{fontstack}", h).replace("{range}", `${o}-${u}`), "Glyphs"), _ = yield c.n(f, new AbortController());
            if (!_ || !_.data) throw new Error(`Could not load glyph range. range: ${e}, ${o}-${u}`);
            const y = {};
            for (const v of c.o(_.data)) y[v.id] = v;
            return y;
          });
        }, li.TinySDF = class {
          constructor({ fontSize: h = 24, buffer: e = 3, radius: i = 8, cutoff: a = 0.25, fontFamily: o = "sans-serif", fontWeight: u = "normal", fontStyle: f = "normal" } = {}) {
            this.buffer = e, this.cutoff = a, this.radius = i;
            const _ = this.size = h + 4 * e, y = this._createCanvas(_), v = this.ctx = y.getContext("2d", { willReadFrequently: !0 });
            v.font = `${f} ${u} ${h}px ${o}`, v.textBaseline = "alphabetic", v.textAlign = "left", v.fillStyle = "black", this.gridOuter = new Float64Array(_ * _), this.gridInner = new Float64Array(_ * _), this.f = new Float64Array(_), this.z = new Float64Array(_ + 1), this.v = new Uint16Array(_);
          }
          _createCanvas(h) {
            const e = document.createElement("canvas");
            return e.width = e.height = h, e;
          }
          draw(h) {
            const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: a, actualBoundingBoxLeft: o, actualBoundingBoxRight: u } = this.ctx.measureText(h), f = Math.ceil(i), _ = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(u - o))), y = Math.min(this.size - this.buffer, f + Math.ceil(a)), v = _ + 2 * this.buffer, T = y + 2 * this.buffer, S = Math.max(v * T, 0), M = new Uint8ClampedArray(S), k = { data: M, width: v, height: T, glyphWidth: _, glyphHeight: y, glyphTop: f, glyphLeft: 0, glyphAdvance: e };
            if (_ === 0 || y === 0) return k;
            const { ctx: R, buffer: V, gridInner: j, gridOuter: N } = this;
            R.clearRect(V, V, _, y), R.fillText(h, V, V + f);
            const G = R.getImageData(V, V, _, y);
            N.fill(Ar, 0, S), j.fill(0, 0, S);
            for (let W = 0; W < y; W++) for (let H = 0; H < _; H++) {
              const K = G.data[4 * (W * _ + H) + 3] / 255;
              if (K === 0) continue;
              const Q = (W + V) * v + H + V;
              if (K === 1) N[Q] = 0, j[Q] = Ar;
              else {
                const J = 0.5 - K;
                N[Q] = J > 0 ? J * J : 0, j[Q] = J < 0 ? J * J : 0;
              }
            }
            fr(N, 0, 0, v, T, v, this.f, this.v, this.z), fr(j, V, V, _, y, v, this.f, this.v, this.z);
            for (let W = 0; W < S; W++) {
              const H = Math.sqrt(N[W]) - Math.sqrt(j[W]);
              M[W] = Math.round(255 - 255 * (H / this.radius + this.cutoff));
            }
            return k;
          }
        };
        class as {
          constructor() {
            this.specification = c.v.light.position;
          }
          possiblyEvaluate(e, i) {
            return c.z(e.expression.evaluate(i));
          }
          interpolate(e, i, a) {
            return { x: c.B.number(e.x, i.x, a), y: c.B.number(e.y, i.y, a), z: c.B.number(e.z, i.z, a) };
          }
        }
        let ht;
        class Cn extends c.E {
          constructor(e) {
            super(), ht = ht || new c.r({ anchor: new c.D(c.v.light.anchor), position: new as(), color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(ht), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, i = {}) {
            if (!this._validate(c.t, e, i)) for (const a in e) {
              const o = e[a];
              a.endsWith("-transition") ? this._transitionable.setTransition(a.slice(0, -11), o) : this._transitionable.setValue(a, o);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, i, a) {
            return (!a || a.validate !== !1) && c.x(this, e.call(c.y, { value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }));
          }
        }
        const zr = new c.r({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) });
        class Kr extends c.E {
          constructor(e) {
            super(), this._transitionable = new c.T(zr), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0));
          }
          setSky(e, i = {}) {
            if (!this._validate(c.F, e, i)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const a in e) {
                const o = e[a];
                a.endsWith("-transition") ? this._transitionable.setTransition(a.slice(0, -11), o) : this._transitionable.setValue(a, o);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, i, a = {}) {
            return (a == null ? void 0 : a.validate) !== !1 && c.x(this, e.call(c.y, c.e({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class Jr {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, i) {
            const a = e.join(",") + String(i);
            return this.dashEntry[a] || (this.dashEntry[a] = this.addDash(e, i)), this.dashEntry[a];
          }
          getDashRanges(e, i, a) {
            const o = [];
            let u = e.length % 2 == 1 ? -e[e.length - 1] * a : 0, f = e[0] * a, _ = !0;
            o.push({ left: u, right: f, isDash: _, zeroLength: e[0] === 0 });
            let y = e[0];
            for (let v = 1; v < e.length; v++) {
              _ = !_;
              const T = e[v];
              u = y * a, y += T, f = y * a, o.push({ left: u, right: f, isDash: _, zeroLength: T === 0 });
            }
            return o;
          }
          addRoundDash(e, i, a) {
            const o = i / 2;
            for (let u = -a; u <= a; u++) {
              const f = this.width * (this.nextRow + a + u);
              let _ = 0, y = e[_];
              for (let v = 0; v < this.width; v++) {
                v / y.right > 1 && (y = e[++_]);
                const T = Math.abs(v - y.left), S = Math.abs(v - y.right), M = Math.min(T, S);
                let k;
                const R = u / a * (o + 1);
                if (y.isDash) {
                  const V = o - Math.abs(R);
                  k = Math.sqrt(M * M + V * V);
                } else k = o - Math.sqrt(M * M + R * R);
                this.data[f + v] = Math.max(0, Math.min(255, k + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let _ = e.length - 1; _ >= 0; --_) {
              const y = e[_], v = e[_ + 1];
              y.zeroLength ? e.splice(_, 1) : v && v.isDash === y.isDash && (v.left = y.left, e.splice(_, 1));
            }
            const i = e[0], a = e[e.length - 1];
            i.isDash === a.isDash && (i.left = a.left - this.width, a.right = i.right + this.width);
            const o = this.width * this.nextRow;
            let u = 0, f = e[u];
            for (let _ = 0; _ < this.width; _++) {
              _ / f.right > 1 && (f = e[++u]);
              const y = Math.abs(_ - f.left), v = Math.abs(_ - f.right), T = Math.min(y, v);
              this.data[o + _] = Math.max(0, Math.min(255, (f.isDash ? T : -T) + 128));
            }
          }
          addDash(e, i) {
            const a = i ? 7 : 0, o = 2 * a + 1;
            if (this.nextRow + o > this.height) return c.w("LineAtlas out of space"), null;
            let u = 0;
            for (let _ = 0; _ < e.length; _++) u += e[_];
            if (u !== 0) {
              const _ = this.width / u, y = this.getDashRanges(e, this.width, _);
              i ? this.addRoundDash(y, _, a) : this.addRegularDash(y);
            }
            const f = { y: (this.nextRow + a + 0.5) / this.height, height: 2 * a / this.height, width: u };
            return this.nextRow += o, this.dirty = !0, f;
          }
          bind(e) {
            const i = e.gl;
            this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data));
          }
        }
        const En = "maplibre_preloaded_worker_pool";
        class sr {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < sr.workerCount; ) this.workers.push(new Worker(c.a.WORKER_URL));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach((i) => {
              i.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[En];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const qi = Math.floor(He.hardwareConcurrency / 2);
        let Ri, ii;
        function Yr() {
          return Ri || (Ri = new sr()), Ri;
        }
        sr.workerCount = c.G(globalThis) ? Math.max(Math.min(qi, 3), 1) : 1;
        class Qr {
          constructor(e, i) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i;
            const a = this.workerPool.acquire(i);
            for (let o = 0; o < a.length; o++) {
              const u = new c.H(a[o], i);
              u.name = `Worker ${o}`, this.actors.push(u);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, i) {
            const a = [];
            for (const o of this.actors) a.push(o.sendAsync({ type: e, data: i }));
            return Promise.all(a);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = !0) {
            this.actors.forEach((i) => {
              i.remove();
            }), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, i) {
            for (const a of this.actors) a.registerMessageHandler(e, i);
          }
        }
        function en() {
          return ii || (ii = new Qr(Yr(), c.J), ii.registerMessageHandler("GR", (h, e, i) => c.m(e, i))), ii;
        }
        function Pi(h, e) {
          const i = c.K();
          return c.L(i, i, [1, 1, 0]), c.M(i, i, [0.5 * h.width, 0.5 * h.height, 1]), h.calculatePosMatrix ? c.N(i, i, h.calculatePosMatrix(e.toUnwrapped())) : i;
        }
        function os(h, e, i, a, o, u) {
          var f;
          const _ = function(S, M, k) {
            if (S) for (const R of S) {
              const V = M[R];
              if (V && V.source === k && V.type === "fill-extrusion") return !0;
            }
            else for (const R in M) {
              const V = M[R];
              if (V.source === k && V.type === "fill-extrusion") return !0;
            }
            return !1;
          }((f = o == null ? void 0 : o.layers) !== null && f !== void 0 ? f : null, e, h.id), y = u.maxPitchScaleFactor(), v = h.tilesIn(a, y, _);
          v.sort(ci);
          const T = [];
          for (const S of v) T.push({ wrappedTileID: S.tileID.wrapped().key, queryResults: S.tile.queryRenderedFeatures(e, i, h._state, S.queryGeometry, S.cameraQueryGeometry, S.scale, o, u, y, Pi(h.transform, S.tileID)) });
          return function(S, M) {
            for (const k in S) for (const R of S[k]) Vt(R, M);
            return S;
          }(function(S) {
            const M = {}, k = {};
            for (const R of S) {
              const V = R.queryResults, j = R.wrappedTileID, N = k[j] = k[j] || {};
              for (const G in V) {
                const W = V[G], H = N[G] = N[G] || {}, K = M[G] = M[G] || [];
                for (const Q of W) H[Q.featureIndex] || (H[Q.featureIndex] = !0, K.push(Q));
              }
            }
            return M;
          }(T), h);
        }
        function ci(h, e) {
          const i = h.tileID, a = e.tileID;
          return i.overscaledZ - a.overscaledZ || i.canonical.y - a.canonical.y || i.wrap - a.wrap || i.canonical.x - a.canonical.x;
        }
        function Vt(h, e) {
          const i = h.feature, a = e.getFeatureState(i.layer["source-layer"], i.id);
          i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = a;
        }
        function mr(h, e, i) {
          return c._(this, void 0, void 0, function* () {
            let a = h;
            if (h.url ? a = (yield c.j(e.transformRequest(h.url, "Source"), i)).data : yield He.frameAsync(i), !a) return null;
            const o = c.O(c.e(a, h), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in a && a.vector_layers && (o.vectorLayerIds = a.vector_layers.map((u) => u.id)), o;
          });
        }
        class Dt {
          constructor(e, i) {
            e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this;
          }
          extend(e) {
            const i = this._sw, a = this._ne;
            let o, u;
            if (e instanceof c.Q) o = e, u = e;
            else {
              if (!(e instanceof Dt)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Dt.convert(e)) : this.extend(c.Q.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(c.Q.convert(e)) : this;
              if (o = e._sw, u = e._ne, !o || !u) return this;
            }
            return i || a ? (i.lng = Math.min(o.lng, i.lng), i.lat = Math.min(o.lat, i.lat), a.lng = Math.max(u.lng, a.lng), a.lat = Math.max(u.lat, a.lat)) : (this._sw = new c.Q(o.lng, o.lat), this._ne = new c.Q(u.lng, u.lat)), this;
          }
          getCenter() {
            return new c.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new c.Q(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new c.Q(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: i, lat: a } = c.Q.convert(e);
            let o = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (o = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= a && a <= this._ne.lat && o;
          }
          static convert(e) {
            return e instanceof Dt ? e : e && new Dt(e);
          }
          static fromLngLat(e, i = 0) {
            const a = 360 * i / 40075017, o = a / Math.cos(Math.PI / 180 * e.lat);
            return new Dt(new c.Q(e.lng - o, e.lat - a), new c.Q(e.lng + o, e.lat + a));
          }
          adjustAntiMeridian() {
            const e = new c.Q(this._sw.lng, this._sw.lat), i = new c.Q(this._ne.lng, this._ne.lat);
            return new Dt(e, e.lng > i.lng ? new c.Q(i.lng + 360, i.lat) : i);
          }
        }
        class tn {
          constructor(e, i, a) {
            this.bounds = Dt.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = a || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const i = Math.pow(2, e.z), a = Math.floor(c.U(this.bounds.getWest()) * i), o = Math.floor(c.S(this.bounds.getNorth()) * i), u = Math.ceil(c.U(this.bounds.getEast()) * i), f = Math.ceil(c.S(this.bounds.getSouth()) * i);
            return e.x >= a && e.x < u && e.y >= o && e.y < f;
          }
        }
        class rn extends c.E {
          constructor(e, i, a, o) {
            if (super(), this.id = e, this.dispatcher = a, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.O(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(o);
          }
          load() {
            return c._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield mr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (c.e(this, e), e.bounds && (this.tileBounds = new tn(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this.fire(new c.k(e));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          setUrl(e) {
            return this.setSourceProperty(() => {
              this.url = e, this._options.url = e;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return c.e({}, this._options);
          }
          loadTile(e) {
            return c._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a = { request: this.map._requestManager.transformRequest(i, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              a.request.collectResourceTiming = this._collectResourceTiming;
              let o = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise((u, f) => {
                  e.reloadPromise = { resolve: u, reject: f };
                });
              } else e.actor = this.dispatcher.getActor(), o = "LT";
              e.abortController = new AbortController();
              try {
                const u = yield e.actor.sendAsync({ type: o, data: a }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, u);
              } catch (u) {
                if (delete e.abortController, e.aborted) return;
                if (u && u.status !== 404) throw u;
                this._afterTileLoadWorkerResponse(e, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(e, i) {
            if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) {
              const a = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(a.resolve).catch(a.reject);
            }
          }
          abortTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Wi extends c.E {
          constructor(e, i, a, o) {
            super(), this.id = e, this.dispatcher = a, this.setEventedParent(o), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, i), c.e(this, c.O(i, ["url", "scheme", "tileSize"]));
          }
          load() {
            return c._(this, arguments, void 0, function* (e = !1) {
              this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const i = yield mr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, i && (c.e(this, i), i.bounds && (this.tileBounds = new tn(i.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (i) {
                this._tileJSONRequest = null, this.fire(new c.k(i));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0);
          }
          setTiles(e) {
            return this.setSourceProperty(() => {
              this._options.tiles = e;
            }), this;
          }
          setUrl(e) {
            return this.setSourceProperty(() => {
              this.url = e, this._options.url = e;
            }), this;
          }
          serialize() {
            return c.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return c._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const a = yield mi.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (a && a.data) {
                  this.map._refreshExpiredTiles && a.cacheControl && a.expires && e.setExpiryData({ cacheControl: a.cacheControl, expires: a.expires });
                  const o = this.map.painter.context, u = o.gl, f = a.data;
                  e.texture = this.map.painter.getTileTexture(f.width), e.texture ? e.texture.update(f, { useMipmap: !0 }) : (e.texture = new zt(o, f, u.RGBA, { useMipmap: !0 }), e.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE, u.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (a) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (a) throw e.state = "errored", a;
              }
            });
          }
          abortTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            });
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class kr extends Wi {
          constructor(e, i, a, o) {
            super(e, i, a, o), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift;
          }
          loadTile(e) {
            return c._(this, void 0, void 0, function* () {
              const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a = this.map._requestManager.transformRequest(i, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const o = yield mi.getImage(a, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (o && o.data) {
                  const u = o.data;
                  this.map._refreshExpiredTiles && o.cacheControl && o.expires && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires });
                  const f = c.b(u) && c.V() ? u : yield this.readImageNow(u), _ = { type: this.type, uid: e.uid, source: this.id, rawImageData: f, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const y = yield e.actor.sendAsync({ type: "LDT", data: _ });
                    e.dem = y, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                  }
                }
              } catch (o) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (o) throw e.state = "errored", o;
              }
            });
          }
          readImageNow(e) {
            return c._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && c.W()) {
                const i = e.width + 2, a = e.height + 2;
                try {
                  return new c.R({ width: i, height: a }, yield c.X(e, -1, -1, i, a));
                } catch {
                }
              }
              return He.getImageData(e, 1);
            });
          }
          _getNeighboringTiles(e) {
            const i = e.canonical, a = Math.pow(2, i.z), o = (i.x - 1 + a) % a, u = i.x === 0 ? e.wrap - 1 : e.wrap, f = (i.x + 1 + a) % a, _ = i.x + 1 === a ? e.wrap + 1 : e.wrap, y = {};
            return y[new c.Y(e.overscaledZ, u, i.z, o, i.y).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, _, i.z, f, i.y).key] = { backfilled: !1 }, i.y > 0 && (y[new c.Y(e.overscaledZ, u, i.z, o, i.y - 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, _, i.z, f, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < a && (y[new c.Y(e.overscaledZ, u, i.z, o, i.y + 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, y[new c.Y(e.overscaledZ, _, i.z, f, i.y + 1).key] = { backfilled: !1 }), y;
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            });
          }
        }
        class Dr extends c.E {
          constructor(e, i, a, o) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = a.getActor(), this.setEventedParent(o), this._data = i.data, this._options = c.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: i.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128), tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : 0.375), extent: c.Z, maxZoom: this.maxzoom, lineMetrics: i.lineMetrics || !1, generateId: i.generateId || !1 }, superclusterOptions: { maxZoom: i.clusterMaxZoom !== void 0 ? i.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i.clusterMinPoints || 2), extent: c.Z, radius: this._pixelsToTileUnits(i.clusterRadius || 50), log: !1, generateId: i.generateId || !1 }, clusterProperties: i.clusterProperties, filter: i.filter }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (c.Z / this.tileSize);
          }
          load() {
            return c._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._updateWorkerData(e), this;
          }
          getData() {
            return c._(this, void 0, void 0, function* () {
              const e = c.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            });
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, i, a) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: i, offset: a } });
          }
          _updateWorkerData(e) {
            return c._(this, void 0, void 0, function* () {
              const i = c.e({ type: this.type }, this.workerOptions);
              e ? i.dataDiff = e : typeof this._data == "string" ? (i.request = this.map._requestManager.transformRequest(He.resolveURL(this._data), "Source"), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.l("dataloading", { dataType: "source" }));
              try {
                const a = yield this.actor.sendAsync({ type: "LD", data: i });
                if (this._pendingLoads--, this._removed || a.abandoned) return void this.fire(new c.l("dataabort", { dataType: "source" }));
                let o = null;
                a.resourceTiming && a.resourceTiming[this.id] && (o = a.resourceTiming[this.id].slice(0));
                const u = { dataType: "source" };
                this._collectResourceTiming && o && o.length > 0 && c.e(u, { resourceTiming: o }), this.fire(new c.l("data", Object.assign(Object.assign({}, u), { sourceDataType: "metadata" }))), this.fire(new c.l("data", Object.assign(Object.assign({}, u), { sourceDataType: "content" })));
              } catch (a) {
                if (this._pendingLoads--, this._removed) return void this.fire(new c.l("dataabort", { dataType: "source" }));
                this.fire(new c.k(a));
              }
            });
          }
          loaded() {
            return this._pendingLoads === 0;
          }
          loadTile(e) {
            return c._(this, void 0, void 0, function* () {
              const i = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const a = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e.abortController = new AbortController();
              const o = yield this.actor.sendAsync({ type: i, data: a }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(o, this.map.painter, i === "RT");
            });
          }
          abortTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
            });
          }
          unloadTile(e) {
            return c._(this, void 0, void 0, function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return c.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class ar extends c.E {
          constructor(e, i, a, o) {
            super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = a, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = i;
          }
          load(e) {
            return c._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const i = yield mi.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading());
              } catch (i) {
                this._request = null, this._loaded = !0, this.fire(new c.k(i));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const i = e.map(c.$.fromLngLat);
            var a;
            return this.tileID = function(o) {
              let u = 1 / 0, f = 1 / 0, _ = -1 / 0, y = -1 / 0;
              for (const M of o) u = Math.min(u, M.x), f = Math.min(f, M.y), _ = Math.max(_, M.x), y = Math.max(y, M.y);
              const v = Math.max(_ - u, y - f), T = Math.max(0, Math.floor(-Math.log(v) / Math.LN2)), S = Math.pow(2, T);
              return new c.a0(T, Math.floor((u + _) / 2 * S), Math.floor((f + y) / 2 * S));
            }(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((o) => this.tileID.getTilePoint(o)._round()), this.flippedWindingOrder = ((a = this.tileCoords)[1].x - a[0].x) * (a[2].y - a[0].y) - (a[1].y - a[0].y) * (a[2].x - a[0].x) < 0, this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, i = e.gl;
            this.texture || (this.texture = new zt(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let a = !1;
            for (const o in this.tiles) {
              const u = this.tiles[o];
              u.state !== "loaded" && (u.state = "loaded", u.texture = this.texture, a = !0);
            }
            a && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return c._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
        }
        class Hi extends ar {
          constructor(e, i, a, o) {
            super(e, i, a, o), this.roundZoom = !0, this.type = "video", this.options = i;
          }
          load() {
            return c._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
              try {
                const i = yield c.a1(this.urls);
                if (this._loaded = !0, !i) return;
                this.video = i, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (i) {
                this.fire(new c.k(i));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const i = this.video.seekable;
              e < i.start(0) || e > i.end(0) ? this.fire(new c.k(new c.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, i = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new zt(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
            let a = !1;
            for (const o in this.tiles) {
              const u = this.tiles[o];
              u.state !== "loaded" && (u.state = "loaded", u.texture = this.texture, a = !0);
            }
            a && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class An extends ar {
          constructor(e, i, a, o) {
            super(e, i, a, o), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some((u) => !Array.isArray(u) || u.length !== 2 || u.some((f) => typeof f != "number")) || this.fire(new c.k(new c.a2(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.k(new c.a2(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new c.k(new c.a2(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new c.k(new c.a2(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.k(new c.a2(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate;
          }
          load() {
            return c._(this, void 0, void 0, function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const i = this.map.painter.context, a = i.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new zt(i, this.canvas, a.RGBA, { premultiply: !0 });
            let o = !1;
            for (const u in this.tiles) {
              const f = this.tiles[u];
              f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, o = !0);
            }
            o && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        }
        const nn = {}, sn = (h) => {
          switch (h) {
            case "geojson":
              return Dr;
            case "image":
              return ar;
            case "raster":
              return Wi;
            case "raster-dem":
              return kr;
            case "vector":
              return rn;
            case "video":
              return Hi;
            case "canvas":
              return An;
          }
          return nn[h];
        }, zn = "RTLPluginLoaded";
        class an extends c.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = en();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((i) => {
              throw this.status = "error", i;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return c._(this, arguments, void 0, function* (i, a = !1) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = He.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`);
              if (this.status === "unavailable") {
                if (!a) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            });
          }
          _requestImport() {
            return c._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new c.l(zn));
            });
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let _r = null;
        function gr() {
          return _r || (_r = new an()), _r;
        }
        class Rr {
          constructor(e, i) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = c.a3(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const i = e + this.timeAdded;
            i < this.fadeEndTime || (this.fadeEndTime = i);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, i, a) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(o, u) {
                const f = {};
                if (!u) return f;
                for (const _ of o) {
                  const y = _.layerIds.map((v) => u.getLayer(v)).filter(Boolean);
                  if (y.length !== 0) {
                    _.layers = y, _.stateDependentLayerIds && (_.stateDependentLayers = _.stateDependentLayerIds.map((v) => y.filter((T) => T.id === v)[0]));
                    for (const v of y) f[v.id] = _;
                  }
                }
                return f;
              }(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1;
              for (const o in this.buckets) {
                const u = this.buckets[o];
                if (u instanceof c.a5) {
                  if (this.hasSymbolBuckets = !0, !a) break;
                  u.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const o in this.buckets) {
                const u = this.buckets[o];
                if (u instanceof c.a5 && u.hasRTLText) {
                  this.hasRTLText = !0, gr().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const o in this.buckets) {
                const u = this.buckets[o];
                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(o).queryRadius(u));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new c.a4();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const a in this.buckets) {
              const o = this.buckets[a];
              o.uploadPending() && o.upload(e);
            }
            const i = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new zt(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new zt(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, i, a, o, u, f, _, y, v, T) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o, cameraQueryGeometry: u, scale: f, tileSize: this.tileSize, pixelPosMatrix: T, transform: y, params: _, queryPadding: this.queryPadding * v }, e, i, a) : {};
          }
          querySourceFeatures(e, i) {
            const a = this.latestFeatureIndex;
            if (!a || !a.rawTileData) return;
            const o = a.loadVTLayers(), u = i && i.sourceLayer ? i.sourceLayer : "", f = o._geojsonTileLayer || o[u];
            if (!f) return;
            const _ = c.a6(i && i.filter), { z: y, x: v, y: T } = this.tileID.canonical, S = { z: y, x: v, y: T };
            for (let M = 0; M < f.length; M++) {
              const k = f.feature(M);
              if (_.needGeometry) {
                const j = c.a7(k, !0);
                if (!_.filter(new c.C(this.tileID.overscaledZ), j, this.tileID.canonical)) continue;
              } else if (!_.filter(new c.C(this.tileID.overscaledZ), k)) continue;
              const R = a.getId(k, u), V = new c.a8(k, y, v, T, R);
              V.tile = S, e.push(V);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const i = this.expirationTime;
            if (e.cacheControl) {
              const a = c.a9(e.cacheControl);
              a["max-age"] && (this.expirationTime = Date.now() + 1e3 * a["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const a = Date.now();
              let o = !1;
              if (this.expirationTime > a) o = !1;
              else if (i) if (this.expirationTime < i) o = !0;
              else {
                const u = this.expirationTime - i;
                u ? this.expirationTime = a + Math.max(u, 3e4) : o = !0;
              }
              else o = !0;
              o ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, i) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const a = this.latestFeatureIndex.loadVTLayers();
            for (const o in this.buckets) {
              if (!i.style.hasLayer(o)) continue;
              const u = this.buckets[o], f = u.layers[0].sourceLayer || "_geojsonTileLayer", _ = a[f], y = e[f];
              if (!_ || !y || Object.keys(y).length === 0) continue;
              u.update(y, _, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const v = i && i.style && i.style.getLayer(o);
              v && (this.queryPadding = Math.max(this.queryPadding, v.queryRadius(u)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < He.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = He.now() + e;
          }
          setDependencies(e, i) {
            const a = {};
            for (const o of i) a[o] = !0;
            this.dependencies[e] = a;
          }
          hasDependency(e, i) {
            for (const a of e) {
              const o = this.dependencies[a];
              if (o) {
                for (const u of i) if (o[u]) return !0;
              }
            }
            return !1;
          }
        }
        class Lr {
          constructor(e, i) {
            this.max = e, this.onRemove = i, this.reset();
          }
          reset() {
            for (const e in this.data) for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, i, a) {
            const o = e.wrapped().key;
            this.data[o] === void 0 && (this.data[o] = []);
            const u = { value: i, timeout: void 0 };
            if (a !== void 0 && (u.timeout = setTimeout(() => {
              this.remove(e, u);
            }, a)), this.data[o].push(u), this.order.push(o), this.order.length > this.max) {
              const f = this._getAndRemoveByKey(this.order[0]);
              f && this.onRemove(f);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const i = this.data[e].shift();
            return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value;
          }
          getByKey(e) {
            const i = this.data[e];
            return i ? i[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, i) {
            if (!this.has(e)) return this;
            const a = e.wrapped().key, o = i === void 0 ? 0 : this.data[a].indexOf(i), u = this.data[a][o];
            return this.data[a].splice(o, 1), u.timeout && clearTimeout(u.timeout), this.data[a].length === 0 && delete this.data[a], this.onRemove(u.value), this.order.splice(this.order.indexOf(a), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const i = this._getAndRemoveByKey(this.order[0]);
              i && this.onRemove(i);
            }
            return this;
          }
          filter(e) {
            const i = [];
            for (const a in this.data) for (const o of this.data[a]) e(o.value) || i.push(o);
            for (const a of i) this.remove(a.value.tileID, a);
          }
        }
        class ls {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, i, a) {
            const o = String(i);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][o] = this.stateChanges[e][o] || {}, c.e(this.stateChanges[e][o], a), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const u in this.state[e]) u !== o && (this.deletedStates[e][u] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][o] === null) {
              this.deletedStates[e][o] = {};
              for (const u in this.state[e][o]) a[u] || (this.deletedStates[e][o][u] = null);
            } else for (const u in a) this.deletedStates[e] && this.deletedStates[e][o] && this.deletedStates[e][o][u] === null && delete this.deletedStates[e][o][u];
          }
          removeFeatureState(e, i, a) {
            if (this.deletedStates[e] === null) return;
            const o = String(i);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, a && i !== void 0) this.deletedStates[e][o] !== null && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][a] = null);
            else if (i !== void 0) if (this.stateChanges[e] && this.stateChanges[e][o]) for (a in this.deletedStates[e][o] = {}, this.stateChanges[e][o]) this.deletedStates[e][o][a] = null;
            else this.deletedStates[e][o] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, i) {
            const a = String(i), o = c.e({}, (this.state[e] || {})[a], (this.stateChanges[e] || {})[a]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const u = this.deletedStates[e][i];
              if (u === null) return {};
              for (const f in u) delete o[f];
            }
            return o;
          }
          initializeTileState(e, i) {
            e.setFeatureState(this.state, i);
          }
          coalesceChanges(e, i) {
            const a = {};
            for (const o in this.stateChanges) {
              this.state[o] = this.state[o] || {};
              const u = {};
              for (const f in this.stateChanges[o]) this.state[o][f] || (this.state[o][f] = {}), c.e(this.state[o][f], this.stateChanges[o][f]), u[f] = this.state[o][f];
              a[o] = u;
            }
            for (const o in this.deletedStates) {
              this.state[o] = this.state[o] || {};
              const u = {};
              if (this.deletedStates[o] === null) for (const f in this.state[o]) u[f] = {}, this.state[o][f] = {};
              else for (const f in this.deletedStates[o]) {
                if (this.deletedStates[o][f] === null) this.state[o][f] = {};
                else for (const _ of Object.keys(this.deletedStates[o][f])) delete this.state[o][f][_];
                u[f] = this.state[o][f];
              }
              a[o] = a[o] || {}, c.e(a[o], u);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(a).length !== 0) for (const o in e) e[o].setFeatureState(a, i);
          }
        }
        function kn(h, e, i) {
          const a = e.intersectsFrustum(h);
          if (!i) return a;
          const o = e.intersectsPlane(i);
          return a === 0 || o === 0 ? 0 : a === 2 && o === 2 ? 2 : 1;
        }
        function cs(h, e, i, a, o) {
          let u = h;
          const f = Math.atan(e / i), _ = Math.hypot(e, i);
          return u = h + c.aa(a / _ / Math.max(0.5, Math.cos(c.ac(o / 2)))), u += 1 * c.aa(Math.cos(f)) / 2, u += c.ad(h - u, -0, 0), u;
        }
        function yr(h, e) {
          const i = (e.roundZoom ? Math.round : Math.floor)(h.zoom + c.aa(h.tileSize / e.tileSize));
          return Math.max(0, i);
        }
        function ie(h, e) {
          const i = h.getCameraFrustum(), a = h.getClippingPlane(), o = h.screenPointToMercatorCoordinate(h.getCameraPoint()), u = c.$.fromLngLat(h.center, h.elevation);
          o.z = u.z + Math.cos(h.pitchInRadians) * h.cameraToCenterDistance / h.worldSize;
          const f = h.getCoveringTilesDetailsProvider(), _ = f.allowVariableZoom(h, e), y = yr(h, e), v = e.minzoom || 0, T = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom, S = Math.min(Math.max(0, y), T), M = Math.pow(2, S), k = [M * o.x, M * o.y, 0], R = [M * u.x, M * u.y, 0], V = Math.hypot(u.x - o.x, u.y - o.y), j = Math.abs(u.z - o.z), N = Math.hypot(V, j), G = (K) => ({ zoom: 0, x: 0, y: 0, wrap: K, fullyVisible: !1 }), W = [], H = [];
          if (h.renderWorldCopies && f.allowWorldCopies()) for (let K = 1; K <= 3; K++) W.push(G(-K)), W.push(G(K));
          for (W.push(G(0)); W.length > 0; ) {
            const K = W.pop(), Q = K.x, J = K.y;
            let se = K.fullyVisible;
            const oe = { x: Q, y: J, z: K.zoom }, fe = f.getTileAABB(oe, K.wrap, h.elevation, e);
            if (!se) {
              const Se = kn(i, fe, a);
              if (Se === 0) continue;
              se = Se === 2;
            }
            const _e = f.distanceToTile2d(o.x, o.y, oe, fe);
            let pe = y;
            _ && (pe = (e.calculateTileZoom || cs)(h.zoom + c.aa(h.tileSize / e.tileSize), _e, j, N, h.fov)), pe = (e.roundZoom ? Math.round : Math.floor)(pe), pe = Math.max(0, pe);
            const Ie = Math.min(pe, T);
            if (K.wrap = f.getWrap(u, oe, K.wrap), K.zoom >= Ie) {
              if (K.zoom < v) continue;
              const Se = S - K.zoom, be = k[0] - 0.5 - (Q << Se), Re = k[1] - 0.5 - (J << Se), Oe = e.reparseOverscaled ? Math.max(K.zoom, pe) : K.zoom;
              H.push({ tileID: new c.Y(K.zoom === T ? Oe : K.zoom, K.wrap, K.zoom, Q, J), distanceSq: c.ab([R[0] - 0.5 - Q, R[1] - 0.5 - J]), tileDistanceToCamera: Math.sqrt(be * be + Re * Re) });
            } else for (let Se = 0; Se < 4; Se++) W.push({ zoom: K.zoom + 1, x: (Q << 1) + Se % 2, y: (J << 1) + (Se >> 1), wrap: K.wrap, fullyVisible: se });
          }
          return H.sort((K, Q) => K.distanceSq - Q.distanceSq).map((K) => K.tileID);
        }
        class P extends c.E {
          constructor(e, i, a) {
            super(), this.id = e, this.dispatcher = a, this.on("data", (o) => this._dataHandler(o)), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((o, u, f, _) => {
              const y = new (sn(u.type))(o, u, f, _);
              if (y.id !== o) throw new Error(`Expected Source id to be ${o} instead of ${y.id}`);
              return y;
            })(e, i, a, this), this._tiles = {}, this._cache = new Lr(0, (o) => this._unloadTile(o)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ls(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const e in this._tiles) {
              const i = this._tiles[e];
              if (i.state !== "loaded" && i.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, i, a) {
            return c._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, i, a);
              } catch (o) {
                e.state = "errored", o.status !== 404 ? this._source.fire(new c.k(o, { tile: e })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new c.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const i in this._tiles) {
              const a = this._tiles[i];
              a.upload(e), a.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e) => e.tileID).sort(L).map((e) => e.key);
          }
          getRenderableIds(e) {
            const i = [];
            for (const a in this._tiles) this._isIdRenderable(a, e) && i.push(this._tiles[a]);
            return e ? i.sort((a, o) => {
              const u = a.tileID, f = o.tileID, _ = new c.P(u.canonical.x, u.canonical.y)._rotate(-this.transform.bearingInRadians), y = new c.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians);
              return u.overscaledZ - f.overscaledZ || y.y - _.y || y.x - _.x;
            }).map((a) => a.tileID.key) : i.map((a) => a.tileID).sort(L).map((a) => a.key);
          }
          hasRenderableParent(e) {
            const i = this.findLoadedParent(e, 0);
            return !!i && this._isIdRenderable(i.tileID.key);
          }
          _isIdRenderable(e, i) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const i in this._tiles) (e || this._tiles[i].state !== "errored") && this._reloadTile(i, "reloading");
            }
          }
          _reloadTile(e, i) {
            return c._(this, void 0, void 0, function* () {
              const a = this._tiles[e];
              a && (a.state !== "loading" && (a.state = i), yield this._loadTile(a, e, i));
            });
          }
          _tileLoaded(e, i, a) {
            e.timeAdded = He.now(), a === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new c.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const i = this.getRenderableIds();
            for (let o = 0; o < i.length; o++) {
              const u = i[o];
              if (e.neighboringTiles && e.neighboringTiles[u]) {
                const f = this.getTileByID(u);
                a(e, f), a(f, e);
              }
            }
            function a(o, u) {
              o.needsHillshadePrepare = !0, o.needsTerrainPrepare = !0;
              let f = u.tileID.canonical.x - o.tileID.canonical.x;
              const _ = u.tileID.canonical.y - o.tileID.canonical.y, y = Math.pow(2, o.tileID.canonical.z), v = u.tileID.key;
              f === 0 && _ === 0 || Math.abs(_) > 1 || (Math.abs(f) > 1 && (Math.abs(f + y) === 1 ? f += y : Math.abs(f - y) === 1 && (f -= y)), u.dem && o.dem && (o.dem.backfillBorder(u.dem, f, _), o.neighboringTiles && o.neighboringTiles[v] && (o.neighboringTiles[v].backfilled = !0)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, i, a, o) {
            for (const u in this._tiles) {
              let f = this._tiles[u];
              if (o[u] || !f.hasData() || f.tileID.overscaledZ <= i || f.tileID.overscaledZ > a) continue;
              let _ = f.tileID;
              for (; f && f.tileID.overscaledZ > i + 1; ) {
                const v = f.tileID.scaledTo(f.tileID.overscaledZ - 1);
                f = this._tiles[v.key], f && f.hasData() && (_ = v);
              }
              let y = _;
              for (; y.overscaledZ > i; ) if (y = y.scaledTo(y.overscaledZ - 1), e[y.key] || e[y.canonical.key]) {
                o[_.key] = _;
                break;
              }
            }
          }
          findLoadedParent(e, i) {
            if (e.key in this._loadedParentTiles) {
              const a = this._loadedParentTiles[e.key];
              return a && a.tileID.overscaledZ >= i ? a : null;
            }
            for (let a = e.overscaledZ - 1; a >= i; a--) {
              const o = e.scaledTo(a), u = this._getLoadedTile(o);
              if (u) return u;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const i = this._tiles[e.key];
            return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const i = Math.ceil(e.width / this._source.tileSize) + 1, a = Math.ceil(e.height / this._source.tileSize) + 1, o = Math.floor(i * a * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), u = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, o) : o;
            this._cache.setMaxSize(u);
          }
          handleWrapJump(e) {
            const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, i) {
              const a = {};
              for (const o in this._tiles) {
                const u = this._tiles[o];
                u.tileID = u.tileID.unwrapTo(u.tileID.wrap + i), a[u.tileID.key] = u;
              }
              this._tiles = a;
              for (const o in this._timers) clearTimeout(this._timers[o]), delete this._timers[o];
              for (const o in this._tiles) this._setTileReloadTimer(o, this._tiles[o]);
            }
          }
          _updateCoveredAndRetainedTiles(e, i, a, o, u, f) {
            const _ = {}, y = {}, v = Object.keys(e), T = He.now();
            for (const S of v) {
              const M = e[S], k = this._tiles[S];
              if (!k || k.fadeEndTime !== 0 && k.fadeEndTime <= T) continue;
              const R = this.findLoadedParent(M, i), V = this.findLoadedSibling(M), j = R || V || null;
              j && (this._addTile(j.tileID), _[j.tileID.key] = j.tileID), y[S] = M;
            }
            this._retainLoadedChildren(y, o, a, e);
            for (const S in _) e[S] || (this._coveredTiles[S] = !0, e[S] = _[S]);
            if (f) {
              const S = {}, M = {};
              for (const k of u) this._tiles[k.key].hasData() ? S[k.key] = k : M[k.key] = k;
              for (const k in M) {
                const R = M[k].children(this._source.maxzoom);
                this._tiles[R[0].key] && this._tiles[R[1].key] && this._tiles[R[2].key] && this._tiles[R[3].key] && (S[R[0].key] = e[R[0].key] = R[0], S[R[1].key] = e[R[1].key] = R[1], S[R[2].key] = e[R[2].key] = R[2], S[R[3].key] = e[R[3].key] = R[3], delete M[k]);
              }
              for (const k in M) {
                const R = M[k], V = this.findLoadedParent(R, this._source.minzoom), j = this.findLoadedSibling(R), N = V || j || null;
                if (N) {
                  S[N.tileID.key] = e[N.tileID.key] = N.tileID;
                  for (const G in S) S[G].isChildOf(N.tileID) && delete S[G];
                }
              }
              for (const k in this._tiles) S[k] || (this._coveredTiles[k] = !0);
            }
          }
          update(e, i) {
            if (!this._sourceLoaded || this._paused) return;
            let a;
            this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? a = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((T) => new c.Y(T.canonical.z, T.wrap, T.canonical.z, T.canonical.x, T.canonical.y)) : (a = ie(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (a = a.filter((T) => this._source.hasTile(T)))) : a = [];
            const o = yr(e, this._source), u = Math.max(o - P.maxOverzooming, this._source.minzoom), f = Math.max(o + P.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const T = {};
              for (const S of a) if (S.canonical.z > this._source.minzoom) {
                const M = S.scaledTo(S.canonical.z - 1);
                T[M.key] = M;
                const k = S.scaledTo(Math.max(this._source.minzoom, Math.min(S.canonical.z, 5)));
                T[k.key] = k;
              }
              a = a.concat(Object.values(T));
            }
            const _ = a.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, _ && this.fire(new c.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const y = this._updateRetainedTiles(a, o);
            O(this._source.type) && this._updateCoveredAndRetainedTiles(y, u, f, o, a, i);
            for (const T in y) this._tiles[T].clearFadeHold();
            const v = c.ae(this._tiles, y);
            for (const T of v) {
              const S = this._tiles[T];
              S.hasSymbolBuckets && !S.holdingForFade() ? S.setHoldDuration(this.map._fadeDuration) : S.hasSymbolBuckets && !S.symbolFadeFinished() || this._removeTile(T);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, i) {
            var a;
            const o = {}, u = {}, f = Math.max(i - P.maxOverzooming, this._source.minzoom), _ = Math.max(i + P.maxUnderzooming, this._source.minzoom), y = {};
            for (const v of e) {
              const T = this._addTile(v);
              o[v.key] = v, T.hasData() || i < this._source.maxzoom && (y[v.key] = v);
            }
            this._retainLoadedChildren(y, i, _, o);
            for (const v of e) {
              let T = this._tiles[v.key];
              if (T.hasData()) continue;
              if (i + 1 > this._source.maxzoom) {
                const M = v.children(this._source.maxzoom)[0], k = this.getTile(M);
                if (k && k.hasData()) {
                  o[M.key] = M;
                  continue;
                }
              } else {
                const M = v.children(this._source.maxzoom);
                if (o[M[0].key] && o[M[1].key] && o[M[2].key] && o[M[3].key]) continue;
              }
              let S = T.wasRequested();
              for (let M = v.overscaledZ - 1; M >= f; --M) {
                const k = v.scaledTo(M);
                if (u[k.key]) break;
                if (u[k.key] = !0, T = this.getTile(k), !T && S && (T = this._addTile(k)), T) {
                  const R = T.hasData();
                  if ((R || !(!((a = this.map) === null || a === void 0) && a.cancelPendingTileRequestsWhileZooming) || S) && (o[k.key] = k), S = T.wasRequested(), R) break;
                }
              }
            }
            return o;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const i = [];
              let a, o = this._tiles[e].tileID;
              for (; o.overscaledZ > 0; ) {
                if (o.key in this._loadedParentTiles) {
                  a = this._loadedParentTiles[o.key];
                  break;
                }
                i.push(o.key);
                const u = o.scaledTo(o.overscaledZ - 1);
                if (a = this._getLoadedTile(u), a) break;
                o = u;
              }
              for (const u of i) this._loadedParentTiles[u] = a;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const i = this._tiles[e].tileID, a = this._getLoadedTile(i);
              this._loadedSiblingTiles[i.key] = a;
            }
          }
          _addTile(e) {
            let i = this._tiles[e.key];
            if (i) return i;
            i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));
            const a = i;
            return i || (i = new Rr(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, a || this._source.fire(new c.l("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i;
          }
          _setTileReloadTimer(e, i) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const a = i.getExpiryTimeout();
            a && (this._timers[e] = setTimeout(() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }, a));
          }
          _removeTile(e) {
            const i = this._tiles[e];
            i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i))));
          }
          _dataHandler(e) {
            const i = e.sourceDataType;
            e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, i, a) {
            const o = [], u = this.transform;
            if (!u) return o;
            const f = a ? u.getCameraQueryGeometry(e) : e, _ = e.map((R) => u.screenPointToMercatorCoordinate(R, this.terrain)), y = f.map((R) => u.screenPointToMercatorCoordinate(R, this.terrain)), v = this.getIds();
            let T = 1 / 0, S = 1 / 0, M = -1 / 0, k = -1 / 0;
            for (const R of y) T = Math.min(T, R.x), S = Math.min(S, R.y), M = Math.max(M, R.x), k = Math.max(k, R.y);
            for (let R = 0; R < v.length; R++) {
              const V = this._tiles[v[R]];
              if (V.holdingForFade()) continue;
              const j = V.tileID, N = Math.pow(2, u.zoom - V.tileID.overscaledZ), G = i * V.queryPadding * c.Z / V.tileSize / N, W = [j.getTilePoint(new c.$(T, S)), j.getTilePoint(new c.$(M, k))];
              if (W[0].x - G < c.Z && W[0].y - G < c.Z && W[1].x + G >= 0 && W[1].y + G >= 0) {
                const H = _.map((Q) => j.getTilePoint(Q)), K = y.map((Q) => j.getTilePoint(Q));
                o.push({ tile: V, tileID: j, queryGeometry: H, cameraQueryGeometry: K, scale: N });
              }
            }
            return o;
          }
          getVisibleCoordinates(e) {
            const i = this.getRenderableIds(e).map((a) => this._tiles[a].tileID);
            return this.transform && this.transform.populateCache(i), i;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (O(this._source.type)) {
              const e = He.now();
              for (const i in this._tiles) if (this._tiles[i].fadeEndTime >= e) return !0;
            }
            return !1;
          }
          setFeatureState(e, i, a) {
            this._state.updateState(e = e || "_geojsonTileLayer", i, a);
          }
          removeFeatureState(e, i, a) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, a);
          }
          getFeatureState(e, i) {
            return this._state.getState(e = e || "_geojsonTileLayer", i);
          }
          setDependencies(e, i, a) {
            const o = this._tiles[e];
            o && o.setDependencies(i, a);
          }
          reloadTilesForDependencies(e, i) {
            for (const a in this._tiles) this._tiles[a].hasDependency(e, i) && this._reloadTile(a, "reloading");
            this._cache.filter((a) => !a.hasDependency(e, i));
          }
        }
        function L(h, e) {
          const i = Math.abs(2 * h.wrap) - +(h.wrap < 0), a = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return h.overscaledZ - e.overscaledZ || a - i || e.canonical.y - h.canonical.y || e.canonical.x - h.canonical.x;
        }
        function O(h) {
          return h === "raster" || h === "image" || h === "video";
        }
        P.maxOverzooming = 10, P.maxUnderzooming = 3;
        class U {
          constructor(e, i) {
            this.reset(e, i);
          }
          reset(e, i) {
            this.points = e || [], this._distances = [0];
            for (let a = 1; a < this.points.length; a++) this._distances[a] = this._distances[a - 1] + this.points[a].dist(this.points[a - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = c.ad(e, 0, 1);
            let i = 1, a = this._distances[i];
            const o = e * this.paddedLength + this.padding;
            for (; a < o && i < this._distances.length; ) a = this._distances[++i];
            const u = i - 1, f = this._distances[u], _ = a - f, y = _ > 0 ? (o - f) / _ : 0;
            return this.points[u].mult(1 - y).add(this.points[i].mult(y));
          }
        }
        function X(h, e) {
          let i = !0;
          return h === "always" || h !== "never" && e !== "never" || (i = !1), i;
        }
        class te {
          constructor(e, i, a) {
            const o = this.boxCells = [], u = this.circleCells = [];
            this.xCellCount = Math.ceil(e / a), this.yCellCount = Math.ceil(i / a);
            for (let f = 0; f < this.xCellCount * this.yCellCount; f++) o.push([]), u.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, i, a, o, u) {
            this._forEachCell(i, a, o, u, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(a), this.bboxes.push(o), this.bboxes.push(u);
          }
          insertCircle(e, i, a, o) {
            this._forEachCell(i - o, a - o, i + o, a + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(a), this.circles.push(o);
          }
          _insertBoxCell(e, i, a, o, u, f) {
            this.boxCells[u].push(f);
          }
          _insertCircleCell(e, i, a, o, u, f) {
            this.circleCells[u].push(f);
          }
          _query(e, i, a, o, u, f, _) {
            if (a < 0 || e > this.width || o < 0 || i > this.height) return [];
            const y = [];
            if (e <= 0 && i <= 0 && this.width <= a && this.height <= o) {
              if (u) return [{ key: null, x1: e, y1: i, x2: a, y2: o }];
              for (let v = 0; v < this.boxKeys.length; v++) y.push({ key: this.boxKeys[v], x1: this.bboxes[4 * v], y1: this.bboxes[4 * v + 1], x2: this.bboxes[4 * v + 2], y2: this.bboxes[4 * v + 3] });
              for (let v = 0; v < this.circleKeys.length; v++) {
                const T = this.circles[3 * v], S = this.circles[3 * v + 1], M = this.circles[3 * v + 2];
                y.push({ key: this.circleKeys[v], x1: T - M, y1: S - M, x2: T + M, y2: S + M });
              }
            } else this._forEachCell(e, i, a, o, this._queryCell, y, { hitTest: u, overlapMode: f, seenUids: { box: {}, circle: {} } }, _);
            return y;
          }
          query(e, i, a, o) {
            return this._query(e, i, a, o, !1, null);
          }
          hitTest(e, i, a, o, u, f) {
            return this._query(e, i, a, o, !0, u, f).length > 0;
          }
          hitTestCircle(e, i, a, o, u) {
            const f = e - a, _ = e + a, y = i - a, v = i + a;
            if (_ < 0 || f > this.width || v < 0 || y > this.height) return !1;
            const T = [];
            return this._forEachCell(f, y, _, v, this._queryCellCircle, T, { hitTest: !0, overlapMode: o, circle: { x: e, y: i, radius: a }, seenUids: { box: {}, circle: {} } }, u), T.length > 0;
          }
          _queryCell(e, i, a, o, u, f, _, y) {
            const { seenUids: v, hitTest: T, overlapMode: S } = _, M = this.boxCells[u];
            if (M !== null) {
              const R = this.bboxes;
              for (const V of M) if (!v.box[V]) {
                v.box[V] = !0;
                const j = 4 * V, N = this.boxKeys[V];
                if (e <= R[j + 2] && i <= R[j + 3] && a >= R[j + 0] && o >= R[j + 1] && (!y || y(N)) && (!T || !X(S, N.overlapMode)) && (f.push({ key: N, x1: R[j], y1: R[j + 1], x2: R[j + 2], y2: R[j + 3] }), T)) return !0;
              }
            }
            const k = this.circleCells[u];
            if (k !== null) {
              const R = this.circles;
              for (const V of k) if (!v.circle[V]) {
                v.circle[V] = !0;
                const j = 3 * V, N = this.circleKeys[V];
                if (this._circleAndRectCollide(R[j], R[j + 1], R[j + 2], e, i, a, o) && (!y || y(N)) && (!T || !X(S, N.overlapMode))) {
                  const G = R[j], W = R[j + 1], H = R[j + 2];
                  if (f.push({ key: N, x1: G - H, y1: W - H, x2: G + H, y2: W + H }), T) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(e, i, a, o, u, f, _, y) {
            const { circle: v, seenUids: T, overlapMode: S } = _, M = this.boxCells[u];
            if (M !== null) {
              const R = this.bboxes;
              for (const V of M) if (!T.box[V]) {
                T.box[V] = !0;
                const j = 4 * V, N = this.boxKeys[V];
                if (this._circleAndRectCollide(v.x, v.y, v.radius, R[j + 0], R[j + 1], R[j + 2], R[j + 3]) && (!y || y(N)) && !X(S, N.overlapMode)) return f.push(!0), !0;
              }
            }
            const k = this.circleCells[u];
            if (k !== null) {
              const R = this.circles;
              for (const V of k) if (!T.circle[V]) {
                T.circle[V] = !0;
                const j = 3 * V, N = this.circleKeys[V];
                if (this._circlesCollide(R[j], R[j + 1], R[j + 2], v.x, v.y, v.radius) && (!y || y(N)) && !X(S, N.overlapMode)) return f.push(!0), !0;
              }
            }
          }
          _forEachCell(e, i, a, o, u, f, _, y) {
            const v = this._convertToXCellCoord(e), T = this._convertToYCellCoord(i), S = this._convertToXCellCoord(a), M = this._convertToYCellCoord(o);
            for (let k = v; k <= S; k++) for (let R = T; R <= M; R++) if (u.call(this, e, i, a, o, this.xCellCount * R + k, f, _, y)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, i, a, o, u, f) {
            const _ = o - e, y = u - i, v = a + f;
            return v * v > _ * _ + y * y;
          }
          _circleAndRectCollide(e, i, a, o, u, f, _) {
            const y = (f - o) / 2, v = Math.abs(e - (o + y));
            if (v > y + a) return !1;
            const T = (_ - u) / 2, S = Math.abs(i - (u + T));
            if (S > T + a) return !1;
            if (v <= y || S <= T) return !0;
            const M = v - y, k = S - T;
            return M * M + k * k <= a * a;
          }
        }
        function le(h, e, i) {
          const a = c.K();
          if (!h) {
            const { vecSouth: S, vecEast: M } = me(e), k = Mr();
            k[0] = M[0], k[1] = M[1], k[2] = S[0], k[3] = S[1], o = k, (T = (f = (u = k)[0]) * (v = u[3]) - (y = u[2]) * (_ = u[1])) && (o[0] = v * (T = 1 / T), o[1] = -_ * T, o[2] = -y * T, o[3] = f * T), a[0] = k[0], a[1] = k[1], a[4] = k[2], a[5] = k[3];
          }
          var o, u, f, _, y, v, T;
          return c.M(a, a, [1 / i, 1 / i, 1]), a;
        }
        function ee(h, e, i, a) {
          if (h) {
            const o = c.K();
            if (!e) {
              const { vecSouth: u, vecEast: f } = me(i);
              o[0] = f[0], o[1] = f[1], o[4] = u[0], o[5] = u[1];
            }
            return c.M(o, o, [a, a, 1]), o;
          }
          return i.pixelsToClipSpaceMatrix;
        }
        function me(h) {
          const e = Math.cos(h.rollInRadians), i = Math.sin(h.rollInRadians), a = Math.cos(h.pitchInRadians), o = Math.cos(h.bearingInRadians), u = Math.sin(h.bearingInRadians), f = c.aj();
          f[0] = -o * a * i - u * e, f[1] = -u * a * i + o * e;
          const _ = c.ak(f);
          _ < 1e-9 ? c.al(f) : c.am(f, f, 1 / _);
          const y = c.aj();
          y[0] = o * a * e - u * i, y[1] = u * a * e + o * i;
          const v = c.ak(y);
          return v < 1e-9 ? c.al(y) : c.am(y, y, 1 / v), { vecEast: y, vecSouth: f };
        }
        function he(h, e, i, a) {
          let o;
          a ? (o = [h, e, a(h, e), 1], c.ao(o, o, i)) : (o = [h, e, 0, 1], Nt(o, o, i));
          const u = o[3];
          return { point: new c.P(o[0] / u, o[1] / u), signedDistanceFromCamera: u, isOccluded: !1 };
        }
        function re(h, e) {
          return 0.5 + h / e * 0.5;
        }
        function xe(h, e) {
          return h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1];
        }
        function ne(h, e, i, a, o, u, f, _, y, v, T, S, M) {
          const k = i ? h.textSizeData : h.iconSizeData, R = c.af(k, e.transform.zoom), V = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], j = i ? h.text.dynamicLayoutVertexArray : h.icon.dynamicLayoutVertexArray;
          j.clear();
          const N = h.lineVertexArray, G = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray, W = e.transform.width / e.transform.height;
          let H = !1;
          for (let K = 0; K < G.length; K++) {
            const Q = G.get(K);
            if (Q.hidden || Q.writingMode === c.ag.vertical && !H) {
              Ft(Q.numGlyphs, j);
              continue;
            }
            H = !1;
            const J = new c.P(Q.anchorX, Q.anchorY), se = { getElevation: M, pitchedLabelPlaneMatrix: a, lineVertexArray: N, pitchWithMap: u, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: J, unwrappedTileID: y, width: v, height: T, translation: S }, oe = Ke(Q.anchorX, Q.anchorY, se);
            if (!xe(oe.point, V)) {
              Ft(Q.numGlyphs, j);
              continue;
            }
            const fe = re(e.transform.cameraToCenterDistance, oe.signedDistanceFromCamera), _e = c.ah(k, R, Q), pe = u ? _e * e.transform.getPitchedTextCorrection(Q.anchorX, Q.anchorY, y) / fe : _e * fe, Ie = We({ projectionContext: se, pitchedLabelPlaneMatrixInverse: o, symbol: Q, fontSize: pe, flip: !1, keepUpright: f, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: j, aspectRatio: W, rotateToLine: _ });
            H = Ie.useVertical, (Ie.notEnoughRoom || H || Ie.needsFlipping && We({ projectionContext: se, pitchedLabelPlaneMatrixInverse: o, symbol: Q, fontSize: pe, flip: !0, keepUpright: f, glyphOffsetArray: h.glyphOffsetArray, dynamicLayoutVertexArray: j, aspectRatio: W, rotateToLine: _ }).notEnoughRoom) && Ft(Q.numGlyphs, j);
          }
          i ? h.text.dynamicLayoutVertexBuffer.updateData(j) : h.icon.dynamicLayoutVertexBuffer.updateData(j);
        }
        function Ce(h, e, i, a, o, u, f, _) {
          const y = u.glyphStartIndex + u.numGlyphs, v = u.lineStartIndex, T = u.lineStartIndex + u.lineLength, S = e.getoffsetX(u.glyphStartIndex), M = e.getoffsetX(y - 1), k = je(h * S, i, a, o, u.segment, v, T, _, f);
          if (!k) return null;
          const R = je(h * M, i, a, o, u.segment, v, T, _, f);
          return R ? _.projectionCache.anyProjectionOccluded ? null : { first: k, last: R } : null;
        }
        function Be(h, e, i, a) {
          return h === c.ag.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * a ? { useVertical: !0 } : (h === c.ag.vertical ? e.y < i.y : e.x > i.x) ? { needsFlipping: !0 } : null;
        }
        function We(h) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: i, symbol: a, fontSize: o, flip: u, keepUpright: f, glyphOffsetArray: _, dynamicLayoutVertexArray: y, aspectRatio: v, rotateToLine: T } = h, S = o / 24, M = a.lineOffsetX * S, k = a.lineOffsetY * S;
          let R;
          if (a.numGlyphs > 1) {
            const V = a.glyphStartIndex + a.numGlyphs, j = a.lineStartIndex, N = a.lineStartIndex + a.lineLength, G = Ce(S, _, M, k, u, a, T, e);
            if (!G) return { notEnoughRoom: !0 };
            const W = ke(G.first.point.x, G.first.point.y, e, i), H = ke(G.last.point.x, G.last.point.y, e, i);
            if (f && !u) {
              const K = Be(a.writingMode, W, H, v);
              if (K) return K;
            }
            R = [G.first];
            for (let K = a.glyphStartIndex + 1; K < V - 1; K++) R.push(je(S * _.getoffsetX(K), M, k, u, a.segment, j, N, e, T));
            R.push(G.last);
          } else {
            if (f && !u) {
              const j = De(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, N = a.lineStartIndex + a.segment + 1, G = new c.P(e.lineVertexArray.getx(N), e.lineVertexArray.gety(N)), W = De(G.x, G.y, e), H = W.signedDistanceFromCamera > 0 ? W.point : $e(e.tileAnchorPoint, G, j, 1, e), K = ke(j.x, j.y, e, i), Q = ke(H.x, H.y, e, i), J = Be(a.writingMode, K, Q, v);
              if (J) return J;
            }
            const V = je(S * _.getoffsetX(a.glyphStartIndex), M, k, u, a.segment, a.lineStartIndex, a.lineStartIndex + a.lineLength, e, T);
            if (!V || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            R = [V];
          }
          for (const V of R) c.an(y, V.point, V.angle);
          return {};
        }
        function $e(h, e, i, a, o) {
          const u = h.add(h.sub(e)._unit()), f = De(u.x, u.y, o).point, _ = i.sub(f);
          return i.add(_._mult(a / _.mag()));
        }
        function ye(h, e, i) {
          const a = e.projectionCache;
          if (a.projections[h]) return a.projections[h];
          const o = new c.P(e.lineVertexArray.getx(h), e.lineVertexArray.gety(h)), u = De(o.x, o.y, e);
          if (u.signedDistanceFromCamera > 0) return a.projections[h] = u.point, a.anyProjectionOccluded = a.anyProjectionOccluded || u.isOccluded, u.point;
          const f = h - i.direction;
          return $e(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new c.P(e.lineVertexArray.getx(f), e.lineVertexArray.gety(f)), o, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e);
        }
        function De(h, e, i) {
          const a = h + i.translation[0], o = e + i.translation[1];
          let u;
          return i.pitchWithMap ? (u = he(a, o, i.pitchedLabelPlaneMatrix, i.getElevation), u.isOccluded = !1) : (u = i.transform.projectTileCoordinates(a, o, i.unwrappedTileID, i.getElevation), u.point.x = (0.5 * u.point.x + 0.5) * i.width, u.point.y = (0.5 * -u.point.y + 0.5) * i.height), u;
        }
        function ke(h, e, i, a) {
          if (i.pitchWithMap) {
            const o = [h, e, 0, 1];
            return c.ao(o, o, a), i.transform.projectTileCoordinates(o[0] / o[3], o[1] / o[3], i.unwrappedTileID, i.getElevation).point;
          }
          return { x: h / i.width * 2 - 1, y: e / i.height * 2 - 1 };
        }
        function Ke(h, e, i) {
          return i.transform.projectTileCoordinates(h, e, i.unwrappedTileID, i.getElevation);
        }
        function qe(h, e, i) {
          return h._unit()._perp()._mult(e * i);
        }
        function Je(h, e, i, a, o, u, f, _, y) {
          if (_.projectionCache.offsets[h]) return _.projectionCache.offsets[h];
          const v = i.add(e);
          if (h + y.direction < a || h + y.direction >= o) return _.projectionCache.offsets[h] = v, v;
          const T = ye(h + y.direction, _, y), S = qe(T.sub(i), f, y.direction), M = i.add(S), k = T.add(S);
          return _.projectionCache.offsets[h] = c.ap(u, v, M, k) || v, _.projectionCache.offsets[h];
        }
        function je(h, e, i, a, o, u, f, _, y) {
          const v = a ? h - e : h + e;
          let T = v > 0 ? 1 : -1, S = 0;
          a && (T *= -1, S = Math.PI), T < 0 && (S += Math.PI);
          let M, k = T > 0 ? u + o : u + o + 1;
          _.projectionCache.cachedAnchorPoint ? M = _.projectionCache.cachedAnchorPoint : (M = De(_.tileAnchorPoint.x, _.tileAnchorPoint.y, _).point, _.projectionCache.cachedAnchorPoint = M);
          let R, V, j = M, N = M, G = 0, W = 0;
          const H = Math.abs(v), K = [];
          let Q;
          for (; G + W <= H; ) {
            if (k += T, k < u || k >= f) return null;
            G += W, N = j, V = R;
            const oe = { absOffsetX: H, direction: T, distanceFromAnchor: G, previousVertex: N };
            if (j = ye(k, _, oe), i === 0) K.push(N), Q = j.sub(N);
            else {
              let fe;
              const _e = j.sub(N);
              fe = _e.mag() === 0 ? qe(ye(k + T, _, oe).sub(j), i, T) : qe(_e, i, T), V || (V = N.add(fe)), R = Je(k, fe, j, u, f, V, i, _, oe), K.push(V), Q = R.sub(V);
            }
            W = Q.mag();
          }
          const J = Q._mult((H - G) / W)._add(V || N), se = S + Math.atan2(j.y - N.y, j.x - N.x);
          return K.push(J), { point: J, angle: y ? se : 0, path: K };
        }
        const on = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Ft(h, e) {
          for (let i = 0; i < h; i++) {
            const a = e.length;
            e.resize(a + 4), e.float32.set(on, 3 * a);
          }
        }
        function Nt(h, e, i) {
          const a = e[0], o = e[1];
          return h[0] = i[0] * a + i[4] * o + i[12], h[1] = i[1] * a + i[5] * o + i[13], h[3] = i[3] * a + i[7] * o + i[15], h;
        }
        const yt = 100;
        class Fs {
          constructor(e, i = new te(e.width + 200, e.height + 200, 25), a = new te(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = i, this.ignoredGrid = a, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + yt, this.screenBottomBoundary = e.height + yt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, i, a, o, u, f, _, y, v, T, S, M) {
            const k = this.projectAndGetPerspectiveRatio(e.anchorPointX + y[0], e.anchorPointY + y[1], u, T, M), R = a * k.perspectiveRatio;
            let V;
            if (f || _) V = this._projectCollisionBox(e, R, o, u, f, _, y, k, T, S, M);
            else {
              const Q = k.x + (S ? S.x * R : 0), J = k.y + (S ? S.y * R : 0);
              V = { allPointsOccluded: !1, box: [Q + e.x1 * R, J + e.y1 * R, Q + e.x2 * R, J + e.y2 * R] };
            }
            const [j, N, G, W] = V.box, H = f ? V.allPointsOccluded : k.isOccluded;
            let K = H;
            return K || (K = k.perspectiveRatio < this.perspectiveRatioCutoff), K || (K = !this.isInsideGrid(j, N, G, W)), K || i !== "always" && this.grid.hitTest(j, N, G, W, i, v) ? { box: [j, N, G, W], placeable: !1, offscreen: !1, occluded: H } : { box: [j, N, G, W], placeable: !0, offscreen: this.isOffscreen(j, N, G, W), occluded: H };
          }
          placeCollisionCircles(e, i, a, o, u, f, _, y, v, T, S, M, k, R) {
            const V = [], j = new c.P(i.anchorX, i.anchorY), N = this.getPerspectiveRatio(j.x, j.y, f, R), G = (v ? u * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, f) / N : u * N) / c.au, W = { getElevation: R, pitchedLabelPlaneMatrix: _, lineVertexArray: a, pitchWithMap: v, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: j, unwrappedTileID: f, width: this.transform.width, height: this.transform.height, translation: k }, H = Ce(G, o, i.lineOffsetX * G, i.lineOffsetY * G, !1, i, !1, W);
            let K = !1, Q = !1, J = !0;
            if (H) {
              const se = 0.5 * S * N + M, oe = new c.P(-100, -100), fe = new c.P(this.screenRightBoundary, this.screenBottomBoundary), _e = new U(), pe = H.first, Ie = H.last;
              let Se = [];
              for (let Oe = pe.path.length - 1; Oe >= 1; Oe--) Se.push(pe.path[Oe]);
              for (let Oe = 1; Oe < Ie.path.length; Oe++) Se.push(Ie.path[Oe]);
              const be = 2.5 * se;
              if (v) {
                const Oe = this.projectPathToScreenSpace(Se, W);
                Se = Oe.some((lt) => lt.signedDistanceFromCamera <= 0) ? [] : Oe.map((lt) => lt.point);
              }
              let Re = [];
              if (Se.length > 0) {
                const Oe = Se[0].clone(), lt = Se[0].clone();
                for (let _t = 1; _t < Se.length; _t++) Oe.x = Math.min(Oe.x, Se[_t].x), Oe.y = Math.min(Oe.y, Se[_t].y), lt.x = Math.max(lt.x, Se[_t].x), lt.y = Math.max(lt.y, Se[_t].y);
                Re = Oe.x >= oe.x && lt.x <= fe.x && Oe.y >= oe.y && lt.y <= fe.y ? [Se] : lt.x < oe.x || Oe.x > fe.x || lt.y < oe.y || Oe.y > fe.y ? [] : c.aq([Se], oe.x, oe.y, fe.x, fe.y);
              }
              for (const Oe of Re) {
                _e.reset(Oe, 0.25 * se);
                let lt = 0;
                lt = _e.length <= 0.5 * se ? 1 : Math.ceil(_e.paddedLength / be) + 1;
                for (let _t = 0; _t < lt; _t++) {
                  const ut = _t / Math.max(lt - 1, 1), Pt = _e.lerp(ut), xt = Pt.x + yt, ct = Pt.y + yt;
                  V.push(xt, ct, se, 0);
                  const dt = xt - se, Kt = ct - se, Jt = xt + se, Zt = ct + se;
                  if (J = J && this.isOffscreen(dt, Kt, Jt, Zt), Q = Q || this.isInsideGrid(dt, Kt, Jt, Zt), e !== "always" && this.grid.hitTestCircle(xt, ct, se, e, T) && (K = !0, !y)) return { circles: [], offscreen: !1, collisionDetected: K };
                }
              }
            }
            return { circles: !y && K || !Q || N < this.perspectiveRatioCutoff ? [] : V, offscreen: J, collisionDetected: K };
          }
          projectPathToScreenSpace(e, i) {
            const a = function(o, u) {
              const f = c.K();
              return c.ai(f, u.pitchedLabelPlaneMatrix), o.map((_) => {
                const y = he(_.x, _.y, f, u.getElevation), v = u.transform.projectTileCoordinates(y.point.x, y.point.y, u.unwrappedTileID, u.getElevation);
                return v.point.x = (0.5 * v.point.x + 0.5) * u.width, v.point.y = (0.5 * -v.point.y + 0.5) * u.height, v;
              });
            }(e, i);
            return function(o) {
              let u = 0, f = 0, _ = 0, y = 0;
              for (let v = 0; v < o.length; v++) o[v].isOccluded ? (_ = v + 1, y = 0) : (y++, y > f && (f = y, u = _));
              return o.slice(u, u + f);
            }(a);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const i = [];
            let a = 1 / 0, o = 1 / 0, u = -1 / 0, f = -1 / 0;
            for (const T of e) {
              const S = new c.P(T.x + yt, T.y + yt);
              a = Math.min(a, S.x), o = Math.min(o, S.y), u = Math.max(u, S.x), f = Math.max(f, S.y), i.push(S);
            }
            const _ = this.grid.query(a, o, u, f).concat(this.ignoredGrid.query(a, o, u, f)), y = {}, v = {};
            for (const T of _) {
              const S = T.key;
              if (y[S.bucketInstanceId] === void 0 && (y[S.bucketInstanceId] = {}), y[S.bucketInstanceId][S.featureIndex]) continue;
              const M = [new c.P(T.x1, T.y1), new c.P(T.x2, T.y1), new c.P(T.x2, T.y2), new c.P(T.x1, T.y2)];
              c.ar(i, M) && (y[S.bucketInstanceId][S.featureIndex] = !0, v[S.bucketInstanceId] === void 0 && (v[S.bucketInstanceId] = []), v[S.bucketInstanceId].push(S.featureIndex));
            }
            return v;
          }
          insertCollisionBox(e, i, a, o, u, f) {
            (a ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o, featureIndex: u, collisionGroupID: f, overlapMode: i }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, i, a, o, u, f) {
            const _ = a ? this.ignoredGrid : this.grid, y = { bucketInstanceId: o, featureIndex: u, collisionGroupID: f, overlapMode: i };
            for (let v = 0; v < e.length; v += 4) _.insertCircle(y, e[v], e[v + 1], e[v + 2]);
          }
          projectAndGetPerspectiveRatio(e, i, a, o, u) {
            if (u) {
              let f;
              o ? (f = [e, i, o(e, i), 1], c.ao(f, f, u)) : (f = [e, i, 0, 1], Nt(f, f, u));
              const _ = f[3];
              return { x: (f[0] / _ + 1) / 2 * this.transform.width + yt, y: (-f[1] / _ + 1) / 2 * this.transform.height + yt, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / _ * 0.5, isOccluded: !1, signedDistanceFromCamera: _ };
            }
            {
              const f = this.transform.projectTileCoordinates(e, i, a, o);
              return { x: (f.point.x + 1) / 2 * this.transform.width + yt, y: (1 - f.point.y) / 2 * this.transform.height + yt, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * 0.5, isOccluded: f.isOccluded, signedDistanceFromCamera: f.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, i, a, o) {
            const u = this.transform.projectTileCoordinates(e, i, a, o);
            return 0.5 + this.transform.cameraToCenterDistance / u.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, i, a, o) {
            return a < yt || e >= this.screenRightBoundary || o < yt || i > this.screenBottomBoundary;
          }
          isInsideGrid(e, i, a, o) {
            return a >= 0 && e < this.gridRightBoundary && o >= 0 && i < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = c.as([]);
            return c.L(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, i, a, o, u, f, _, y, v, T, S) {
            let M = 1, k = 0, R = 0, V = 1;
            const j = e.anchorPointX + _[0], N = e.anchorPointY + _[1];
            if (f && !u) {
              const Se = this.projectAndGetPerspectiveRatio(j + 1, N, o, v, S), be = Se.x - y.x, Re = Math.atan((Se.y - y.y) / be) + (be < 0 ? Math.PI : 0), Oe = Math.sin(Re), lt = Math.cos(Re);
              M = lt, k = Oe, R = -Oe, V = lt;
            } else if (!f && u) {
              const Se = me(this.transform);
              M = Se.vecEast[0], k = Se.vecEast[1], R = Se.vecSouth[0], V = Se.vecSouth[1];
            }
            let G = y.x, W = y.y, H = i;
            u && (G = j, W = N, H = Math.pow(2, -(this.transform.zoom - a.overscaledZ)), H *= this.transform.getPitchedTextCorrection(j, N, o), T || (H *= c.ad(0.5 + y.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), T && (G += M * T.x * H + R * T.y * H, W += k * T.x * H + V * T.y * H);
            const K = e.x1 * H, Q = e.x2 * H, J = (K + Q) / 2, se = e.y1 * H, oe = e.y2 * H, fe = (se + oe) / 2, _e = [{ offsetX: K, offsetY: se }, { offsetX: J, offsetY: se }, { offsetX: Q, offsetY: se }, { offsetX: Q, offsetY: fe }, { offsetX: Q, offsetY: oe }, { offsetX: J, offsetY: oe }, { offsetX: K, offsetY: oe }, { offsetX: K, offsetY: fe }];
            let pe = [];
            for (const { offsetX: Se, offsetY: be } of _e) pe.push(new c.P(G + M * Se + R * be, W + k * Se + V * be));
            let Ie = !1;
            if (u) {
              const Se = pe.map((be) => this.projectAndGetPerspectiveRatio(be.x, be.y, o, v, S));
              Ie = Se.some((be) => !be.isOccluded), pe = Se.map((be) => new c.P(be.x, be.y));
            } else Ie = !0;
            return { box: c.at(pe), allPointsOccluded: !Ie };
          }
        }
        class yi {
          constructor(e, i, a, o) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : o && a ? 1 : 0, this.placed = a;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class pt {
          constructor(e, i, a, o, u) {
            this.text = new yi(e ? e.text : null, i, a, u), this.icon = new yi(e ? e.icon : null, i, o, u);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class dl {
          constructor(e, i, a) {
            this.text = e, this.icon = i, this.skipFade = a;
          }
        }
        class hs {
          constructor(e, i, a, o, u) {
            this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = a, this.bucketIndex = o, this.tileID = u;
          }
        }
        class Ga {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const i = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: i, predicate: (a) => a.collisionGroupID === i };
            }
            return this.collisionGroups[e];
          }
        }
        function Br(h, e, i, a, o) {
          const { horizontalAlign: u, verticalAlign: f } = c.aA(h);
          return new c.P(-(u - 0.5) * e + a[0] * o, -(f - 0.5) * i + a[1] * o);
        }
        class Dn {
          constructor(e, i, a, o, u) {
            this.transform = e.clone(), this.terrain = i, this.collisionIndex = new Fs(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = a, this.retainedQueryData = {}, this.collisionGroups = new Ga(o), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = u, u && (u.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const i = this.terrain;
            return i ? (a, o) => i.getElevation(e, a, o) : null;
          }
          getBucketParts(e, i, a, o) {
            const u = a.getBucket(i), f = a.latestFeatureIndex;
            if (!u || !f || i.id !== u.layerIds[0]) return;
            const _ = a.collisionBoxArray, y = u.layers[0].layout, v = u.layers[0].paint, T = Math.pow(2, this.transform.zoom - a.tileID.overscaledZ), S = a.tileSize / c.Z, M = a.tileID.toUnwrapped(), k = y.get("text-rotation-alignment") === "map", R = c.av(a, 1, this.transform.zoom), V = c.aw(this.collisionIndex.transform, a, v.get("text-translate"), v.get("text-translate-anchor")), j = c.aw(this.collisionIndex.transform, a, v.get("icon-translate"), v.get("icon-translate-anchor")), N = le(k, this.transform, R);
            this.retainedQueryData[u.bucketInstanceId] = new hs(u.bucketInstanceId, f, u.sourceLayerIndex, u.index, a.tileID);
            const G = { bucket: u, layout: y, translationText: V, translationIcon: j, unwrappedTileID: M, pitchedLabelPlaneMatrix: N, scale: T, textPixelRatio: S, holdingForFade: a.holdingForFade(), collisionBoxArray: _, partiallyEvaluatedTextSize: c.af(u.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(u.sourceID) };
            if (o) for (const W of u.sortKeyRanges) {
              const { sortKey: H, symbolInstanceStart: K, symbolInstanceEnd: Q } = W;
              e.push({ sortKey: H, symbolInstanceStart: K, symbolInstanceEnd: Q, parameters: G });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: u.symbolInstances.length, parameters: G });
          }
          attemptAnchorPlacement(e, i, a, o, u, f, _, y, v, T, S, M, k, R, V, j, N, G, W, H) {
            const K = c.ax[e.textAnchor], Q = [e.textOffset0, e.textOffset1], J = Br(K, a, o, Q, u), se = this.collisionIndex.placeCollisionBox(i, M, y, v, T, _, f, j, S.predicate, W, J, H);
            if ((!G || this.collisionIndex.placeCollisionBox(G, M, y, v, T, _, f, N, S.predicate, W, J, H).placeable) && se.placeable) {
              let oe;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[k.crossTileID] && this.prevPlacement.placements[k.crossTileID] && this.prevPlacement.placements[k.crossTileID].text && (oe = this.prevPlacement.variableOffsets[k.crossTileID].anchor), k.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[k.crossTileID] = { textOffset: Q, width: a, height: o, anchor: K, textBoxScale: u, prevAnchor: oe }, this.markUsedJustification(R, K, k, V), R.allowVerticalPlacement && (this.markUsedOrientation(R, V, k), this.placedOrientations[k.crossTileID] = V), { shift: J, placedGlyphBoxes: se };
            }
          }
          placeLayerBucketPart(e, i, a) {
            const { bucket: o, layout: u, translationText: f, translationIcon: _, unwrappedTileID: y, pitchedLabelPlaneMatrix: v, textPixelRatio: T, holdingForFade: S, collisionBoxArray: M, partiallyEvaluatedTextSize: k, collisionGroup: R } = e.parameters, V = u.get("text-optional"), j = u.get("icon-optional"), N = c.ay(u, "text-overlap", "text-allow-overlap"), G = N === "always", W = c.ay(u, "icon-overlap", "icon-allow-overlap"), H = W === "always", K = u.get("text-rotation-alignment") === "map", Q = u.get("text-pitch-alignment") === "map", J = u.get("icon-text-fit") !== "none", se = u.get("symbol-z-order") === "viewport-y", oe = G && (H || !o.hasIconData() || j), fe = H && (G || !o.hasTextData() || V);
            !o.collisionArrays && M && o.deserializeCollisionBoxes(M);
            const _e = this.retainedQueryData[o.bucketInstanceId].tileID, pe = this._getTerrainElevationFunc(_e), Ie = this.transform.getFastPathSimpleProjectionMatrix(_e), Se = (be, Re, Oe) => {
              var lt, _t;
              if (i[be.crossTileID]) return;
              if (S) return void (this.placements[be.crossTileID] = new dl(!1, !1, !1));
              let ut = !1, Pt = !1, xt = !0, ct = null, dt = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Kt = { placeable: !1 }, Jt = null, Zt = null, ni = null, Ur = 0, br = 0, ur = 0;
              Re.textFeatureIndex ? Ur = Re.textFeatureIndex : be.useRuntimeCollisionCircles && (Ur = be.featureIndex), Re.verticalTextFeatureIndex && (br = Re.verticalTextFeatureIndex);
              const Ui = Re.textBox;
              if (Ui) {
                const Gi = (gt) => {
                  let ft = c.ag.horizontal;
                  if (o.allowVerticalPlacement && !gt && this.prevPlacement) {
                    const Ut = this.prevPlacement.placedOrientations[be.crossTileID];
                    Ut && (this.placedOrientations[be.crossTileID] = Ut, ft = Ut, this.markUsedOrientation(o, ft, be));
                  }
                  return ft;
                }, dr = (gt, ft) => {
                  if (o.allowVerticalPlacement && be.numVerticalGlyphVertices > 0 && Re.verticalTextBox) {
                    for (const Ut of o.writingModes) if (Ut === c.ag.vertical ? (dt = ft(), Kt = dt) : dt = gt(), dt && dt.placeable) break;
                  } else dt = gt();
                }, Yi = be.textAnchorOffsetStartIndex, pr = be.textAnchorOffsetEndIndex;
                if (pr === Yi) {
                  const gt = (ft, Ut) => {
                    const Gt = this.collisionIndex.placeCollisionBox(ft, N, T, _e, y, Q, K, f, R.predicate, pe, void 0, Ie);
                    return Gt && Gt.placeable && (this.markUsedOrientation(o, Ut, be), this.placedOrientations[be.crossTileID] = Ut), Gt;
                  };
                  dr(() => gt(Ui, c.ag.horizontal), () => {
                    const ft = Re.verticalTextBox;
                    return o.allowVerticalPlacement && be.numVerticalGlyphVertices > 0 && ft ? gt(ft, c.ag.vertical) : { box: null, offscreen: null };
                  }), Gi(dt && dt.placeable);
                } else {
                  let gt = c.ax[(_t = (lt = this.prevPlacement) === null || lt === void 0 ? void 0 : lt.variableOffsets[be.crossTileID]) === null || _t === void 0 ? void 0 : _t.anchor];
                  const ft = (Gt, Sn, Kc) => {
                    const ic = Gt.x2 - Gt.x1, $o = Gt.y2 - Gt.y1, rc = be.textBoxScale, Mn = J && W === "never" ? Sn : null;
                    let Ci = null, qo = N === "never" ? 1 : 2, nc = "never";
                    gt && qo++;
                    for (let Ia = 0; Ia < qo; Ia++) {
                      for (let Ca = Yi; Ca < pr; Ca++) {
                        const sc = o.textAnchorOffsets.get(Ca);
                        if (gt && sc.textAnchor !== gt) continue;
                        const Ea = this.attemptAnchorPlacement(sc, Gt, ic, $o, rc, K, Q, T, _e, y, R, nc, be, o, Kc, f, _, Mn, pe);
                        if (Ea && (Ci = Ea.placedGlyphBoxes, Ci && Ci.placeable)) return ut = !0, ct = Ea.shift, Ci;
                      }
                      gt ? gt = null : nc = N;
                    }
                    return a && !Ci && (Ci = { box: this.collisionIndex.placeCollisionBox(Ui, "always", T, _e, y, Q, K, f, R.predicate, pe, void 0, Ie).box, offscreen: !1, placeable: !1, occluded: !1 }), Ci;
                  };
                  dr(() => ft(Ui, Re.iconBox, c.ag.horizontal), () => {
                    const Gt = Re.verticalTextBox;
                    return o.allowVerticalPlacement && (!dt || !dt.placeable) && be.numVerticalGlyphVertices > 0 && Gt ? ft(Gt, Re.verticalIconBox, c.ag.vertical) : { box: null, occluded: !0, offscreen: null };
                  }), dt && (ut = dt.placeable, xt = dt.offscreen);
                  const Ut = Gi(dt && dt.placeable);
                  if (!ut && this.prevPlacement) {
                    const Gt = this.prevPlacement.variableOffsets[be.crossTileID];
                    Gt && (this.variableOffsets[be.crossTileID] = Gt, this.markUsedJustification(o, Gt.anchor, be, Ut));
                  }
                }
              }
              if (Jt = dt, ut = Jt && Jt.placeable, xt = Jt && Jt.offscreen, be.useRuntimeCollisionCircles) {
                const Gi = o.text.placedSymbolArray.get(be.centerJustifiedTextSymbolIndex), dr = c.ah(o.textSizeData, k, Gi), Yi = u.get("text-padding");
                Zt = this.collisionIndex.placeCollisionCircles(N, Gi, o.lineVertexArray, o.glyphOffsetArray, dr, y, v, a, Q, R.predicate, be.collisionCircleDiameter, Yi, f, pe), Zt.circles.length && Zt.collisionDetected && !a && c.w("Collisions detected, but collision boxes are not shown"), ut = G || Zt.circles.length > 0 && !Zt.collisionDetected, xt = xt && Zt.offscreen;
              }
              if (Re.iconFeatureIndex && (ur = Re.iconFeatureIndex), Re.iconBox) {
                const Gi = (dr) => this.collisionIndex.placeCollisionBox(dr, W, T, _e, y, Q, K, _, R.predicate, pe, J && ct ? ct : void 0, Ie);
                Kt && Kt.placeable && Re.verticalIconBox ? (ni = Gi(Re.verticalIconBox), Pt = ni.placeable) : (ni = Gi(Re.iconBox), Pt = ni.placeable), xt = xt && ni.offscreen;
              }
              const Tn = V || be.numHorizontalGlyphVertices === 0 && be.numVerticalGlyphVertices === 0, As = j || be.numIconVertices === 0;
              Tn || As ? As ? Tn || (Pt = Pt && ut) : ut = Pt && ut : Pt = ut = Pt && ut;
              const Pn = Pt && ni.placeable;
              if (ut && Jt.placeable && this.collisionIndex.insertCollisionBox(Jt.box, N, u.get("text-ignore-placement"), o.bucketInstanceId, Kt && Kt.placeable && br ? br : Ur, R.ID), Pn && this.collisionIndex.insertCollisionBox(ni.box, W, u.get("icon-ignore-placement"), o.bucketInstanceId, ur, R.ID), Zt && ut && this.collisionIndex.insertCollisionCircles(Zt.circles, N, u.get("text-ignore-placement"), o.bucketInstanceId, Ur, R.ID), a && this.storeCollisionData(o.bucketInstanceId, Oe, Re, Jt, ni, Zt), be.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (o.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[be.crossTileID] = new dl((ut || oe) && !(Jt != null && Jt.occluded), (Pt || fe) && !(ni != null && ni.occluded), xt || o.justReloaded), i[be.crossTileID] = !0;
            };
            if (se) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const be = o.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Re = be.length - 1; Re >= 0; --Re) {
                const Oe = be[Re];
                Se(o.symbolInstances.get(Oe), o.collisionArrays[Oe], Oe);
              }
            } else for (let be = e.symbolInstanceStart; be < e.symbolInstanceEnd; be++) Se(o.symbolInstances.get(be), o.collisionArrays[be], be);
            o.justReloaded = !1;
          }
          storeCollisionData(e, i, a, o, u, f) {
            if (a.textBox || a.iconBox) {
              let _, y;
              this.collisionBoxArrays.has(e) ? _ = this.collisionBoxArrays.get(e) : (_ = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, _)), _.has(i) ? y = _.get(i) : (y = { text: null, icon: null }, _.set(i, y)), a.textBox && (y.text = o.box), a.iconBox && (y.icon = u.box);
            }
            if (f) {
              let _ = this.collisionCircleArrays[e];
              _ === void 0 && (_ = this.collisionCircleArrays[e] = []);
              for (let y = 0; y < f.circles.length; y += 4) _.push(f.circles[y + 0] - yt), _.push(f.circles[y + 1] - yt), _.push(f.circles[y + 2]), _.push(f.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, i, a, o) {
            let u;
            u = o === c.ag.vertical ? a.verticalPlacedTextSymbolIndex : { left: a.leftJustifiedTextSymbolIndex, center: a.centerJustifiedTextSymbolIndex, right: a.rightJustifiedTextSymbolIndex }[c.az(i)];
            const f = [a.leftJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.rightJustifiedTextSymbolIndex, a.verticalPlacedTextSymbolIndex];
            for (const _ of f) _ >= 0 && (e.text.placedSymbolArray.get(_).crossTileID = u >= 0 && _ !== u ? 0 : a.crossTileID);
          }
          markUsedOrientation(e, i, a) {
            const o = i === c.ag.horizontal || i === c.ag.horizontalOnly ? i : 0, u = i === c.ag.vertical ? i : 0, f = [a.leftJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.rightJustifiedTextSymbolIndex];
            for (const _ of f) e.text.placedSymbolArray.get(_).placedOrientation = o;
            a.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).placedOrientation = u);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const i = this.prevPlacement;
            let a = !1;
            this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
            const o = i ? i.symbolFadeChange(e) : 1, u = i ? i.opacities : {}, f = i ? i.variableOffsets : {}, _ = i ? i.placedOrientations : {};
            for (const y in this.placements) {
              const v = this.placements[y], T = u[y];
              T ? (this.opacities[y] = new pt(T, o, v.text, v.icon), a = a || v.text !== T.text.placed || v.icon !== T.icon.placed) : (this.opacities[y] = new pt(null, o, v.text, v.icon, v.skipFade), a = a || v.text || v.icon);
            }
            for (const y in u) {
              const v = u[y];
              if (!this.opacities[y]) {
                const T = new pt(v, o, !1, !1);
                T.isHidden() || (this.opacities[y] = T, a = a || v.text.placed || v.icon.placed);
              }
            }
            for (const y in f) this.variableOffsets[y] || !this.opacities[y] || this.opacities[y].isHidden() || (this.variableOffsets[y] = f[y]);
            for (const y in _) this.placedOrientations[y] || !this.opacities[y] || this.opacities[y].isHidden() || (this.placedOrientations[y] = _[y]);
            if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            a ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, i) {
            const a = {};
            for (const o of i) {
              const u = o.getBucket(e);
              u && o.latestFeatureIndex && e.id === u.layerIds[0] && this.updateBucketOpacities(u, o.tileID, a, o.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, i, a, o) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const u = e.layers[0], f = u.layout, _ = new pt(null, 0, !1, !1, !0), y = f.get("text-allow-overlap"), v = f.get("icon-allow-overlap"), T = u._unevaluatedLayout.hasValue("text-variable-anchor") || u._unevaluatedLayout.hasValue("text-variable-anchor-offset"), S = f.get("text-rotation-alignment") === "map", M = f.get("text-pitch-alignment") === "map", k = f.get("icon-text-fit") !== "none", R = new pt(null, 0, y && (v || !e.hasIconData() || f.get("icon-optional")), v && (y || !e.hasTextData() || f.get("text-optional")), !0);
            !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);
            const V = (N, G, W) => {
              for (let H = 0; H < G / 4; H++) N.opacityVertexArray.emplaceBack(W);
              N.hasVisibleVertices = N.hasVisibleVertices || W !== Ln;
            }, j = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let N = 0; N < e.symbolInstances.length; N++) {
              const G = e.symbolInstances.get(N), { numHorizontalGlyphVertices: W, numVerticalGlyphVertices: H, crossTileID: K } = G;
              let Q = this.opacities[K];
              a[K] ? Q = _ : Q || (Q = R, this.opacities[K] = Q), a[K] = !0;
              const J = G.numIconVertices > 0, se = this.placedOrientations[G.crossTileID], oe = se === c.ag.vertical, fe = se === c.ag.horizontal || se === c.ag.horizontalOnly;
              if (W > 0 || H > 0) {
                const pe = qa(Q.text);
                V(e.text, W, oe ? Ln : pe), V(e.text, H, fe ? Ln : pe);
                const Ie = Q.text.isHidden();
                [G.rightJustifiedTextSymbolIndex, G.centerJustifiedTextSymbolIndex, G.leftJustifiedTextSymbolIndex].forEach((Re) => {
                  Re >= 0 && (e.text.placedSymbolArray.get(Re).hidden = Ie || oe ? 1 : 0);
                }), G.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(G.verticalPlacedTextSymbolIndex).hidden = Ie || fe ? 1 : 0);
                const Se = this.variableOffsets[G.crossTileID];
                Se && this.markUsedJustification(e, Se.anchor, G, se);
                const be = this.placedOrientations[G.crossTileID];
                be && (this.markUsedJustification(e, "left", G, be), this.markUsedOrientation(e, be, G));
              }
              if (J) {
                const pe = qa(Q.icon), Ie = !(k && G.verticalPlacedIconSymbolIndex && oe);
                G.placedIconSymbolIndex >= 0 && (V(e.icon, G.numIconVertices, Ie ? pe : Ln), e.icon.placedSymbolArray.get(G.placedIconSymbolIndex).hidden = Q.icon.isHidden()), G.verticalPlacedIconSymbolIndex >= 0 && (V(e.icon, G.numVerticalIconVertices, Ie ? Ln : pe), e.icon.placedSymbolArray.get(G.verticalPlacedIconSymbolIndex).hidden = Q.icon.isHidden());
              }
              const _e = j && j.has(N) ? j.get(N) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const pe = e.collisionArrays[N];
                if (pe) {
                  let Ie = new c.P(0, 0);
                  if (pe.textBox || pe.verticalTextBox) {
                    let Se = !0;
                    if (T) {
                      const be = this.variableOffsets[K];
                      be ? (Ie = Br(be.anchor, be.width, be.height, be.textOffset, be.textBoxScale), S && Ie._rotate(M ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Se = !1;
                    }
                    if (pe.textBox || pe.verticalTextBox) {
                      let be;
                      pe.textBox && (be = oe), pe.verticalTextBox && (be = fe), $a(e.textCollisionBox.collisionVertexArray, Q.text.placed, !Se || be, _e.text, Ie.x, Ie.y);
                    }
                  }
                  if (pe.iconBox || pe.verticalIconBox) {
                    const Se = !!(!fe && pe.verticalIconBox);
                    let be;
                    pe.iconBox && (be = Se), pe.verticalIconBox && (be = !Se), $a(e.iconCollisionBox.collisionVertexArray, Q.icon.placed, be, _e.icon, k ? Ie.x : 0, k ? Ie.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, i) {
            const a = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
            return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * a > e;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function $a(h, e, i, a, o, u) {
          a && a.length !== 0 || (a = [0, 0, 0, 0]);
          const f = a[0] - yt, _ = a[1] - yt, y = a[2] - yt, v = a[3] - yt;
          h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, f, _), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, y, _), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, y, v), h.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, u || 0, f, v);
        }
        const pl = Math.pow(2, 25), fl = Math.pow(2, 24), Rn = Math.pow(2, 17), ml = Math.pow(2, 16), Mc = Math.pow(2, 9), Ic = Math.pow(2, 8), Cc = Math.pow(2, 1);
        function qa(h) {
          if (h.opacity === 0 && !h.placed) return 0;
          if (h.opacity === 1 && h.placed) return 4294967295;
          const e = h.placed ? 1 : 0, i = Math.floor(127 * h.opacity);
          return i * pl + e * fl + i * Rn + e * ml + i * Mc + e * Ic + i * Cc + e;
        }
        const Ln = 0;
        class Wa {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, i, a, o, u) {
            const f = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (i.getBucketParts(f, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, u()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, f.sort((_, y) => _.sortKey - y.sortKey)); this._currentPartIndex < f.length; ) if (i.placeLayerBucketPart(f[this._currentPartIndex], this._seenCrossTileIDs, a), this._currentPartIndex++, u()) return !0;
            return !1;
          }
        }
        class Ha {
          constructor(e, i, a, o, u, f, _, y) {
            this.placement = new Dn(e, i, f, _, y), this._currentPlacementIndex = a.length - 1, this._forceFullPlacement = o, this._showCollisionBoxes = u, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, i, a) {
            const o = He.now(), u = () => !this._forceFullPlacement && He.now() - o > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const f = i[e[this._currentPlacementIndex]], _ = this.placement.collisionIndex.transform.zoom;
              if (f.type === "symbol" && (!f.minzoom || f.minzoom <= _) && (!f.maxzoom || f.maxzoom > _)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Wa(f)), this._inProgressLayer.continuePlacement(a[f.source], this.placement, this._showCollisionBoxes, f, u)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const Bn = 512 / c.Z / 2;
        class Xa {
          constructor(e, i, a) {
            this.tileID = e, this.bucketInstanceId = a, this._symbolsByKey = {};
            const o = /* @__PURE__ */ new Map();
            for (let u = 0; u < i.length; u++) {
              const f = i.get(u), _ = f.key, y = o.get(_);
              y ? y.push(f) : o.set(_, [f]);
            }
            for (const [u, f] of o) {
              const _ = { positions: f.map((y) => ({ x: Math.floor(y.anchorX * Bn), y: Math.floor(y.anchorY * Bn) })), crossTileIDs: f.map((y) => y.crossTileID) };
              if (_.positions.length > 128) {
                const y = new c.aB(_.positions.length, 16, Uint16Array);
                for (const { x: v, y: T } of _.positions) y.add(v, T);
                y.finish(), delete _.positions, _.index = y;
              }
              this._symbolsByKey[u] = _;
            }
          }
          getScaledCoordinates(e, i) {
            const { x: a, y: o, z: u } = this.tileID.canonical, { x: f, y: _, z: y } = i.canonical, v = Bn / Math.pow(2, y - u), T = (_ * c.Z + e.anchorY) * v, S = o * c.Z * Bn;
            return { x: Math.floor((f * c.Z + e.anchorX) * v - a * c.Z * Bn), y: Math.floor(T - S) };
          }
          findMatches(e, i, a) {
            const o = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
            for (let u = 0; u < e.length; u++) {
              const f = e.get(u);
              if (f.crossTileID) continue;
              const _ = this._symbolsByKey[f.key];
              if (!_) continue;
              const y = this.getScaledCoordinates(f, i);
              if (_.index) {
                const v = _.index.range(y.x - o, y.y - o, y.x + o, y.y + o).sort();
                for (const T of v) {
                  const S = _.crossTileIDs[T];
                  if (!a[S]) {
                    a[S] = !0, f.crossTileID = S;
                    break;
                  }
                }
              } else if (_.positions) for (let v = 0; v < _.positions.length; v++) {
                const T = _.positions[v], S = _.crossTileIDs[v];
                if (Math.abs(T.x - y.x) <= o && Math.abs(T.y - y.y) <= o && !a[S]) {
                  a[S] = !0, f.crossTileID = S;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
          }
        }
        class Ka {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Os {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const i = Math.round((e - this.lng) / 360);
            if (i !== 0) for (const a in this.indexes) {
              const o = this.indexes[a], u = {};
              for (const f in o) {
                const _ = o[f];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + i), u[_.tileID.key] = _;
              }
              this.indexes[a] = u;
            }
            this.lng = e;
          }
          addBucket(e, i, a) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let u = 0; u < i.symbolInstances.length; u++) i.symbolInstances.get(u).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const o = this.usedCrossTileIDs[e.overscaledZ];
            for (const u in this.indexes) {
              const f = this.indexes[u];
              if (Number(u) > e.overscaledZ) for (const _ in f) {
                const y = f[_];
                y.tileID.isChildOf(e) && y.findMatches(i.symbolInstances, e, o);
              }
              else {
                const _ = f[e.scaledTo(Number(u)).key];
                _ && _.findMatches(i.symbolInstances, e, o);
              }
            }
            for (let u = 0; u < i.symbolInstances.length; u++) {
              const f = i.symbolInstances.get(u);
              f.crossTileID || (f.crossTileID = a.generate(), o[f.crossTileID] = !0);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Xa(e, i.symbolInstances, i.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(e, i) {
            for (const a of i.getCrossTileIDsLists()) for (const o of a) delete this.usedCrossTileIDs[e][o];
          }
          removeStaleBuckets(e) {
            let i = !1;
            for (const a in this.indexes) {
              const o = this.indexes[a];
              for (const u in o) e[o[u].bucketInstanceId] || (this.removeBucketCrossTileIDs(a, o[u]), delete o[u], i = !0);
            }
            return i;
          }
        }
        class Ja {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Ka(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, i, a) {
            let o = this.layerIndexes[e.id];
            o === void 0 && (o = this.layerIndexes[e.id] = new Os());
            let u = !1;
            const f = {};
            o.handleWrapJump(a);
            for (const _ of i) {
              const y = _.getBucket(e);
              y && e.id === y.layerIds[0] && (y.bucketInstanceId || (y.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(_.tileID, y, this.crossTileIDs) && (u = !0), f[y.bucketInstanceId] = !0);
            }
            return o.removeStaleBuckets(f) && (u = !0), u;
          }
          pruneUnusedLayers(e) {
            const i = {};
            e.forEach((a) => {
              i[a] = !0;
            });
            for (const a in this.layerIndexes) i[a] || delete this.layerIndexes[a];
          }
        }
        var ln = "void main() {fragColor=vec4(1.0);}";
        const Xi = { prelude: nt(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: nt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: nt("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: nt(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: nt(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: nt(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: nt(ln, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: nt(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: nt(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: nt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: nt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: nt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: nt(ln, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: nt(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: nt(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: nt(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: nt(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: nt(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: nt(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: nt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: nt(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: nt(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: nt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: nt(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: nt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: nt(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: nt(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: nt(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: nt(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: nt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: nt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: nt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: nt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: nt(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: nt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function nt(h, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a = e.match(/in ([\w]+) ([\w]+)/g), o = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), u = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), f = u ? u.concat(o) : o, _ = {};
          return { fragmentSource: h = h.replace(i, (y, v, T, S, M) => (_[M] = !0, v === "define" ? `
#ifndef HAS_UNIFORM_u_${M}
in ${T} ${S} ${M};
#else
uniform ${T} ${S} u_${M};
#endif
` : `
#ifdef HAS_UNIFORM_u_${M}
    ${T} ${S} ${M} = u_${M};
#endif
`)), vertexSource: e = e.replace(i, (y, v, T, S, M) => {
            const k = S === "float" ? "vec2" : "vec4", R = M.match(/color/) ? "color" : k;
            return _[M] ? v === "define" ? `
#ifndef HAS_UNIFORM_u_${M}
uniform lowp float u_${M}_t;
in ${T} ${k} a_${M};
out ${T} ${S} ${M};
#else
uniform ${T} ${S} u_${M};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${M}
    ${M} = a_${M};
#else
    ${T} ${S} ${M} = u_${M};
#endif
` : `
#ifndef HAS_UNIFORM_u_${M}
    ${M} = unpack_mix_${R}(a_${M}, u_${M}_t);
#else
    ${T} ${S} ${M} = u_${M};
#endif
` : v === "define" ? `
#ifndef HAS_UNIFORM_u_${M}
uniform lowp float u_${M}_t;
in ${T} ${k} a_${M};
#else
uniform ${T} ${S} u_${M};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${M}
    ${T} ${S} ${M} = a_${M};
#else
    ${T} ${S} ${M} = u_${M};
#endif
` : `
#ifndef HAS_UNIFORM_u_${M}
    ${T} ${S} ${M} = unpack_mix_${R}(a_${M}, u_${M}_t);
#else
    ${T} ${S} ${M} = u_${M};
#endif
`;
          }), staticAttributes: a, staticUniforms: f };
        }
        class Si {
          constructor(e, i, a) {
            this.vertexBuffer = e, this.indexBuffer = i, this.segments = a;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Li = c.aC([{ name: "a_pos", type: "Int16", components: 2 }]);
        const st = "#define PROJECTION_MERCATOR", js = "mercator";
        class Ya {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return js;
          }
          get shaderDefine() {
            return st;
          }
          get shaderPreludeCode() {
            return Xi.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Xi.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return c.aD.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, i, a, o, u) {
            if (this._cachedMesh) return this._cachedMesh;
            const f = new c.aE();
            f.emplaceBack(0, 0), f.emplaceBack(c.Z, 0), f.emplaceBack(0, c.Z), f.emplaceBack(c.Z, c.Z);
            const _ = e.createVertexBuffer(f, Li.members), y = c.aF.simpleSegment(0, 0, 4, 2), v = new c.aG();
            v.emplaceBack(1, 0, 2), v.emplaceBack(1, 2, 3);
            const T = e.createIndexBuffer(v);
            return this._cachedMesh = new Si(_, T, y), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        function Bi(h, e) {
          const i = c.ad(e.lat, -85.051129, c.aI);
          return new c.P(c.U(e.lng) * h, c.S(i) * h);
        }
        function ri(h, e) {
          return new c.$(e.x / h, e.y / h).toLngLat();
        }
        function Ht(h) {
          return h.cameraToCenterDistance * Math.min(0.85 * Math.tan(c.ac(90 - h.pitch)), Math.tan(c.ac(89.25 - h.pitch)));
        }
        function It(h, e) {
          const i = h.canonical, a = e / c.aH(i.z), o = i.x + Math.pow(2, i.z) * h.wrap, u = c.as(new Float64Array(16));
          return c.L(u, u, [o * a, i.y * a, 0]), c.M(u, u, [a / c.Z, a / c.Z, 1]), u;
        }
        function Qa(h, e, i, a, o) {
          const u = c.$.fromLngLat(h, e), f = o * c.aJ(1, h.lat), _ = f * Math.cos(c.ac(i)), y = Math.sqrt(f * f - _ * _), v = y * Math.sin(c.ac(-a)), T = y * Math.cos(c.ac(-a));
          return new c.$(u.x + v, u.y + T, u.z + _);
        }
        class Xt {
          constructor(e = 0, i = 0, a = 0, o = 0) {
            if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(a) || a < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = i, this.left = a, this.right = o;
          }
          interpolate(e, i, a) {
            return i.top != null && e.top != null && (this.top = c.B.number(e.top, i.top, a)), i.bottom != null && e.bottom != null && (this.bottom = c.B.number(e.bottom, i.bottom, a)), i.left != null && e.left != null && (this.left = c.B.number(e.left, i.left, a)), i.right != null && e.right != null && (this.right = c.B.number(e.right, i.right, a)), this;
          }
          getCenter(e, i) {
            const a = c.ad((this.left + e - this.right) / 2, 0, e), o = c.ad((this.top + i - this.bottom) / 2, 0, i);
            return new c.P(a, o);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new Xt(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function _i(h, e) {
          if (!h.renderWorldCopies || h.lngRange) return;
          const i = e.lng - h.center.lng;
          e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
        }
        function xi(h) {
          return Math.max(0, Math.floor(h));
        }
        class Vs {
          constructor(e, i, a, o, u, f) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = f === void 0 || !!f, this._minZoom = i || 0, this._maxZoom = a || 22, this._minPitch = o ?? 0, this._maxPitch = u ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new c.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = xi(this._zoom), this._scale = c.aH(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Xt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(e, i, a) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = xi(this._zoom), this._scale = c.aH(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Xt(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !a && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new c.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const i = c.aK(e, -180, 180) * Math.PI / 180;
            var a, o, u, f, _, y, v, T, S;
            this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = Mr(), a = this._rotationMatrix, u = -this._bearingInRadians, f = (o = this._rotationMatrix)[0], _ = o[1], y = o[2], v = o[3], T = Math.sin(u), S = Math.cos(u), a[0] = f * S + y * T, a[1] = _ * S + v * T, a[2] = f * -T + y * S, a[3] = _ * -T + v * S);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const i = c.ad(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const i = e / 180 * Math.PI;
            this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return c.aL(this._fovInRadians);
          }
          setFov(e) {
            e = c.ad(e, 0.1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = c.ac(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const i = this.getConstrained(this._center, e).zoom;
            this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = c.aH(i), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, i) {
            this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, i, a) {
            this._unmodified = !1, this._edgeInsets.interpolate(e, i, a), this._constrain(), this._calcMatrices();
          }
          resize(e, i, a = !0) {
            this._width = e, this._height = i, a && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Dt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, c.aI]);
          }
          getConstrained(e, i) {
            return this._callbacks.getConstrained(e, i);
          }
          getCameraQueryGeometry(e, i) {
            if (i.length === 1) return [i[0], e];
            {
              let a = e.x, o = e.y, u = e.x, f = e.y;
              for (const _ of i) a = Math.min(a, _.x), o = Math.min(o, _.y), u = Math.max(u, _.x), f = Math.max(f, _.y);
              return [new c.P(a, o), new c.P(u, o), new c.P(u, f), new c.P(a, f), new c.P(a, o)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const e = this._unmodified, { center: i, zoom: a } = this.getConstrained(this.center, this.zoom);
            this.setCenter(i), this.setZoom(a), this._unmodified = e, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = c.as(new Float64Array(16));
              c.M(e, e, [this._width / 2, -this._height / 2, 1]), c.L(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = c.as(new Float64Array(16)), c.M(e, e, [1, -1, 1]), c.L(e, e, [-1, -1, 0]), c.M(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, i, a, o) {
            const u = a !== void 0 ? a : this.bearing, f = o = o !== void 0 ? o : this.pitch, _ = c.$.fromLngLat(e, i), y = -Math.cos(c.ac(f)), v = Math.sin(c.ac(f)), T = v * Math.sin(c.ac(u)), S = -v * Math.cos(c.ac(u));
            let M = this.elevation;
            const k = i - M;
            let R;
            y * k >= 0 || Math.abs(y) < 0.1 ? (R = 1e4, M = i + R * y) : R = -k / y;
            let V, j, N = c.aM(1, _.y), G = 0;
            do {
              if (G += 1, G > 10) break;
              j = R / N, V = new c.$(_.x + T * j, _.y + S * j), N = 1 / V.meterInMercatorCoordinateUnits();
            } while (Math.abs(R - j * N) > 1e-12);
            return { center: V.toLngLat(), elevation: M, zoom: c.aa(this.height / 2 / Math.tan(this.fovInRadians / 2) / j / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const i = c.aJ(1, this.center.lat) * this.worldSize, a = this.cameraToCenterDistance / i, o = c.$.fromLngLat(this.center, this.elevation), u = Qa(this.center, this.elevation, this.pitch, this.bearing, a);
            this._elevation = e;
            const f = this.calculateCenterFromCameraLngLatAlt(u.toLngLat(), c.aM(u.z, o.y), this.bearing, this.pitch);
            this._elevation = f.elevation, this._center = f.center, this.setZoom(f.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new c.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = c.aJ(1, this.center.lat) * this.worldSize;
            return Qa(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / i, e.canonical.y / i, 1 / i / c.Z, 1 / i / c.Z];
          }
        }
        class Ki {
          constructor(e, i) {
            this.min = e, this.max = i, this.center = c.aN([], c.aO([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2], a = c.aP(this.min), o = c.aP(this.max);
            for (let u = 0; u < i.length; u++) a[u] = i[u] ? this.min[u] : this.center[u], o[u] = i[u] ? this.center[u] : this.max[u];
            return o[2] = this.max[2], new Ki(a, o);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let i = !0;
            for (let a = 0; a < e.planes.length; a++) {
              const o = this.intersectsPlane(e.planes[a]);
              if (o === 0) return 0;
              o === 1 && (i = !1);
            }
            return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let i = e[3], a = e[3];
            for (let o = 0; o < 3; o++) e[o] > 0 ? (i += e[o] * this.min[o], a += e[o] * this.max[o]) : (a += e[o] * this.min[o], i += e[o] * this.max[o]);
            return i >= 0 ? 2 : a < 0 ? 0 : 1;
          }
        }
        class Ot {
          distanceToTile2d(e, i, a, o) {
            const u = o.distanceX([e, i]), f = o.distanceY([e, i]);
            return Math.hypot(u, f);
          }
          getWrap(e, i, a) {
            return a;
          }
          getTileAABB(e, i, a, o) {
            var u, f;
            let _ = a, y = a;
            if (o.terrain) {
              const T = new c.Y(e.z, i, e.z, e.x, e.y), S = o.terrain.getMinMaxElevation(T);
              _ = (u = S.minElevation) !== null && u !== void 0 ? u : a, y = (f = S.maxElevation) !== null && f !== void 0 ? f : a;
            }
            const v = 1 << e.z;
            return new Ki([i + e.x / v, e.y / v, _], [i + (e.x + 1) / v, (e.y + 1) / v, y]);
          }
          allowVariableZoom(e, i) {
            const a = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, o = c.ad(78.5 - a / 2, 0, 60);
            return !!i.terrain || e.pitch > o;
          }
          allowWorldCopies() {
            return !0;
          }
          recalculateCache() {
          }
        }
        class Fr {
          constructor(e, i, a) {
            this.points = e, this.planes = i, this.aabb = a;
          }
          static fromInvProjectionMatrix(e, i = 1, a = 0) {
            const o = Math.pow(2, a), u = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((v) => {
              const T = 1 / (v = c.ao([], v, e))[3] / i * o;
              return c.aQ(v, v, [T, T, 1 / v[3], T]);
            }), f = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((v) => {
              const T = c.aR([], u[v[0]], u[v[1]]), S = c.aR([], u[v[2]], u[v[1]]), M = c.aS([], c.aT([], T, S)), k = -c.aU(M, u[v[1]]);
              return M.concat(k);
            }), _ = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], y = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const v of u) for (let T = 0; T < 3; T++) _[T] = Math.min(_[T], v[T]), y[T] = Math.max(y[T], v[T]);
            return new Fr(u, f, new Ki(_, y));
          }
        }
        class Fi {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, a) {
            return this._helper.interpolatePadding(e, i, a);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i, a = !0) {
            this._helper.resize(e, i, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, i) {
          }
          constructor(e, i, a, o, u) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Vs({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (f, _) => this.getConstrained(f, _) }, e, i, a, o, u), this._coveringTilesDetailsProvider = new Ot();
          }
          clone() {
            const e = new Fi();
            return e.apply(this), e;
          }
          apply(e, i, a) {
            this._helper.apply(e, i, a);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const i = [new c.aV(0, e)];
            if (this._helper._renderWorldCopies) {
              const a = this.screenPointToMercatorCoordinate(new c.P(0, 0)), o = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, 0)), u = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, this._helper._height)), f = this.screenPointToMercatorCoordinate(new c.P(0, this._helper._height)), _ = Math.floor(Math.min(a.x, o.x, u.x, f.x)), y = Math.floor(Math.max(a.x, o.x, u.x, f.x)), v = 1;
              for (let T = _ - v; T <= y + v; T++) T !== 0 && i.push(new c.aV(T, e));
            }
            return i;
          }
          getCameraFrustum() {
            return Fr.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const i = this.screenPointToLocation(this.centerPoint, e), a = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(a);
          }
          setLocationAtPoint(e, i) {
            const a = c.aJ(this.elevation, this.center.lat), o = this.screenPointToMercatorCoordinateAtZ(i, a), u = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, a), f = c.$.fromLngLat(e), _ = new c.$(f.x - (o.x - u.x), f.y - (o.y - u.y));
            this.setCenter(_ == null ? void 0 : _.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, i) {
            return i ? this.coordinatePoint(c.$.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(c.$.fromLngLat(e));
          }
          screenPointToLocation(e, i) {
            var a;
            return (a = this.screenPointToMercatorCoordinate(e, i)) === null || a === void 0 ? void 0 : a.toLngLat();
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const a = i.pointCoordinate(e);
              if (a != null) return a;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, i) {
            const a = i || 0, o = [e.x, e.y, 0, 1], u = [e.x, e.y, 1, 1];
            c.ao(o, o, this._pixelMatrixInverse), c.ao(u, u, this._pixelMatrixInverse);
            const f = o[3], _ = u[3], y = o[1] / f, v = u[1] / _, T = o[2] / f, S = u[2] / _, M = T === S ? 0 : (a - T) / (S - T);
            return new c.$(c.B.number(o[0] / f, u[0] / _, M) / this.worldSize, c.B.number(y, v, M) / this.worldSize, a);
          }
          coordinatePoint(e, i = 0, a = this._pixelMatrix) {
            const o = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
            return c.ao(o, o, a), new c.P(o[0] / o[3], o[1] / o[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - Ht(this));
            return new Dt().extend(this.screenPointToLocation(new c.P(0, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new c.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, i) {
            return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - Ht(this);
          }
          calculatePosMatrix(e, i = !1, a) {
            var o;
            const u = (o = e.key) !== null && o !== void 0 ? o : c.aW(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), f = i ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (f.has(u)) {
              const v = f.get(u);
              return a ? v.f32 : v.f64;
            }
            const _ = It(e, this.worldSize);
            c.N(_, i ? this._alignedProjMatrix : this._viewProjMatrix, _);
            const y = { f64: _, f32: new Float32Array(_) };
            return f.set(u, y), a ? y.f32 : y.f64;
          }
          calculateFogMatrix(e) {
            const i = e.key, a = this._fogMatrixCacheF32;
            if (a.has(i)) return a.get(i);
            const o = It(e, this.worldSize);
            return c.N(o, this._fogMatrix, o), a.set(i, new Float32Array(o)), a.get(i);
          }
          getConstrained(e, i) {
            i = c.ad(+i, this.minZoom, this.maxZoom);
            const a = { center: new c.Q(e.lng, e.lat), zoom: i };
            let o = this._helper._lngRange;
            this._helper._renderWorldCopies || o !== null || (o = [-179.9999999999, 180 - 1e-10]);
            const u = this.tileSize * c.aH(a.zoom);
            let f = 0, _ = u, y = 0, v = u, T = 0, S = 0;
            const { x: M, y: k } = this.size;
            if (this._helper._latRange) {
              const W = this._helper._latRange;
              f = c.S(W[1]) * u, _ = c.S(W[0]) * u, _ - f < k && (T = k / (_ - f));
            }
            o && (y = c.aK(c.U(o[0]) * u, 0, u), v = c.aK(c.U(o[1]) * u, 0, u), v < y && (v += u), v - y < M && (S = M / (v - y)));
            const { x: R, y: V } = Bi(u, e);
            let j, N;
            const G = Math.max(S || 0, T || 0);
            if (G) {
              const W = new c.P(S ? (v + y) / 2 : R, T ? (_ + f) / 2 : V);
              return a.center = ri(u, W).wrap(), a.zoom += c.aa(G), a;
            }
            if (this._helper._latRange) {
              const W = k / 2;
              V - W < f && (N = f + W), V + W > _ && (N = _ - W);
            }
            if (o) {
              const W = (y + v) / 2;
              let H = R;
              this._helper._renderWorldCopies && (H = c.aK(R, W - u / 2, W + u / 2));
              const K = M / 2;
              H - K < y && (j = y + K), H + K > v && (j = v - K);
            }
            if (j !== void 0 || N !== void 0) {
              const W = new c.P(j ?? R, N ?? V);
              a.center = ri(u, W).wrap();
            }
            return a;
          }
          calculateCenterFromCameraLngLatAlt(e, i, a, o) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, a, o);
          }
          _calculateNearFarZIfNeeded(e, i, a) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const o = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), u = e - o * this._helper._pixelPerMeter / Math.cos(i), f = o < 0 ? u : e, _ = Math.PI / 2 + this.pitchInRadians, y = c.ac(this.fov) * (Math.abs(Math.cos(c.ac(this.roll))) * this.height + Math.abs(Math.sin(c.ac(this.roll))) * this.width) / this.height * (0.5 + a.y / this.height), v = Math.sin(y) * f / Math.sin(c.ad(Math.PI - _ - y, 0.01, Math.PI - 0.01)), T = Ht(this), S = Math.atan(T / this._helper.cameraToCenterDistance), M = c.ac(0.75), k = S > M ? 2 * S * (0.5 + a.y / (2 * T)) : M, R = Math.sin(k) * f / Math.sin(c.ad(Math.PI - _ - k, 0.01, Math.PI - 0.01)), V = Math.min(v, R);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * V + f), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, i = Bi(this.worldSize, this.center), a = i.x, o = i.y;
            this._helper._pixelPerMeter = c.aJ(1, this.center.lat) * this.worldSize;
            const u = c.ac(Math.min(this.pitch, 89.25)), f = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(u));
            let _;
            this._calculateNearFarZIfNeeded(f, u, e), _ = new Float64Array(16), c.aX(_, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), c.ai(this._invProjMatrix, _), _[8] = 2 * -e.x / this._helper._width, _[9] = 2 * e.y / this._helper._height, this._projectionMatrix = c.aY(_), c.M(_, _, [1, -1, 1]), c.L(_, _, [0, 0, -this._helper.cameraToCenterDistance]), c.aZ(_, _, -this.rollInRadians), c.a_(_, _, this.pitchInRadians), c.aZ(_, _, -this.bearingInRadians), c.L(_, _, [-a, -o, 0]), this._mercatorMatrix = c.M([], _, [this.worldSize, this.worldSize, this.worldSize]), c.M(_, _, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, _), c.L(_, _, [0, 0, -this.elevation]), this._viewProjMatrix = _, this._invViewProjMatrix = c.ai([], _);
            const y = [0, 0, -1, 1];
            c.ao(y, y, this._invViewProjMatrix), this._cameraPosition = [y[0] / y[3], y[1] / y[3], y[2] / y[3]], this._fogMatrix = new Float64Array(16), c.aX(this._fogMatrix, this.fovInRadians, this.width / this.height, f, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, c.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.aZ(this._fogMatrix, this._fogMatrix, -this.rollInRadians), c.a_(this._fogMatrix, this._fogMatrix, this.pitchInRadians), c.aZ(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), c.L(this._fogMatrix, this._fogMatrix, [-a, -o, 0]), c.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, _);
            const v = this._helper._width % 2 / 2, T = this._helper._height % 2 / 2, S = Math.cos(this.bearingInRadians), M = Math.sin(-this.bearingInRadians), k = a - Math.round(a) + S * v + M * T, R = o - Math.round(o) + S * T + M * v, V = new Float64Array(_);
            if (c.L(V, V, [k > 0.5 ? k - 1 : k, R > 0.5 ? R - 1 : R, 0]), this._alignedProjMatrix = V, _ = c.ai(new Float64Array(16), this._pixelMatrix), !_) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = _, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new c.P(0, 0)), i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return c.ao(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = c.aJ(1, this.center.lat) * this.worldSize;
            return Qa(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, i) {
            const a = c.$.fromLngLat(e), o = [a.x * this.worldSize, a.y * this.worldSize, i, 1];
            return c.ao(o, o, this._viewProjMatrix), o[2] / o[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: i, aligned: a, applyTerrainMatrix: o } = e, u = this._helper.getMercatorTileCoordinates(i), f = i ? this.calculatePosMatrix(i, a, !0) : null;
            let _;
            return _ = i && i.terrainRttPosMatrix32f && o ? i.terrainRttPosMatrix32f : f || c.a$(), { mainMatrix: _, tileMercatorCoords: u, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: _ };
          }
          isLocationOccluded(e) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, i, a) {
            return 1;
          }
          transformLightDirection(e) {
            return c.aP(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, i, a, o) {
            const u = this.calculatePosMatrix(a);
            let f;
            o ? (f = [e, i, o(e, i), 1], c.ao(f, f, u)) : (f = [e, i, 0, 1], Nt(f, f, u));
            const _ = f[3];
            return { point: new c.P(f[0] / _, f[1] / _), signedDistanceFromCamera: _, isOccluded: !1 };
          }
          populateCache(e) {
            for (const i of e) this.calculatePosMatrix(i);
          }
          getMatrixForModel(e, i) {
            const a = c.$.fromLngLat(e, i), o = a.meterInMercatorCoordinateUnits(), u = c.b0();
            return c.L(u, u, [a.x, a.y, a.z]), c.aZ(u, u, Math.PI), c.a_(u, u, Math.PI / 2), c.M(u, u, [-o, o, o]), u;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = new c.Y(0, 0, 0, 0, 0), a = this.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: e }), o = It(i, this.worldSize);
            c.N(o, this._viewProjMatrix, o), a.tileMercatorCoords = [0, 0, 1, 1];
            const u = [c.Z, c.Z, this.worldSize / this._helper.pixelsPerMeter], f = c.b1();
            return c.M(f, o, u), a.fallbackMatrix = f, a.mainMatrix = f, a;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function us() {
          c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function Oi(h) {
          if (h.useSlerp) if (h.k < 1) {
            const e = c.b2(h.startEulerAngles.roll, h.startEulerAngles.pitch, h.startEulerAngles.bearing), i = c.b2(h.endEulerAngles.roll, h.endEulerAngles.pitch, h.endEulerAngles.bearing), a = new Float64Array(4);
            c.b3(a, e, i, h.k);
            const o = c.b4(a);
            h.tr.setRoll(o.roll), h.tr.setPitch(o.pitch), h.tr.setBearing(o.bearing);
          } else h.tr.setRoll(h.endEulerAngles.roll), h.tr.setPitch(h.endEulerAngles.pitch), h.tr.setBearing(h.endEulerAngles.bearing);
          else h.tr.setRoll(c.B.number(h.startEulerAngles.roll, h.endEulerAngles.roll, h.k)), h.tr.setPitch(c.B.number(h.startEulerAngles.pitch, h.endEulerAngles.pitch, h.k)), h.tr.setBearing(c.B.number(h.startEulerAngles.bearing, h.endEulerAngles.bearing, h.k));
        }
        function eo(h, e, i, a, o) {
          const u = o.padding, f = Bi(o.worldSize, i.getNorthWest()), _ = Bi(o.worldSize, i.getNorthEast()), y = Bi(o.worldSize, i.getSouthEast()), v = Bi(o.worldSize, i.getSouthWest()), T = c.ac(-a), S = f.rotate(T), M = _.rotate(T), k = y.rotate(T), R = v.rotate(T), V = new c.P(Math.max(S.x, M.x, R.x, k.x), Math.max(S.y, M.y, R.y, k.y)), j = new c.P(Math.min(S.x, M.x, R.x, k.x), Math.min(S.y, M.y, R.y, k.y)), N = V.sub(j), G = (o.width - (u.left + u.right + e.left + e.right)) / N.x, W = (o.height - (u.top + u.bottom + e.top + e.bottom)) / N.y;
          if (W < 0 || G < 0) return void us();
          const H = Math.min(c.aa(o.scale * Math.min(G, W)), h.maxZoom), K = c.P.convert(h.offset), Q = new c.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(c.ac(a)), J = K.add(Q).mult(o.scale / c.aH(H));
          return { center: ri(o.worldSize, f.add(y).div(2).sub(J)), zoom: H, bearing: a };
        }
        class Ji {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(e, i) {
            return { easingOffset: e, easingCenter: i.center };
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, i, a) {
            e.around.distSqr(i.centerPoint) < 0.01 || i.setLocationAtPoint(a, e.around);
          }
          cameraForBoxAndBearing(e, i, a, o, u) {
            return eo(e, i, a, o, u);
          }
          handleJumpToCenterZoom(e, i) {
            e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(c.Q.convert(i.center));
          }
          handleEaseTo(e, i) {
            const a = e.zoom, o = e.padding, u = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, f = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, _ = i.zoom !== void 0, y = !e.isPaddingEqual(i.padding);
            let v = !1;
            const T = _ ? +i.zoom : e.zoom;
            let S = e.centerPoint.add(i.offsetAsPoint);
            const M = e.screenPointToLocation(S), { center: k, zoom: R } = e.getConstrained(c.Q.convert(i.center || M), T ?? a);
            _i(e, k);
            const V = Bi(e.worldSize, M), j = Bi(e.worldSize, k).sub(V), N = c.aH(R - a);
            return v = R !== a, { easeFunc: (G) => {
              if (v && e.setZoom(c.B.number(a, R, G)), c.b5(u, f) || Oi({ startEulerAngles: u, endEulerAngles: f, tr: e, k: G, useSlerp: u.roll != f.roll }), y && (e.interpolatePadding(o, i.padding, G), S = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint);
              else {
                const W = c.aH(e.zoom - a), H = R > a ? Math.min(2, N) : Math.max(0.5, N), K = Math.pow(H, 1 - G), Q = ri(e.worldSize, V.add(j.mult(G * K)).mult(W));
                e.setLocationAtPoint(e.renderWorldCopies ? Q.wrap() : Q, S);
              }
            }, isZooming: v, elevationCenter: k };
          }
          handleFlyTo(e, i) {
            const a = i.zoom !== void 0, o = e.zoom, u = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), a ? +i.zoom : o), f = u.center, _ = u.zoom;
            _i(e, f);
            const y = Bi(e.worldSize, i.locationAtOffset), v = Bi(e.worldSize, f).sub(y), T = v.mag(), S = c.aH(_ - o);
            let M;
            if (i.minZoom !== void 0) {
              const k = Math.min(+i.minZoom, o, _), R = e.getConstrained(f, k).zoom;
              M = c.aH(R - o);
            }
            return { easeFunc: (k, R, V, j) => {
              e.setZoom(k === 1 ? _ : o + c.aa(R));
              const N = k === 1 ? f : ri(e.worldSize, y.add(v.mult(V)).mult(R));
              e.setLocationAtPoint(e.renderWorldCopies ? N.wrap() : N, j);
            }, scaleOfZoom: S, targetCenter: f, scaleOfMinZoom: M, pixelPathLength: T };
          }
        }
        class wt {
          constructor(e, i, a) {
            this.blendFunction = e, this.blendColor = i, this.mask = a;
          }
        }
        wt.Replace = [1, 0], wt.disabled = new wt(wt.Replace, c.b6.transparent, [!1, !1, !1, !1]), wt.unblended = new wt(wt.Replace, c.b6.transparent, [!0, !0, !0, !0]), wt.alphaBlended = new wt([1, 771], c.b6.transparent, [!0, !0, !0, !0]);
        const Ns = 2305;
        class it {
          constructor(e, i, a) {
            this.enable = e, this.mode = i, this.frontFace = a;
          }
        }
        it.disabled = new it(!1, 1029, Ns), it.backCCW = new it(!0, 1029, Ns), it.frontCCW = new it(!0, 1028, Ns);
        class Xe {
          constructor(e, i, a) {
            this.func = e, this.mask = i, this.range = a;
          }
        }
        Xe.ReadOnly = !1, Xe.ReadWrite = !0, Xe.disabled = new Xe(519, Xe.ReadOnly, [0, 1]);
        const Fn = 7680;
        class rt {
          constructor(e, i, a, o, u, f) {
            this.test = e, this.ref = i, this.mask = a, this.fail = o, this.depthFail = u, this.pass = f;
          }
        }
        rt.disabled = new rt({ func: 519, mask: 0 }, 0, 0, Fn, Fn, Fn);
        const ds = /* @__PURE__ */ new WeakMap();
        function ji(h) {
          var e;
          if (ds.has(h)) return ds.get(h);
          {
            const i = (e = h.getParameter(h.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return ds.set(h, i), i;
          }
        }
        class ps {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const i = e.context, a = i.gl;
            this._texFormat = a.RGBA, this._texType = a.UNSIGNED_BYTE;
            const o = new c.aE();
            o.emplaceBack(-1, -1), o.emplaceBack(2, -1), o.emplaceBack(-1, 2);
            const u = new c.aG();
            u.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Si(i.createVertexBuffer(o, Li.members), i.createIndexBuffer(u), c.aF.simpleSegment(0, 0, o.length, u.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(a.TEXTURE1);
            const f = a.createTexture();
            a.bindTexture(a.TEXTURE_2D, f), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST), a.texImage2D(a.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(f), ji(a) && (this._pbo = a.createBuffer(), a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.bufferData(a.PIXEL_PACK_BUFFER, 4, a.STREAM_READ), a.bindBuffer(a.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, i) {
            const a = this._updateCount;
            return this._readbackQueue ? a >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : a >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, i = e.gl;
            e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, i) {
            const a = this._cachedRenderContext.context, o = a.gl;
            if (this._bindFramebuffer(), a.viewport.set([0, 0, this._texWidth, this._texHeight]), a.clear({ color: c.b6.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(a, o.TRIANGLES, Xe.disabled, rt.disabled, wt.unblended, it.disabled, /* @__PURE__ */ ((u, f) => ({ u_input: u, u_output_expected: f }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ji(o)) {
              o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.readBuffer(o.COLOR_ATTACHMENT0), o.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
              const u = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
              o.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: u };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && ji(e)) {
              const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i === e.WAIT_FAILED) return c.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (i === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = ps._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let i = 0;
            return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128;
          }
        }
        const Zs = c.Z / 128;
        function fs(h, e) {
          const i = h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1, a = i + (h.generateBorders ? 2 : 0), o = i + (h.extendToNorthPole || h.generateBorders ? 1 : 0) + (h.extendToSouthPole || h.generateBorders ? 1 : 0), u = a + 1, f = o + 1, _ = h.generateBorders ? -1 : 0, y = h.generateBorders || h.extendToNorthPole ? -1 : 0, v = i + (h.generateBorders ? 1 : 0), T = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0), S = u * f, M = a * o * 6, k = u * f > 65536;
          if (k && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const R = k || e === "32bit", V = new Int16Array(2 * S);
          let j = 0;
          for (let W = y; W <= T; W++) for (let H = _; H <= v; H++) {
            let K = H / i * c.Z;
            H === -1 && (K = -64), H === i + 1 && (K = c.Z + Zs);
            let Q = W / i * c.Z;
            W === -1 && (Q = h.extendToNorthPole ? c.b8 : -64), W === i + 1 && (Q = h.extendToSouthPole ? c.b9 : c.Z + Zs), V[j++] = K, V[j++] = Q;
          }
          const N = R ? new Uint32Array(M) : new Uint16Array(M);
          let G = 0;
          for (let W = 0; W < o; W++) for (let H = 0; H < a; H++) {
            const K = H + 1 + W * u, Q = H + (W + 1) * u, J = H + 1 + (W + 1) * u;
            N[G++] = H + W * u, N[G++] = Q, N[G++] = K, N[G++] = K, N[G++] = Q, N[G++] = J;
          }
          return { vertices: V.buffer.slice(0), indices: N.buffer.slice(0), uses32bitIndices: R };
        }
        const On = new c.aD({ fill: new c.ba(128, 2), line: new c.ba(512, 0), tile: new c.ba(128, 32), stencil: new c.ba(128, 1), circle: 3 });
        class jn {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Xi.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Xi.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return On;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new ps(e));
            const i = c.S(this._errorQueryLatitudeDegrees), a = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - 0.5 * Math.PI, o = this._errorMeasurement.updateErrorLoop(i, a), u = He.now();
            o !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o, this._errorMeasurementLastChangeTime = u);
            const f = Math.min(Math.max((u - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = c.bb(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, c.bc(f));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, i, a, o, u) {
            const f = (u === "stencil" ? On.stencil : On.tile).getGranularityForZoomLevel(i.z);
            return this._getMesh(e, { granularity: f, generateBorders: a, extendToNorthPole: i.y === 0 && o, extendToSouthPole: i.y === (1 << i.z) - 1 && o });
          }
          _getMesh(e, i) {
            const a = this._getMeshKey(i);
            if (a in this._tileMeshCache) return this._tileMeshCache[a];
            const o = function(u, f) {
              const _ = fs(f, "16bit"), y = c.aE.deserialize({ arrayBuffer: _.vertices, length: _.vertices.byteLength / 2 / 2 }), v = c.aG.deserialize({ arrayBuffer: _.indices, length: _.indices.byteLength / 2 / 3 });
              return new Si(u.createVertexBuffer(y, Li.members), u.createIndexBuffer(v), c.aF.simpleSegment(0, 0, y.length, v.length));
            }(e, i);
            return this._tileMeshCache[a] = o, o;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = He.now();
            let i = !1;
            return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Ec = new c.r({ type: new c.D(c.v.projection.type) });
        class Us extends c.E {
          constructor(e) {
            super(), this._transitionable = new c.T(Ec), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0)), this._mercatorProjection = new Ya(), this._verticalPerspectiveProjection = new jn();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof c.bd) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, i, a, o, u) {
            return this.currentProjection.getMeshFromTileID(e, i, a, o, u);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function to(h) {
          const e = ui(h.worldSize, h.center.lat);
          return 2 * Math.PI * e;
        }
        function ms(h, e, i, a, o) {
          const u = 1 / (1 << o), f = e / c.Z * u + a * u, _ = c.bf((h / c.Z * u + i * u) * Math.PI * 2 + Math.PI, 2 * Math.PI), y = 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - 0.5 * Math.PI, v = Math.cos(y), T = new Float64Array(3);
          return T[0] = Math.sin(_) * v, T[1] = Math.sin(y), T[2] = Math.cos(_) * v, T;
        }
        function hi(h) {
          return function(e, i) {
            const a = Math.cos(i), o = new Float64Array(3);
            return o[0] = Math.sin(e) * a, o[1] = Math.sin(i), o[2] = Math.cos(e) * a, o;
          }(h.lng * Math.PI / 180, h.lat * Math.PI / 180);
        }
        function ui(h, e) {
          return h / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function Gs(h) {
          const e = Math.asin(h[1]) / Math.PI * 180, i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
          if (i > 1e-6) {
            const a = h[0] / i, o = Math.acos(h[2] / i), u = (a > 0 ? o : -o) / Math.PI * 180;
            return new c.Q(c.aK(u, -180, 180), e);
          }
          return new c.Q(0, e);
        }
        function Mi(h) {
          return Math.cos(h * Math.PI / 180);
        }
        function Rt(h, e) {
          const i = Mi(h), a = Mi(e);
          return c.aa(a / i);
        }
        function io(h, e) {
          const i = h.rotate(e.bearingInRadians), a = e.zoom + Rt(e.center.lat, 0), o = c.bb(1 / Mi(e.center.lat), 1 / Mi(Math.min(Math.abs(e.center.lat), 60)), c.be(a, 7, 3, 0, 1)), u = 360 / to({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new c.Q(e.center.lng - i.x * u * o, c.ad(e.center.lat + i.y * u, -85.051129, c.aI));
        }
        function $s(h) {
          const e = 0.5 * h, i = Math.sin(e), a = Math.cos(e);
          return Math.log(i + a) - Math.log(a - i);
        }
        function cn(h, e, i, a) {
          const o = h.lat + i * a;
          if (Math.abs(i) > 1) {
            const u = (Math.sign(h.lat + i) !== Math.sign(h.lat) ? -Math.abs(h.lat) : Math.abs(h.lat)) * Math.PI / 180, f = Math.abs(h.lat + i) * Math.PI / 180, _ = $s(u + a * (f - u)), y = $s(u), v = $s(f);
            return new c.Q(h.lng + e * ((_ - y) / (v - y)), o);
          }
          return new c.Q(h.lng + e * a, o);
        }
        class Ac {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._aabbFactory = e;
          }
          recalculateCache() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileAABB(e, i, a, o) {
            const u = `${e.z}_${e.x}_${e.y}`, f = this._cache.get(u);
            if (f) return f;
            const _ = this._cachePrevious.get(u);
            if (_) return this._cache.set(u, _), _;
            const y = this._aabbFactory(e, i, a, o);
            return this._cache.set(u, y), this._hadAnyChanges = !0, y;
          }
        }
        function qs(h, e, i) {
          const a = h - e;
          return a < 0 ? -a : Math.max(0, a - i);
        }
        function ro(h, e, i, a, o) {
          const u = h - i;
          let f;
          return f = u < 0 ? Math.min(-u, 1 + u - o) : u > 1 ? Math.min(Math.max(u - o, 0), 1 - u) : 0, Math.max(f, qs(e, a, o));
        }
        class zc {
          constructor() {
            this._aabbCache = new Ac(this._computeTileAABB);
          }
          recalculateCache() {
            this._aabbCache.recalculateCache();
          }
          distanceToTile2d(e, i, a, o) {
            const u = 1 << a.z, f = 1 / u, _ = a.x / u, y = a.y / u;
            let v = 2;
            return v = Math.min(v, ro(e, i, _, y, f)), v = Math.min(v, ro(e, i, _ + 0.5, -y - f, f)), v = Math.min(v, ro(e, i, _ + 0.5, 2 - y - f, f)), v;
          }
          getWrap(e, i, a) {
            const o = 1 << i.z, u = 1 / o, f = i.x / o, _ = qs(e.x, f, u), y = qs(e.x, f - 1, u), v = qs(e.x, f + 1, u), T = Math.min(_, y, v);
            return T === v ? 1 : T === y ? -1 : 0;
          }
          allowVariableZoom(e, i) {
            return yr(e, i) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileAABB(e, i, a, o) {
            return this._aabbCache.getTileAABB(e, i, a, o);
          }
          _computeTileAABB(e, i, a, o) {
            if (e.z <= 0) return new Ki([-1, -1, -1], [1, 1, 1]);
            if (e.z === 1) return new Ki([e.x === 0 ? -1 : 0, e.y === 0 ? 0 : -1, -1], [e.x === 0 ? 0 : 1, e.y === 0 ? 1 : 0, 1]);
            {
              const u = [ms(0, 0, e.x, e.y, e.z), ms(c.Z, 0, e.x, e.y, e.z), ms(c.Z, c.Z, e.x, e.y, e.z), ms(0, c.Z, e.x, e.y, e.z)], f = [1, 1, 1], _ = [-1, -1, -1];
              for (const y of u) for (let v = 0; v < 3; v++) f[v] = Math.min(f[v], y[v]), _[v] = Math.max(_[v], y[v]);
              if (e.y === 0 || e.y === (1 << e.z) - 1) {
                const y = [0, e.y === 0 ? 1 : -1, 0];
                for (let v = 0; v < 3; v++) f[v] = Math.min(f[v], y[v]), _[v] = Math.max(_[v], y[v]);
              }
              return new Ki(f, _);
            }
          }
        }
        class Ws {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, a) {
            return this._helper.interpolatePadding(e, i, a);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i) {
            this._helper.resize(e, i);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = c.bg(), this._projectionMatrix = c.b0(), this._globeViewProjMatrix32f = c.a$(), this._globeViewProjMatrixNoCorrection = c.b0(), this._globeViewProjMatrixNoCorrectionInverted = c.b0(), this._globeProjMatrixInverted = c.b0(), this._cameraPosition = c.bh(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Vs({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, i) => this.getConstrained(e, i) }), this._coveringTilesDetailsProvider = new zc();
          }
          clone() {
            const e = new Ws();
            return e.apply(this), e;
          }
          apply(e, i) {
            this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = c.bh();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: i, applyGlobeMatrix: a } = e, o = this._helper.getMercatorTileCoordinates(i);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: o, clippingPlane: this._cachedClippingPlane, projectionTransition: a ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const i = this.pitchInRadians, a = this.cameraToCenterDistance / e, o = Math.sin(i) * a, u = Math.cos(i) * a + 1, f = 1 / Math.sqrt(o * o + u * u) * 1;
            let _ = -o, y = u;
            const v = Math.sqrt(_ * _ + y * y);
            _ /= v, y /= v;
            const T = [0, _, y];
            return c.bi(T, T, [0, 0, 0], -this.bearingInRadians), c.bj(T, T, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), c.bk(T, T, [0, 0, 0], this.center.lng * Math.PI / 180), c.aN(T, T, 0.25), [...T, 0.25 * -f];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(hi(e));
          }
          transformLightDirection(e) {
            const i = this._helper._center.lng * Math.PI / 180, a = this._helper._center.lat * Math.PI / 180, o = Math.cos(a), u = [Math.sin(i) * o, Math.sin(a), Math.cos(i) * o], f = [u[2], 0, -u[0]], _ = [0, 0, 0];
            c.aT(_, f, u), c.aS(f, f), c.aS(_, _);
            const y = [0, 0, 0];
            return c.aS(y, [f[0] * e[0] + _[0] * e[1] + u[0] * e[2], f[1] * e[0] + _[1] * e[1] + u[1] * e[2], f[2] * e[0] + _[2] * e[1] + u[2] * e[2]]), y;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, i, a) {
            const o = function(_, y, v) {
              const T = 1 / (1 << v.z);
              return new c.$(_ / c.Z * T + v.x * T, y / c.Z * T + v.y * T);
            }(e, i, a.canonical), u = (f = o.y, [c.bf(o.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - 0.5 * Math.PI]);
            var f;
            return this.getCircleRadiusCorrection() / Math.cos(u[1]);
          }
          projectTileCoordinates(e, i, a, o) {
            const u = a.canonical, f = ms(e, i, u.x, u.y, u.z), _ = 1 + (o ? o(e, i) : 0) / c.bq, y = [f[0] * _, f[1] * _, f[2] * _, 1];
            c.ao(y, y, this._globeViewProjMatrixNoCorrection);
            const v = this._cachedClippingPlane, T = v[0] * f[0] + v[1] * f[1] + v[2] * f[2] + v[3] < 0;
            return { point: new c.P(y[0] / y[3], y[1] / y[3]), signedDistanceFromCamera: y[3], isOccluded: T };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = ui(this.worldSize, this.center.lat), i = c.b1(), a = c.b1();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), c.aX(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const o = this.centerOffset;
            i[8] = 2 * -o.x / this._helper._width, i[9] = 2 * o.y / this._helper._height, this._projectionMatrix = c.aY(i), this._globeProjMatrixInverted = c.b1(), c.ai(this._globeProjMatrixInverted, i), c.L(i, i, [0, 0, -this.cameraToCenterDistance]), c.aZ(i, i, this.rollInRadians), c.a_(i, i, -this.pitchInRadians), c.aZ(i, i, this.bearingInRadians), c.L(i, i, [0, 0, -e]);
            const u = c.bh();
            u[0] = e, u[1] = e, u[2] = e, c.a_(a, i, this.center.lat * Math.PI / 180), c.bl(a, a, -this.center.lng * Math.PI / 180), c.M(a, a, u), this._globeViewProjMatrixNoCorrection = a, c.a_(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), c.bl(i, i, -this.center.lng * Math.PI / 180), c.M(i, i, u), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = c.b1(), c.ai(this._globeViewProjMatrixNoCorrectionInverted, a);
            const f = c.bh();
            this._cameraPosition = c.bh(), this._cameraPosition[2] = this.cameraToCenterDistance / e, c.bi(this._cameraPosition, this._cameraPosition, f, -this.rollInRadians), c.bj(this._cameraPosition, this._cameraPosition, f, this.pitchInRadians), c.bi(this._cameraPosition, this._cameraPosition, f, -this.bearingInRadians), c.aO(this._cameraPosition, this._cameraPosition, [0, 0, 1]), c.bj(this._cameraPosition, this._cameraPosition, f, -this.center.lat * Math.PI / 180), c.bk(this._cameraPosition, this._cameraPosition, f, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const _ = c.aY(this._globeViewProjMatrixNoCorrectionInverted);
            c.M(_, _, [1, 1, -1]), this._cachedFrustum = Fr.fromInvProjectionMatrix(_);
          }
          calculateFogMatrix(e) {
            c.w("calculateFogMatrix is not supported on globe projection.");
            const i = c.b1();
            return c.as(i), i;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new c.aV(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && c.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, i) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const a = hi(e);
            c.aN(a, a, 1 + i / c.bq);
            const o = c.bg();
            return c.ao(o, [a[0], a[1], a[2], 1], this._globeViewProjMatrixNoCorrection), o[2] / o[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, i = 0.5 * this.height, a = [new c.P(0, 0), new c.P(e, 0), new c.P(this.width, 0), new c.P(this.width, i), new c.P(this.width, this.height), new c.P(e, this.height), new c.P(0, this.height), new c.P(0, i)], o = [];
            for (const S of a) o.push(this.unprojectScreenPoint(S));
            let u = 0, f = 0, _ = 0, y = 0;
            const v = this.center;
            for (const S of o) {
              const M = c.bm(v.lng, S.lng), k = c.bm(v.lat, S.lat);
              M < f && (f = M), M > u && (u = M), k < y && (y = k), k > _ && (_ = k);
            }
            const T = [v.lng + f, v.lat + y, v.lng + u, v.lat + _];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (T[3] = 90, T[0] = -180, T[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (T[1] = -90, T[0] = -180, T[2] = 180), new Dt(T);
          }
          getConstrained(e, i) {
            const a = c.ad(e.lat, -85.051129, c.aI), o = c.ad(+i, this.minZoom + Rt(0, a), this.maxZoom);
            return { center: new c.Q(e.lng, a), zoom: o };
          }
          calculateCenterFromCameraLngLatAlt(e, i, a, o) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, a, o);
          }
          setLocationAtPoint(e, i) {
            const a = hi(this.unprojectScreenPoint(i)), o = hi(e), u = c.bh();
            c.bn(u);
            const f = c.bh();
            c.bk(f, a, u, -this.center.lng * Math.PI / 180), c.bj(f, f, u, this.center.lat * Math.PI / 180);
            const _ = o[0] * o[0] + o[2] * o[2], y = f[0] * f[0];
            if (_ < y) return;
            const v = Math.sqrt(_ - y), T = -v, S = c.bo(o[0], o[2], f[0], v), M = c.bo(o[0], o[2], f[0], T), k = c.bh();
            c.bk(k, o, u, -S);
            const R = c.bo(k[1], k[2], f[1], f[2]), V = c.bh();
            c.bk(V, o, u, -M);
            const j = c.bo(V[1], V[2], f[1], f[2]), N = 0.5 * Math.PI, G = R >= -N && R <= N, W = j >= -N && j <= N;
            let H, K;
            if (G && W) {
              const oe = this.center.lng * Math.PI / 180, fe = this.center.lat * Math.PI / 180;
              c.br(S, oe) + c.br(R, fe) < c.br(M, oe) + c.br(j, fe) ? (H = S, K = R) : (H = M, K = j);
            } else if (G) H = S, K = R;
            else {
              if (!W) return;
              H = M, K = j;
            }
            const Q = H / Math.PI * 180, J = K / Math.PI * 180, se = this.center.lat;
            this.setCenter(new c.Q(Q, c.ad(J, -90, 90))), this.setZoom(this.zoom + Rt(se, this.center.lat));
          }
          locationToScreenPoint(e, i) {
            const a = hi(e);
            if (i) {
              const o = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
              c.aN(a, a, 1 + o / c.bq);
            }
            return this._projectSurfacePointToScreen(a);
          }
          _projectSurfacePointToScreen(e) {
            const i = c.bg();
            return c.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new c.P((0.5 * i[0] + 0.5) * this.width, (0.5 * -i[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, i) {
            if (i) {
              const a = i.pointCoordinate(e);
              if (a) return a;
            }
            return c.$.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, i) {
            var a;
            return (a = this.screenPointToMercatorCoordinate(e, i)) === null || a === void 0 ? void 0 : a.toLngLat();
          }
          isPointOnMapSurface(e, i) {
            const a = this._cameraPosition, o = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(a, o);
          }
          getRayDirectionFromPixel(e) {
            const i = c.bg();
            i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, c.ao(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3];
            const a = c.bh();
            a[0] = i[0] - this._cameraPosition[0], a[1] = i[1] - this._cameraPosition[1], a[2] = i[2] - this._cameraPosition[2];
            const o = c.bh();
            return c.aS(o, a), o;
          }
          isSurfacePointVisible(e) {
            const i = this._cachedClippingPlane;
            return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return !1;
            const i = c.bg();
            return c.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1;
          }
          rayPlanetIntersection(e, i) {
            const a = c.aU(e, i), o = c.bh(), u = c.bh();
            c.aN(u, i, a), c.aR(o, e, u);
            const f = 1 - c.aU(o, o);
            if (f < 0) return null;
            const _ = c.aU(e, e) - 1, y = -a + (a < 0 ? 1 : -1) * Math.sqrt(f), v = _ / y, T = y;
            return { tMin: Math.min(v, T), tMax: Math.max(v, T) };
          }
          unprojectScreenPoint(e) {
            const i = this._cameraPosition, a = this.getRayDirectionFromPixel(e), o = this.rayPlanetIntersection(i, a);
            if (o) {
              const v = c.bh();
              c.aO(v, i, [a[0] * o.tMin, a[1] * o.tMin, a[2] * o.tMin]);
              const T = c.bh();
              return c.aS(T, v), Gs(T);
            }
            const u = this._cachedClippingPlane[0] * a[0] + this._cachedClippingPlane[1] * a[1] + this._cachedClippingPlane[2] * a[2], f = -c.bp(this._cachedClippingPlane, i) / u, _ = c.bh();
            if (f > 0) c.aO(_, i, [a[0] * f, a[1] * f, a[2] * f]);
            else {
              const v = c.bh();
              c.aO(v, i, [2 * a[0], 2 * a[1], 2 * a[2]]);
              const T = c.bp(this._cachedClippingPlane, v);
              c.aR(_, v, [this._cachedClippingPlane[0] * T, this._cachedClippingPlane[1] * T, this._cachedClippingPlane[2] * T]);
            }
            const y = c.bh();
            return c.aS(y, _), Gs(y);
          }
          getMatrixForModel(e, i) {
            const a = c.Q.convert(e), o = 1 / c.bq, u = c.b0();
            return c.bl(u, u, a.lng / 180 * Math.PI), c.a_(u, u, -a.lat / 180 * Math.PI), c.L(u, u, [0, 0, 1 + i / c.bq]), c.a_(u, u, 0.5 * Math.PI), c.M(u, u, [o, o, o]), u;
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this.getProjectionData({ overscaledTileID: new c.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return i.tileMercatorCoords = [0, 0, 1, 1], i;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class Hs {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, i, a) {
            return this._helper.interpolatePadding(e, i, a);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, i, a = !0) {
            this._helper.resize(e, i, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, i) {
            this._helper.overrideNearFarZ(e, i);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, i) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Vs({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, i) => this.getConstrained(e, i) }), this._globeness = 1, this._mercatorTransform = new Fi(), this._verticalPerspectiveTransform = new Ws();
          }
          clone() {
            const e = new Hs();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const i = this._mercatorTransform.getProjectionData(e), a = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? a.mainMatrix : i.mainMatrix, clippingPlane: a.clippingPlane, tileMercatorCoords: a.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: i.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return c.bb(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return c.bb(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, i, a) {
            const o = this._mercatorTransform.getPitchedTextCorrection(e, i, a), u = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, a);
            return c.bb(o, u, this._globeness);
          }
          projectTileCoordinates(e, i, a, o) {
            return this.currentTransform.projectTileCoordinates(e, i, a, o);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, i) {
            return this.currentTransform.lngLatToCameraDepth(e, i);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, i) {
            return this.currentTransform.getConstrained(e, i);
          }
          calculateCenterFromCameraLngLatAlt(e, i, a, o) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, i, a, o);
          }
          setLocationAtPoint(e, i) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, i) {
            return this.currentTransform.locationToScreenPoint(e, i);
          }
          screenPointToMercatorCoordinate(e, i) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, i);
          }
          screenPointToLocation(e, i) {
            return this.currentTransform.screenPointToLocation(e, i);
          }
          isPointOnMapSurface(e, i) {
            return this.currentTransform.isPointOnMapSurface(e, i);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, i) {
            return this.currentTransform.getMatrixForModel(e, i);
          }
          getProjectionDataForCustomLayer(e = !0) {
            const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return i;
            const a = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return a.fallbackMatrix = i.mainMatrix, a;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class vi {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(e, i) {
            const a = io(e, i);
            return Math.abs(a.lng - i.center.lng) > 180 && (a.lng = i.center.lng + 179.5 * Math.sign(a.lng - i.center.lng)), { easingCenter: a, easingOffset: new c.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            const a = e.around, o = i.screenPointToLocation(a);
            e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta);
            const u = i.zoom;
            e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
            const f = i.zoom - u;
            if (f === 0) return;
            const _ = c.bm(i.center.lng, o.lng), y = _ / (Math.abs(_ / 180) + 1), v = c.bm(i.center.lat, o.lat), T = i.getRayDirectionFromPixel(a), S = i.cameraPosition, M = -1 * c.aU(S, T), k = c.bh();
            c.aO(k, S, [T[0] * M, T[1] * M, T[2] * M]);
            const R = c.bs(k) - 1, V = Math.exp(0.5 * -Math.max(R - 0.3, 0)), j = ui(i.worldSize, i.center.lat) / Math.min(i.width, i.height), N = c.be(j, 0.9, 0.5, 1, 0.25), G = (1 - c.aH(-f)) * Math.min(V, N), W = i.center.lat, H = i.zoom, K = new c.Q(i.center.lng + y * G, c.ad(i.center.lat + v * G, -85.051129, c.aI));
            i.setLocationAtPoint(o, a);
            const Q = i.center, J = c.be(Math.abs(_), 45, 85, 0, 1), se = c.be(j, 0.75, 0.35, 0, 1), oe = Math.pow(Math.max(J, se), 0.25), fe = c.bm(Q.lng, K.lng), _e = c.bm(Q.lat, K.lat);
            i.setCenter(new c.Q(Q.lng + fe * oe, Q.lat + _e * oe).wrap()), i.setZoom(H + Rt(W, i.center.lat));
          }
          handleMapControlsPan(e, i, a) {
            if (!e.panDelta) return;
            const o = i.center.lat, u = i.zoom;
            i.setCenter(io(e.panDelta, i).wrap()), i.setZoom(u + Rt(o, i.center.lat));
          }
          cameraForBoxAndBearing(e, i, a, o, u) {
            const f = eo(e, i, a, o, u), _ = i.left / u.width * 2 - 1, y = (u.width - i.right) / u.width * 2 - 1, v = i.top / u.height * -2 + 1, T = (u.height - i.bottom) / u.height * -2 + 1, S = c.bm(a.getWest(), a.getEast()) < 0, M = S ? a.getEast() : a.getWest(), k = S ? a.getWest() : a.getEast(), R = Math.max(a.getNorth(), a.getSouth()), V = Math.min(a.getNorth(), a.getSouth()), j = M + 0.5 * c.bm(M, k), N = R + 0.5 * c.bm(R, V), G = u.clone();
            G.setCenter(f.center), G.setBearing(f.bearing), G.setPitch(0), G.setRoll(0), G.setZoom(f.zoom);
            const W = G.modelViewProjectionMatrix, H = [hi(a.getNorthWest()), hi(a.getNorthEast()), hi(a.getSouthWest()), hi(a.getSouthEast()), hi(new c.Q(k, N)), hi(new c.Q(M, N)), hi(new c.Q(j, R)), hi(new c.Q(j, V))], K = hi(f.center);
            let Q = Number.POSITIVE_INFINITY;
            for (const J of H) _ < 0 && (Q = vi.getLesserNonNegativeNonNull(Q, vi.solveVectorScale(J, K, W, "x", _))), y > 0 && (Q = vi.getLesserNonNegativeNonNull(Q, vi.solveVectorScale(J, K, W, "x", y))), v > 0 && (Q = vi.getLesserNonNegativeNonNull(Q, vi.solveVectorScale(J, K, W, "y", v))), T < 0 && (Q = vi.getLesserNonNegativeNonNull(Q, vi.solveVectorScale(J, K, W, "y", T)));
            if (Number.isFinite(Q) && Q !== 0) return f.zoom = G.zoom + c.aa(Q), f;
            us();
          }
          handleJumpToCenterZoom(e, i) {
            const a = e.center.lat, o = e.getConstrained(i.center ? c.Q.convert(i.center) : e.center, e.zoom).center;
            e.setCenter(o.wrap());
            const u = i.zoom !== void 0 ? +i.zoom : e.zoom + Rt(a, o.lat);
            e.zoom !== u && e.setZoom(u);
          }
          handleEaseTo(e, i) {
            const a = e.zoom, o = e.center, u = e.padding, f = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, _ = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, y = i.zoom !== void 0, v = !e.isPaddingEqual(i.padding);
            let T = !1;
            const S = i.center ? c.Q.convert(i.center) : o, M = e.getConstrained(S, a).center;
            _i(e, M);
            const k = e.clone();
            k.setCenter(M), k.setZoom(y ? +i.zoom : a + Rt(o.lat, S.lat)), k.setBearing(i.bearing);
            const R = new c.P(c.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            k.setLocationAtPoint(M, R);
            const V = (i.offset && i.offsetAsPoint.mag()) > 0 ? k.center : M, j = y ? +i.zoom : a + Rt(o.lat, V.lat), N = a + Rt(o.lat, 0), G = j + Rt(V.lat, 0), W = c.bm(o.lng, V.lng), H = c.bm(o.lat, V.lat), K = c.aH(G - N);
            return T = j !== a, { easeFunc: (Q) => {
              if (c.b5(f, _) || Oi({ startEulerAngles: f, endEulerAngles: _, tr: e, k: Q, useSlerp: f.roll != _.roll }), v && e.interpolatePadding(u, i.padding, Q), i.around) c.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint);
              else {
                const J = G > N ? Math.min(2, K) : Math.max(0.5, K), se = Math.pow(J, 1 - Q), oe = cn(o, W, H, Q * se);
                e.setCenter(oe.wrap());
              }
              if (T) {
                const J = c.B.number(N, G, Q) + Rt(0, e.center.lat);
                e.setZoom(J);
              }
            }, isZooming: T, elevationCenter: V };
          }
          handleFlyTo(e, i) {
            const a = i.zoom !== void 0, o = e.center, u = e.zoom, f = e.padding, _ = !e.isPaddingEqual(i.padding), y = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), u).center, v = a ? +i.zoom : e.zoom + Rt(e.center.lat, y.lat), T = e.clone();
            T.setCenter(y), T.setZoom(v), T.setBearing(i.bearing);
            const S = new c.P(c.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
            T.setLocationAtPoint(y, S);
            const M = T.center;
            _i(e, M);
            const k = function(H, K, Q) {
              const J = hi(K), se = hi(Q), oe = c.aU(J, se), fe = Math.acos(oe), _e = to(H);
              return fe / (2 * Math.PI) * _e;
            }(e, o, M), R = u + Rt(o.lat, 0), V = v + Rt(M.lat, 0), j = c.aH(V - R);
            let N;
            if (typeof i.minZoom == "number") {
              const H = +i.minZoom + Rt(M.lat, 0), K = Math.min(H, R, V) + Rt(0, M.lat), Q = e.getConstrained(M, K).zoom + Rt(M.lat, 0);
              N = c.aH(Q - R);
            }
            const G = c.bm(o.lng, M.lng), W = c.bm(o.lat, M.lat);
            return { easeFunc: (H, K, Q, J) => {
              const se = cn(o, G, W, Q);
              _ && e.interpolatePadding(f, i.padding, H);
              const oe = H === 1 ? M : se;
              e.setCenter(oe.wrap());
              const fe = R + c.aa(K);
              e.setZoom(H === 1 ? v : fe + Rt(0, oe.lat));
            }, scaleOfZoom: j, targetCenter: M, scaleOfMinZoom: N, pixelPathLength: k };
          }
          static solveVectorScale(e, i, a, o, u) {
            const f = o === "x" ? [a[0], a[4], a[8], a[12]] : [a[1], a[5], a[9], a[13]], _ = [a[3], a[7], a[11], a[15]], y = e[0] * f[0] + e[1] * f[1] + e[2] * f[2], v = e[0] * _[0] + e[1] * _[1] + e[2] * _[2], T = i[0] * f[0] + i[1] * f[1] + i[2] * f[2], S = i[0] * _[0] + i[1] * _[1] + i[2] * _[2];
            return T + u * v === y + u * S || _[3] * (y - T) + f[3] * (S - v) + y * S == T * v ? null : (T + f[3] - u * S - u * _[3]) / (T - y - u * S + u * v);
          }
          static getLesserNonNegativeNonNull(e, i) {
            return i !== null && i >= 0 && i < e ? i : e;
          }
        }
        class Xs {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new Ji(), this._verticalPerspectiveCameraHelper = new vi();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, i) {
            return this.currentHelper.handlePanInertia(e, i);
          }
          handleMapControlsRollPitchBearingZoom(e, i) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i);
          }
          handleMapControlsPan(e, i, a) {
            this.currentHelper.handleMapControlsPan(e, i, a);
          }
          cameraForBoxAndBearing(e, i, a, o, u) {
            return this.currentHelper.cameraForBoxAndBearing(e, i, a, o, u);
          }
          handleJumpToCenterZoom(e, i) {
            this.currentHelper.handleJumpToCenterZoom(e, i);
          }
          handleEaseTo(e, i) {
            return this.currentHelper.handleEaseTo(e, i);
          }
          handleFlyTo(e, i) {
            return this.currentHelper.handleFlyTo(e, i);
          }
        }
        const hn = (h, e) => c.x(h, e && e.filter((i) => i.identifier !== "source.canvas")), no = c.bt();
        class _s extends c.E {
          constructor(e, i = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const a in this.sourceCaches) {
                const o = this.sourceCaches[a].getSource().type;
                o !== "vector" && o !== "geojson" || this.sourceCaches[a].reload();
              }
            }, this.map = e, this.dispatcher = new Qr(Yr(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (a, o) => this.getGlyphs(a, o)), this.dispatcher.registerMessageHandler("GI", (a, o) => this.getImages(a, o)), this.imageManager = new Bs(), this.imageManager.setEventedParent(this), this.glyphManager = new li(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new Jr(256, 512), this.crossTileSymbolIndex = new Ja(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.bu(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.bv()), gr().on(zn, this._rtlPluginLoaded), this.on("data", (a) => {
              if (a.dataType !== "source" || a.sourceDataType !== "metadata") return;
              const o = this.sourceCaches[a.sourceId];
              if (!o) return;
              const u = o.getSource();
              if (u && u.vectorLayerIds) for (const f in this._layers) {
                const _ = this._layers[f];
                _.source === u.id && this._validateLayer(_);
              }
            });
          }
          loadURL(e, i = {}, a) {
            this.fire(new c.l("dataloading", { dataType: "style" })), i.validate = typeof i.validate != "boolean" || i.validate;
            const o = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const u = this._loadStyleRequest;
            c.j(o, this._loadStyleRequest).then((f) => {
              this._loadStyleRequest = null, this._load(f.data, i, a);
            }).catch((f) => {
              this._loadStyleRequest = null, f && !u.signal.aborted && this.fire(new c.k(f));
            });
          }
          loadJSON(e, i = {}, a) {
            this.fire(new c.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), He.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, a);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new c.l("dataloading", { dataType: "style" })), this._load(no, { validate: !1 });
          }
          _load(e, i, a) {
            var o, u;
            const f = i.transformStyle ? i.transformStyle(a, e) : e;
            if (!i.validate || !hn(this, c.y(f))) {
              this._loaded = !0, this.stylesheet = f;
              for (const _ in f.sources) this.addSource(_, f.sources[_], { validate: !1 });
              f.sprite ? this._loadSprite(f.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(f.glyphs), this._createLayers(), this.light = new Cn(this.stylesheet.light), this._setProjectionInternal(((o = this.stylesheet.projection) === null || o === void 0 ? void 0 : o.type) || "mercator"), this.sky = new Kr(this.stylesheet.sky), this.map.setTerrain((u = this.stylesheet.terrain) !== null && u !== void 0 ? u : null), this.fire(new c.l("data", { dataType: "style" })), this.fire(new c.l("style.load"));
            }
          }
          _createLayers() {
            const e = c.bw(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e), this._order = e.map((i) => i.id), this._layers = {}, this._serializedLayers = null;
            for (const i of e) {
              const a = c.bx(i);
              a.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = a;
            }
          }
          _loadSprite(e, i = !1, a = void 0) {
            let o;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(u, f, _, y) {
              return c._(this, void 0, void 0, function* () {
                const v = Mt(u), T = _ > 1 ? "@2x" : "", S = {}, M = {};
                for (const { id: k, url: R } of v) {
                  const V = f.transformRequest(bt(R, T, ".json"), "SpriteJSON");
                  S[k] = c.j(V, y);
                  const j = f.transformRequest(bt(R, T, ".png"), "SpriteImage");
                  M[k] = mi.getImage(j, y);
                }
                return yield Promise.all([...Object.values(S), ...Object.values(M)]), function(k, R) {
                  return c._(this, void 0, void 0, function* () {
                    const V = {};
                    for (const j in k) {
                      V[j] = {};
                      const N = He.getImageCanvasContext((yield R[j]).data), G = (yield k[j]).data;
                      for (const W in G) {
                        const { width: H, height: K, x: Q, y: J, sdf: se, pixelRatio: oe, stretchX: fe, stretchY: _e, content: pe, textFitWidth: Ie, textFitHeight: Se } = G[W];
                        V[j][W] = { data: null, pixelRatio: oe, sdf: se, stretchX: fe, stretchY: _e, content: pe, textFitWidth: Ie, textFitHeight: Se, spriteData: { width: H, height: K, x: Q, y: J, context: N } };
                      }
                    }
                    return V;
                  });
                }(S, M);
              });
            }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((u) => {
              if (this._spriteRequest = null, u) for (const f in u) {
                this._spritesImagesIds[f] = [];
                const _ = this._spritesImagesIds[f] ? this._spritesImagesIds[f].filter((y) => !(y in u)) : [];
                for (const y of _) this.imageManager.removeImage(y), this._changedImages[y] = !0;
                for (const y in u[f]) {
                  const v = f === "default" ? y : `${f}:${y}`;
                  this._spritesImagesIds[f].push(v), v in this.imageManager.images ? this.imageManager.updateImage(v, u[f][y], !1) : this.imageManager.addImage(v, u[f][y]), i && (this._changedImages[v] = !0);
                }
              }
            }).catch((u) => {
              this._spriteRequest = null, o = u, this.fire(new c.k(o));
            }).finally(() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })), a && a(o);
            });
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const i = this.sourceCaches[e.source];
            if (!i) return;
            const a = e.sourceLayer;
            if (!a) return;
            const o = i.getSource();
            (o.type === "geojson" || o.vectorLayerIds && o.vectorLayerIds.indexOf(a) === -1) && this.fire(new c.k(new Error(`Source layer "${a}" does not exist on source "${o.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, i = !1) {
            const a = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(i ? c.by(a) : a);
            const o = [];
            for (const u of e) if (a[u]) {
              const f = i ? c.by(a[u]) : a[u];
              o.push(f);
            }
            return o;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const i = Object.keys(this._layers);
            for (const a of i) {
              const o = this._layers[a];
              o.type !== "custom" && (e[a] = o.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, i, a;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((a = this.projection) === null || a === void 0) && a.hasTransition()) return !0;
            for (const o in this.sourceCaches) if (this.sourceCaches[o].hasTransition()) return !0;
            for (const o in this._layers) if (this._layers[o].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const i = this._changed;
            if (i) {
              const o = Object.keys(this._updatedLayers), u = Object.keys(this._removedLayers);
              (o.length || u.length) && this._updateWorkerLayers(o, u);
              for (const f in this._updatedSources) {
                const _ = this._updatedSources[f];
                if (_ === "reload") this._reloadSource(f);
                else {
                  if (_ !== "clear") throw new Error(`Invalid action ${_}`);
                  this._clearSource(f);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const f in this._updatedPaintProps) this._layers[f].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const a = {};
            for (const o in this.sourceCaches) {
              const u = this.sourceCaches[o];
              a[o] = u.used, u.used = !1;
            }
            for (const o of this._order) {
              const u = this._layers[o];
              u.recalculate(e, this._availableImages), !u.isHidden(e.zoom) && u.source && (this.sourceCaches[u.source].used = !0);
            }
            for (const o in a) {
              const u = this.sourceCaches[o];
              !!a[o] != !!u.used && u.fire(new c.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: o }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new c.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(e, i) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: i });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(e, i = {}) {
            var a;
            this._checkLoaded();
            const o = this.serialize();
            if (e = i.transformStyle ? i.transformStyle(o, e) : e, ((a = i.validate) === null || a === void 0 || a) && hn(this, c.y(e))) return !1;
            (e = c.by(e)).layers = c.bw(e.layers);
            const u = c.bz(o, e), f = this._getOperationsToPerform(u);
            if (f.unimplemented.length > 0) throw new Error(`Unimplemented: ${f.unimplemented.join(", ")}.`);
            if (f.operations.length === 0) return !1;
            for (const _ of f.operations) _();
            return this.stylesheet = e, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(e) {
            const i = [], a = [];
            for (const o of e) switch (o.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                i.push(() => this.addLayer.apply(this, o.args));
                break;
              case "removeLayer":
                i.push(() => this.removeLayer.apply(this, o.args));
                break;
              case "setPaintProperty":
                i.push(() => this.setPaintProperty.apply(this, o.args));
                break;
              case "setLayoutProperty":
                i.push(() => this.setLayoutProperty.apply(this, o.args));
                break;
              case "setFilter":
                i.push(() => this.setFilter.apply(this, o.args));
                break;
              case "addSource":
                i.push(() => this.addSource.apply(this, o.args));
                break;
              case "removeSource":
                i.push(() => this.removeSource.apply(this, o.args));
                break;
              case "setLayerZoomRange":
                i.push(() => this.setLayerZoomRange.apply(this, o.args));
                break;
              case "setLight":
                i.push(() => this.setLight.apply(this, o.args));
                break;
              case "setGeoJSONSourceData":
                i.push(() => this.setGeoJSONSourceData.apply(this, o.args));
                break;
              case "setGlyphs":
                i.push(() => this.setGlyphs.apply(this, o.args));
                break;
              case "setSprite":
                i.push(() => this.setSprite.apply(this, o.args));
                break;
              case "setTerrain":
                i.push(() => this.map.setTerrain.apply(this, o.args));
                break;
              case "setSky":
                i.push(() => this.setSky.apply(this, o.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, o.args);
                break;
              case "setTransition":
                i.push(() => {
                });
                break;
              default:
                a.push(o.command);
            }
            return { operations: i, unimplemented: a };
          }
          addImage(e, i) {
            if (this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, i), this._afterImageUpdated(e);
          }
          updateImage(e, i) {
            this.imageManager.updateImage(e, i);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, i, a = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(c.y.source, `sources.${e}`, i, null, a)) return;
            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
            const o = this.sourceCaches[e] = new P(e, i, this.dispatcher);
            o.style = this, o.setEventedParent(this, () => ({ isSourceLoaded: o.loaded(), source: o.serialize(), sourceId: e })), o.onAdd(this.map), this._changed = !0;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const a in this._layers) if (this._layers[a].source === e) return this.fire(new c.k(new Error(`Source "${e}" cannot be removed while layer "${a}" is using it.`)));
            const i = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new c.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(e, i) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const a = this.sourceCaches[e].getSource();
            if (a.type !== "geojson") throw new Error(`geojsonSource.type is ${a.type}, which is !== 'geojson`);
            a.setData(i), this._changed = !0;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, i, a = {}) {
            this._checkLoaded();
            const o = e.id;
            if (this.getLayer(o)) return void this.fire(new c.k(new Error(`Layer "${o}" already exists on this map.`)));
            let u;
            if (e.type === "custom") {
              if (hn(this, c.bA(e))) return;
              u = c.bx(e);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(o, e.source), e = c.by(e), e = c.e(e, { source: o })), this._validate(c.y.layer, `layers.${o}`, e, { arrayIndex: -1 }, a)) return;
              u = c.bx(e), this._validateLayer(u), u.setEventedParent(this, { layer: { id: o } });
            }
            const f = i ? this._order.indexOf(i) : this._order.length;
            if (i && f === -1) this.fire(new c.k(new Error(`Cannot add layer "${o}" before non-existing layer "${i}".`)));
            else {
              if (this._order.splice(f, 0, o), this._layerOrderChanged = !0, this._layers[o] = u, this._removedLayers[o] && u.source && u.type !== "custom") {
                const _ = this._removedLayers[o];
                delete this._removedLayers[o], _.type !== u.type ? this._updatedSources[u.source] = "clear" : (this._updatedSources[u.source] = "reload", this.sourceCaches[u.source].pause());
              }
              this._updateLayer(u), u.onAdd && u.onAdd(this.map);
            }
          }
          moveLayer(e, i) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new c.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === i) return;
            const a = this._order.indexOf(e);
            this._order.splice(a, 1);
            const o = i ? this._order.indexOf(i) : this._order.length;
            i && o === -1 ? this.fire(new c.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(o, 0, e), this._layerOrderChanged = !0);
          }
          removeLayer(e) {
            this._checkLoaded();
            const i = this._layers[e];
            if (!i) return void this.fire(new c.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            i.setEventedParent(null);
            const a = this._order.indexOf(e);
            this._order.splice(a, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, i, a) {
            this._checkLoaded();
            const o = this.getLayer(e);
            o ? o.minzoom === i && o.maxzoom === a || (i != null && (o.minzoom = i), a != null && (o.maxzoom = a), this._updateLayer(o)) : this.fire(new c.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, i, a = {}) {
            this._checkLoaded();
            const o = this.getLayer(e);
            if (o) {
              if (!c.bB(o.filter, i)) return i == null ? (o.filter = void 0, void this._updateLayer(o)) : void (this._validate(c.y.filter, `layers.${o.id}.filter`, i, null, a) || (o.filter = c.by(i), this._updateLayer(o)));
            } else this.fire(new c.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return c.by(this.getLayer(e).filter);
          }
          setLayoutProperty(e, i, a, o = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? c.bB(u.getLayoutProperty(i), a) || (u.setLayoutProperty(i, a, o), this._updateLayer(u)) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, i) {
            const a = this.getLayer(e);
            if (a) return a.getLayoutProperty(i);
            this.fire(new c.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, i, a, o = {}) {
            this._checkLoaded();
            const u = this.getLayer(e);
            u ? c.bB(u.getPaintProperty(i), a) || (u.setPaintProperty(i, a, o) && this._updateLayer(u), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getPaintProperty(e, i) {
            return this.getLayer(e).getPaintProperty(i);
          }
          setFeatureState(e, i) {
            this._checkLoaded();
            const a = e.source, o = e.sourceLayer, u = this.sourceCaches[a];
            if (u === void 0) return void this.fire(new c.k(new Error(`The source '${a}' does not exist in the map's style.`)));
            const f = u.getSource().type;
            f === "geojson" && o ? this.fire(new c.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : f !== "vector" || o ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), u.setFeatureState(o, e.id, i)) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, i) {
            this._checkLoaded();
            const a = e.source, o = this.sourceCaches[a];
            if (o === void 0) return void this.fire(new c.k(new Error(`The source '${a}' does not exist in the map's style.`)));
            const u = o.getSource().type, f = u === "vector" ? e.sourceLayer : void 0;
            u !== "vector" || f ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new c.k(new Error("A feature id is required to remove its specific state property."))) : o.removeFeatureState(f, e.id, i) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const i = e.source, a = e.sourceLayer, o = this.sourceCaches[i];
            if (o !== void 0) return o.getSource().type !== "vector" || a ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), o.getFeatureState(a, e.id)) : void this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new c.k(new Error(`The source '${i}' does not exist in the map's style.`)));
          }
          getTransition() {
            return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = c.bC(this.sourceCaches, (u) => u.serialize()), i = this._serializeByIds(this._order, !0), a = this.map.getTerrain() || void 0, o = this.stylesheet;
            return c.bD({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, sky: o.sky, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, projection: o.projection, sources: e, layers: i, terrain: a }, (u) => u !== void 0);
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(e) {
            const i = (f) => this._layers[f].type === "fill-extrusion", a = {}, o = [];
            for (let f = this._order.length - 1; f >= 0; f--) {
              const _ = this._order[f];
              if (i(_)) {
                a[_] = f;
                for (const y of e) {
                  const v = y[_];
                  if (v) for (const T of v) o.push(T);
                }
              }
            }
            o.sort((f, _) => _.intersectionZ - f.intersectionZ);
            const u = [];
            for (let f = this._order.length - 1; f >= 0; f--) {
              const _ = this._order[f];
              if (i(_)) for (let y = o.length - 1; y >= 0; y--) {
                const v = o[y].feature;
                if (a[v.layer.id] < f) break;
                u.push(v), o.pop();
              }
              else for (const y of e) {
                const v = y[_];
                if (v) for (const T of v) u.push(T.feature);
              }
            }
            return u;
          }
          queryRenderedFeatures(e, i, a) {
            i && i.filter && this._validate(c.y.filter, "queryRenderedFeatures.filter", i.filter, null, i);
            const o = {};
            if (i && i.layers) {
              if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new c.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const v of i.layers) {
                const T = this._layers[v];
                if (!T) return this.fire(new c.k(new Error(`The layer '${v}' does not exist in the map's style and cannot be queried for features.`))), [];
                o[T.source] = !0;
              }
            }
            const u = [];
            i.availableImages = this._availableImages;
            const f = this._serializedAllLayers(), _ = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null, y = Object.assign(Object.assign({}, i), { layers: _ });
            for (const v in this.sourceCaches) i.layers && !o[v] || u.push(os(this.sourceCaches[v], this._layers, f, e, y, a));
            return this.placement && u.push(function(v, T, S, M, k, R, V) {
              const j = {}, N = R.queryRenderedSymbols(M), G = [];
              for (const W of Object.keys(N).map(Number)) G.push(V[W]);
              G.sort(ci);
              for (const W of G) {
                const H = W.featureIndex.lookupSymbolFeatures(N[W.bucketInstanceId], T, W.bucketIndex, W.sourceLayerIndex, k.filter, k.layers, k.availableImages, v);
                for (const K in H) {
                  const Q = j[K] = j[K] || [], J = H[K];
                  J.sort((se, oe) => {
                    const fe = W.featureSortOrder;
                    if (fe) {
                      const _e = fe.indexOf(se.featureIndex);
                      return fe.indexOf(oe.featureIndex) - _e;
                    }
                    return oe.featureIndex - se.featureIndex;
                  });
                  for (const se of J) Q.push(se);
                }
              }
              return function(W, H, K) {
                for (const Q in W) for (const J of W[Q]) Vt(J, K[H[Q].source]);
                return W;
              }(j, v, S);
            }(this._layers, f, this.sourceCaches, e, y, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(u);
          }
          querySourceFeatures(e, i) {
            i && i.filter && this._validate(c.y.filter, "querySourceFeatures.filter", i.filter, null, i);
            const a = this.sourceCaches[e];
            return a ? function(o, u) {
              const f = o.getRenderableIds().map((v) => o.getTileByID(v)), _ = [], y = {};
              for (let v = 0; v < f.length; v++) {
                const T = f[v], S = T.tileID.canonical.key;
                y[S] || (y[S] = !0, T.querySourceFeatures(_, u));
              }
              return _;
            }(a, i) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, i = {}) {
            this._checkLoaded();
            const a = this.light.getLight();
            let o = !1;
            for (const f in e) if (!c.bB(e[f], a[f])) {
              o = !0;
              break;
            }
            if (!o) return;
            const u = { now: He.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, i), this.light.updateTransitions(u);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, i = {}) {
            this._checkLoaded();
            const a = this.getSky();
            let o = !1;
            if (!e && !a) return;
            if (e && !a) o = !0;
            else if (!e && a) o = !0;
            else for (const f in e) if (!c.bB(e[f], a[f])) {
              o = !0;
              break;
            }
            if (!o) return;
            const u = { now: He.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(u);
          }
          _setProjectionInternal(e) {
            const i = function(a) {
              if (Array.isArray(a)) {
                const o = new Us({ type: a });
                return { projection: o, transform: new Hs(), cameraHelper: new Xs(o) };
              }
              switch (a) {
                case "mercator":
                  return { projection: new Ya(), transform: new Fi(), cameraHelper: new Ji() };
                case "globe": {
                  const o = new Us({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: o, transform: new Hs(), cameraHelper: new Xs(o) };
                }
                case "vertical-perspective":
                  return { projection: new jn(), transform: new Ws(), cameraHelper: new vi() };
                default:
                  return c.w(`Unknown projection name: ${a}. Falling back to mercator projection.`), { projection: new Ya(), transform: new Fi(), cameraHelper: new Ji() };
              }
            }(e);
            this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper);
            for (const a in this.sourceCaches) this.sourceCaches[a].reload();
          }
          _validate(e, i, a, o, u = {}) {
            return (!u || u.validate !== !1) && hn(this, e.call(c.y, c.e({ key: i, style: this.serialize(), value: a, styleSpec: c.v }, o)));
          }
          _remove(e = !0) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), gr().off(zn, this._rtlPluginLoaded);
            for (const i in this._layers) this._layers[i].setEventedParent(null);
            for (const i in this.sourceCaches) {
              const a = this.sourceCaches[i];
              a.setEventedParent(null), a.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const i in this.sourceCaches) this.sourceCaches[i].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, i, a, o, u = !1) {
            let f = !1, _ = !1;
            const y = {};
            for (const v of this._order) {
              const T = this._layers[v];
              if (T.type !== "symbol") continue;
              if (!y[T.source]) {
                const M = this.sourceCaches[T.source];
                y[T.source] = M.getRenderableIds(!0).map((k) => M.getTileByID(k)).sort((k, R) => R.tileID.overscaledZ - k.tileID.overscaledZ || (k.tileID.isLessThan(R.tileID) ? -1 : 1));
              }
              const S = this.crossTileSymbolIndex.addLayer(T, y[T.source], e.center.lng);
              f = f || S;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((u = u || this._layerOrderChanged || a === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(He.now(), e.zoom)) && (this.pauseablePlacement = new Ha(e, this.map.terrain, this._order, u, i, a, o, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, y), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(He.now()), _ = !0), f && this.pauseablePlacement.placement.setStale()), _ || f) for (const v of this._order) {
              const T = this._layers[v];
              T.type === "symbol" && this.placement.updateLayerOpacities(T, y[T.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(He.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, i) {
            return c._(this, void 0, void 0, function* () {
              const a = yield this.imageManager.getImages(i.icons);
              this._updateTilesForChangedImages();
              const o = this.sourceCaches[i.source];
              return o && o.setDependencies(i.tileID.key, i.type, i.icons), a;
            });
          }
          getGlyphs(e, i) {
            return c._(this, void 0, void 0, function* () {
              const a = yield this.glyphManager.getGlyphs(i.stacks), o = this.sourceCaches[i.source];
              return o && o.setDependencies(i.tileID.key, i.type, [""]), a;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, i = {}) {
            this._checkLoaded(), e && this._validate(c.y.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, i, a = {}, o) {
            this._checkLoaded();
            const u = [{ id: e, url: i }], f = [...Mt(this.stylesheet.sprite), ...u];
            this._validate(c.y.sprite, "sprite", f, null, a) || (this.stylesheet.sprite = f, this._loadSprite(u, !0, o));
          }
          removeSprite(e) {
            this._checkLoaded();
            const i = Mt(this.stylesheet.sprite);
            if (i.find((a) => a.id === e)) {
              if (this._spritesImagesIds[e]) for (const a of this._spritesImagesIds[e]) this.imageManager.removeImage(a), this._changedImages[a] = !0;
              i.splice(i.findIndex((a) => a.id === e), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" }));
            } else this.fire(new c.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return Mt(this.stylesheet.sprite);
          }
          setSprite(e, i = {}, a) {
            this._checkLoaded(), e && this._validate(c.y.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, a) : (this._unloadSprite(), a && a(null)));
          }
        }
        var or = c.aC([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class kc {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, i, a, o, u, f, _, y, v) {
            this.context = e;
            let T = this.boundPaintVertexBuffers.length !== o.length;
            for (let S = 0; !T && S < o.length; S++) this.boundPaintVertexBuffers[S] !== o[S] && (T = !0);
            !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== a || T || this.boundIndexBuffer !== u || this.boundVertexOffset !== f || this.boundDynamicVertexBuffer !== _ || this.boundDynamicVertexBuffer2 !== y || this.boundDynamicVertexBuffer3 !== v ? this.freshBind(i, a, o, u, f, _, y, v) : (e.bindVertexArray.set(this.vao), _ && _.bind(), u && u.dynamicDraw && u.bind(), y && y.bind(), v && v.bind());
          }
          freshBind(e, i, a, o, u, f, _, y) {
            const v = e.numAttributes, T = this.context, S = T.gl;
            this.vao && this.destroy(), this.vao = T.createVertexArray(), T.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = a, this.boundIndexBuffer = o, this.boundVertexOffset = u, this.boundDynamicVertexBuffer = f, this.boundDynamicVertexBuffer2 = _, this.boundDynamicVertexBuffer3 = y, i.enableAttributes(S, e);
            for (const M of a) M.enableAttributes(S, e);
            f && f.enableAttributes(S, e), _ && _.enableAttributes(S, e), y && y.enableAttributes(S, e), i.bind(), i.setVertexAttribPointers(S, e, u);
            for (const M of a) M.bind(), M.setVertexAttribPointers(S, e, u);
            f && (f.bind(), f.setVertexAttribPointers(S, e, u)), o && o.bind(), _ && (_.bind(), _.setVertexAttribPointers(S, e, u)), y && (y.bind(), y.setVertexAttribPointers(S, e, u)), T.currentNumAttributes = v;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const so = (h, e, i, a, o) => ({ u_texture: 0, u_ele_delta: h, u_fog_matrix: e, u_fog_color: i ? i.properties.get("fog-color") : c.b6.white, u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: o ? 0 : i ? i.calculateFogBlendOpacity(a) : 0, u_horizon_color: i ? i.properties.get("horizon-color") : c.b6.white, u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: o ? 1 : 0 }), gs = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function Or(h) {
          const e = [];
          for (let i = 0; i < h.length; i++) {
            if (h[i] === null) continue;
            const a = h[i].split(" ");
            e.push(a.pop());
          }
          return e;
        }
        class Dc {
          constructor(e, i, a, o, u, f, _, y) {
            const v = e.gl;
            this.program = v.createProgram();
            const T = Or(i.staticAttributes), S = a ? a.getBinderAttributes() : [], M = T.concat(S), k = Xi.prelude.staticUniforms ? Or(Xi.prelude.staticUniforms) : [], R = _.staticUniforms ? Or(_.staticUniforms) : [], V = i.staticUniforms ? Or(i.staticUniforms) : [], j = a ? a.getBinderUniforms() : [], N = k.concat(R).concat(V).concat(j), G = [];
            for (const oe of N) G.indexOf(oe) < 0 && G.push(oe);
            const W = a ? a.defines() : [];
            ji(v) && W.unshift("#version 300 es"), u && W.push("#define OVERDRAW_INSPECTOR;"), f && W.push("#define TERRAIN3D;"), y && W.push(y);
            let H = W.concat(Xi.prelude.fragmentSource, _.fragmentSource, i.fragmentSource).join(`
`), K = W.concat(Xi.prelude.vertexSource, _.vertexSource, i.vertexSource).join(`
`);
            ji(v) || (H = function(oe) {
              return oe.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }(H), K = function(oe) {
              return oe.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(K));
            const Q = v.createShader(v.FRAGMENT_SHADER);
            if (v.isContextLost()) return void (this.failedToCreate = !0);
            if (v.shaderSource(Q, H), v.compileShader(Q), !v.getShaderParameter(Q, v.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${v.getShaderInfoLog(Q)}`);
            v.attachShader(this.program, Q);
            const J = v.createShader(v.VERTEX_SHADER);
            if (v.isContextLost()) return void (this.failedToCreate = !0);
            if (v.shaderSource(J, K), v.compileShader(J), !v.getShaderParameter(J, v.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${v.getShaderInfoLog(J)}`);
            v.attachShader(this.program, J), this.attributes = {};
            const se = {};
            this.numAttributes = M.length;
            for (let oe = 0; oe < this.numAttributes; oe++) M[oe] && (v.bindAttribLocation(this.program, oe, M[oe]), this.attributes[M[oe]] = oe);
            if (v.linkProgram(this.program), !v.getProgramParameter(this.program, v.LINK_STATUS)) throw new Error(`Program failed to link: ${v.getProgramInfoLog(this.program)}`);
            v.deleteShader(J), v.deleteShader(Q);
            for (let oe = 0; oe < G.length; oe++) {
              const fe = G[oe];
              if (fe && !se[fe]) {
                const _e = v.getUniformLocation(this.program, fe);
                _e && (se[fe] = _e);
              }
            }
            this.fixedUniforms = o(e, se), this.terrainUniforms = ((oe, fe) => ({ u_depth: new c.bE(oe, fe.u_depth), u_terrain: new c.bE(oe, fe.u_terrain), u_terrain_dim: new c.b7(oe, fe.u_terrain_dim), u_terrain_matrix: new c.bG(oe, fe.u_terrain_matrix), u_terrain_unpack: new c.bH(oe, fe.u_terrain_unpack), u_terrain_exaggeration: new c.b7(oe, fe.u_terrain_exaggeration) }))(e, se), this.projectionUniforms = ((oe, fe) => ({ u_projection_matrix: new c.bG(oe, fe.u_projection_matrix), u_projection_tile_mercator_coords: new c.bH(oe, fe.u_projection_tile_mercator_coords), u_projection_clipping_plane: new c.bH(oe, fe.u_projection_clipping_plane), u_projection_transition: new c.b7(oe, fe.u_projection_transition), u_projection_fallback_matrix: new c.bG(oe, fe.u_projection_fallback_matrix) }))(e, se), this.binderUniforms = a ? a.getUniforms(e, se) : [];
          }
          draw(e, i, a, o, u, f, _, y, v, T, S, M, k, R, V, j, N, G, W) {
            const H = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(a), e.setStencilMode(o), e.setColorMode(u), e.setCullFace(f), y) {
              e.activeTexture.set(H.TEXTURE2), H.bindTexture(H.TEXTURE_2D, y.depthTexture), e.activeTexture.set(H.TEXTURE3), H.bindTexture(H.TEXTURE_2D, y.texture);
              for (const Q in this.terrainUniforms) this.terrainUniforms[Q].set(y[Q]);
            }
            if (v) for (const Q in v) this.projectionUniforms[gs[Q]].set(v[Q]);
            if (_) for (const Q in this.fixedUniforms) this.fixedUniforms[Q].set(_[Q]);
            j && j.setUniforms(e, this.binderUniforms, R, { zoom: V });
            let K = 0;
            switch (i) {
              case H.LINES:
                K = 2;
                break;
              case H.TRIANGLES:
                K = 3;
                break;
              case H.LINE_STRIP:
                K = 1;
            }
            for (const Q of k.get()) {
              const J = Q.vaos || (Q.vaos = {});
              (J[T] || (J[T] = new kc())).bind(e, this, S, j ? j.getPaintVertexBuffers() : [], M, Q.vertexOffset, N, G, W), H.drawElements(i, Q.primitiveLength * K, H.UNSIGNED_SHORT, Q.primitiveOffset * K * 2);
            }
          }
        }
        function ys(h, e, i) {
          const a = 1 / c.av(i, 1, e.transform.tileZoom), o = Math.pow(2, i.tileID.overscaledZ), u = i.tileSize * Math.pow(2, e.transform.tileZoom) / o, f = u * (i.tileID.canonical.x + i.tileID.wrap * o), _ = u * i.tileID.canonical.y;
          return { u_image: 0, u_texsize: i.imageAtlasTexture.size, u_scale: [a, h.fromScale, h.toScale], u_fade: h.t, u_pixel_coord_upper: [f >> 16, _ >> 16], u_pixel_coord_lower: [65535 & f, 65535 & _] };
        }
        const _l = (h, e, i, a) => {
          const o = h.style.light, u = o.properties.get("position"), f = [u.x, u.y, u.z], _ = c.bK();
          o.properties.get("anchor") === "viewport" && c.bL(_, h.transform.bearingInRadians), c.bM(f, f, _);
          const y = h.transform.transformLightDirection(f), v = o.properties.get("color");
          return { u_lightpos: f, u_lightpos_globe: y, u_lightintensity: o.properties.get("intensity"), u_lightcolor: [v.r, v.g, v.b], u_vertical_gradient: +e, u_opacity: i, u_fill_translate: a };
        }, Vn = (h, e, i, a, o, u, f) => c.e(_l(h, e, i, a), ys(u, h, f), { u_height_factor: -Math.pow(2, o.overscaledZ) / f.tileSize / 8 }), gl = (h, e, i, a) => c.e(ys(e, h, i), { u_fill_translate: a }), yl = (h, e) => ({ u_world: h, u_fill_translate: e }), Rc = (h, e, i, a, o) => c.e(gl(h, e, i, o), { u_world: a }), xl = (h, e, i, a, o) => {
          const u = h.transform;
          let f, _, y = 0;
          if (i.paint.get("circle-pitch-alignment") === "map") {
            const v = c.av(e, 1, u.zoom);
            f = !0, _ = [v, v], y = v / (c.Z * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * o;
          } else f = !1, _ = u.pixelsToGLUnits;
          return { u_camera_to_center_distance: u.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +f, u_device_pixel_ratio: h.pixelRatio, u_extrude_scale: _, u_globe_extrude_scale: y, u_translate: a };
        }, ao = (h) => ({ u_pixel_extrude_scale: [1 / h.width, 1 / h.height] }), vl = (h) => ({ u_viewport_size: [h.width, h.height] }), oo = (h, e = 1) => ({ u_color: h, u_overlay: 0, u_overlay_scale: e }), lo = (h, e, i, a) => {
          const o = c.av(h, 1, e) / (c.Z * Math.pow(2, h.tileID.overscaledZ)) * 2 * Math.PI * a;
          return { u_extrude_scale: c.av(h, 1, e), u_intensity: i, u_globe_extrude_scale: o };
        }, co = (h, e, i, a) => {
          const o = c.K();
          c.bN(o, 0, h.width, h.height, 0, 0, 1);
          const u = h.context.gl;
          return { u_matrix: o, u_world: [u.drawingBufferWidth, u.drawingBufferHeight], u_image: i, u_color_ramp: a, u_opacity: e.paint.get("heatmap-opacity") };
        }, un = (h, e, i) => {
          const a = i.paint.get("hillshade-shadow-color"), o = i.paint.get("hillshade-highlight-color"), u = i.paint.get("hillshade-accent-color");
          let f = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          return i.paint.get("hillshade-illumination-anchor") === "viewport" && (f += h.transform.bearingInRadians), { u_image: 0, u_latrange: wl(0, e.tileID), u_light: [i.paint.get("hillshade-exaggeration"), f], u_shadow: a, u_highlight: o, u_accent: u };
        }, bl = (h, e) => {
          const i = e.stride, a = c.K();
          return c.bN(a, 0, c.Z, -8192, 0, 0, 1), c.L(a, a, [0, -8192, 0]), { u_matrix: a, u_image: 1, u_dimension: [i, i], u_zoom: h.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function wl(h, e) {
          const i = Math.pow(2, e.canonical.z), a = e.canonical.y;
          return [new c.$(0, a / i).toLngLat().lat, new c.$(0, (a + 1) / i).toLngLat().lat];
        }
        const dn = (h, e, i, a) => {
          const o = h.transform;
          return { u_translation: ho(h, e, i), u_ratio: a / c.av(e, 1, o.zoom), u_device_pixel_ratio: h.pixelRatio, u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]] };
        }, Lc = (h, e, i, a, o) => c.e(dn(h, e, i, a), { u_image: 0, u_image_height: o }), Ks = (h, e, i, a, o) => {
          const u = h.transform, f = Tl(e, u);
          return { u_translation: ho(h, e, i), u_texsize: e.imageAtlasTexture.size, u_ratio: a / c.av(e, 1, u.zoom), u_device_pixel_ratio: h.pixelRatio, u_image: 0, u_scale: [f, o.fromScale, o.toScale], u_fade: o.t, u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]] };
        }, Bc = (h, e, i, a, o, u) => {
          const f = h.lineAtlas, _ = Tl(e, h.transform), y = i.layout.get("line-cap") === "round", v = f.getDash(o.from, y), T = f.getDash(o.to, y), S = v.width * u.fromScale, M = T.width * u.toScale;
          return c.e(dn(h, e, i, a), { u_patternscale_a: [_ / S, -v.height / 2], u_patternscale_b: [_ / M, -T.height / 2], u_sdfgamma: f.width / (256 * Math.min(S, M) * h.pixelRatio) / 2, u_image: 0, u_tex_y_a: v.y, u_tex_y_b: T.y, u_mix: u.t });
        };
        function Tl(h, e) {
          return 1 / c.av(h, 1, e.tileZoom);
        }
        function ho(h, e, i) {
          return c.aw(h.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }
        const Pl = (h, e, i, a, o) => {
          return { u_tl_parent: h, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * a.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a.paint.get("raster-brightness-min"), u_brightness_high: a.paint.get("raster-brightness-max"), u_saturation_factor: (f = a.paint.get("raster-saturation"), f > 0 ? 1 - 1 / (1.001 - f) : -f), u_contrast_factor: (u = a.paint.get("raster-contrast"), u > 0 ? 1 / (1 - u) : 1 + u), u_spin_weights: Sl(a.paint.get("raster-hue-rotate")), u_coords_top: [o[0].x, o[0].y, o[1].x, o[1].y], u_coords_bottom: [o[3].x, o[3].y, o[2].x, o[2].y] };
          var u, f;
        };
        function Sl(h) {
          h *= Math.PI / 180;
          const e = Math.sin(h), i = Math.cos(h);
          return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];
        }
        const Js = (h, e, i, a, o, u, f, _, y, v, T, S, M) => {
          const k = f.transform;
          return { u_is_size_zoom_constant: +(h === "constant" || h === "source"), u_is_size_feature_constant: +(h === "constant" || h === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: k.cameraToCenterDistance, u_pitch: k.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i, u_aspect_ratio: k.width / k.height, u_fade_change: f.options.fadeDuration ? f.symbolFadeChange : 1, u_label_plane_matrix: _, u_coord_matrix: y, u_is_text: +T, u_pitch_with_map: +a, u_is_along_line: o, u_is_variable_anchor: u, u_texsize: S, u_texture: 0, u_translation: v, u_pitched_scale: M };
        }, uo = (h, e, i, a, o, u, f, _, y, v, T, S, M, k) => {
          const R = f.transform;
          return c.e(Js(h, e, i, a, o, u, f, _, y, v, T, S, k), { u_gamma_scale: a ? Math.cos(R.pitch * Math.PI / 180) * R.cameraToCenterDistance : 1, u_device_pixel_ratio: f.pixelRatio, u_is_halo: 1 });
        }, Ys = (h, e, i, a, o, u, f, _, y, v, T, S, M) => c.e(uo(h, e, i, a, o, u, f, _, y, v, !0, T, 0, M), { u_texsize_icon: S, u_texture_icon: 1 }), xr = (h, e) => ({ u_opacity: h, u_color: e }), po = (h, e, i, a, o) => c.e(function(u, f, _, y) {
          const v = _.imageManager.getPattern(u.from.toString()), T = _.imageManager.getPattern(u.to.toString()), { width: S, height: M } = _.imageManager.getPixelSize(), k = Math.pow(2, y.tileID.overscaledZ), R = y.tileSize * Math.pow(2, _.transform.tileZoom) / k, V = R * (y.tileID.canonical.x + y.tileID.wrap * k), j = R * y.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: v.tl, u_pattern_br_a: v.br, u_pattern_tl_b: T.tl, u_pattern_br_b: T.br, u_texsize: [S, M], u_mix: f.t, u_pattern_size_a: v.displaySize, u_pattern_size_b: T.displaySize, u_scale_a: f.fromScale, u_scale_b: f.toScale, u_tile_units_to_pixels: 1 / c.av(y, 1, _.transform.tileZoom), u_pixel_coord_upper: [V >> 16, j >> 16], u_pixel_coord_lower: [65535 & V, 65535 & j] };
        }(i, o, e, a), { u_opacity: h }), Qs = (h, e) => {
        }, fo = { fillExtrusion: (h, e) => ({ u_lightpos: new c.bI(h, e.u_lightpos), u_lightpos_globe: new c.bI(h, e.u_lightpos_globe), u_lightintensity: new c.b7(h, e.u_lightintensity), u_lightcolor: new c.bI(h, e.u_lightcolor), u_vertical_gradient: new c.b7(h, e.u_vertical_gradient), u_opacity: new c.b7(h, e.u_opacity), u_fill_translate: new c.bJ(h, e.u_fill_translate) }), fillExtrusionPattern: (h, e) => ({ u_lightpos: new c.bI(h, e.u_lightpos), u_lightpos_globe: new c.bI(h, e.u_lightpos_globe), u_lightintensity: new c.b7(h, e.u_lightintensity), u_lightcolor: new c.bI(h, e.u_lightcolor), u_vertical_gradient: new c.b7(h, e.u_vertical_gradient), u_height_factor: new c.b7(h, e.u_height_factor), u_opacity: new c.b7(h, e.u_opacity), u_fill_translate: new c.bJ(h, e.u_fill_translate), u_image: new c.bE(h, e.u_image), u_texsize: new c.bJ(h, e.u_texsize), u_pixel_coord_upper: new c.bJ(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(h, e.u_pixel_coord_lower), u_scale: new c.bI(h, e.u_scale), u_fade: new c.b7(h, e.u_fade) }), fill: (h, e) => ({ u_fill_translate: new c.bJ(h, e.u_fill_translate) }), fillPattern: (h, e) => ({ u_image: new c.bE(h, e.u_image), u_texsize: new c.bJ(h, e.u_texsize), u_pixel_coord_upper: new c.bJ(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(h, e.u_pixel_coord_lower), u_scale: new c.bI(h, e.u_scale), u_fade: new c.b7(h, e.u_fade), u_fill_translate: new c.bJ(h, e.u_fill_translate) }), fillOutline: (h, e) => ({ u_world: new c.bJ(h, e.u_world), u_fill_translate: new c.bJ(h, e.u_fill_translate) }), fillOutlinePattern: (h, e) => ({ u_world: new c.bJ(h, e.u_world), u_image: new c.bE(h, e.u_image), u_texsize: new c.bJ(h, e.u_texsize), u_pixel_coord_upper: new c.bJ(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(h, e.u_pixel_coord_lower), u_scale: new c.bI(h, e.u_scale), u_fade: new c.b7(h, e.u_fade), u_fill_translate: new c.bJ(h, e.u_fill_translate) }), circle: (h, e) => ({ u_camera_to_center_distance: new c.b7(h, e.u_camera_to_center_distance), u_scale_with_map: new c.bE(h, e.u_scale_with_map), u_pitch_with_map: new c.bE(h, e.u_pitch_with_map), u_extrude_scale: new c.bJ(h, e.u_extrude_scale), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_globe_extrude_scale: new c.b7(h, e.u_globe_extrude_scale), u_translate: new c.bJ(h, e.u_translate) }), collisionBox: (h, e) => ({ u_pixel_extrude_scale: new c.bJ(h, e.u_pixel_extrude_scale) }), collisionCircle: (h, e) => ({ u_viewport_size: new c.bJ(h, e.u_viewport_size) }), debug: (h, e) => ({ u_color: new c.bF(h, e.u_color), u_overlay: new c.bE(h, e.u_overlay), u_overlay_scale: new c.b7(h, e.u_overlay_scale) }), depth: Qs, clippingMask: Qs, heatmap: (h, e) => ({ u_extrude_scale: new c.b7(h, e.u_extrude_scale), u_intensity: new c.b7(h, e.u_intensity), u_globe_extrude_scale: new c.b7(h, e.u_globe_extrude_scale) }), heatmapTexture: (h, e) => ({ u_matrix: new c.bG(h, e.u_matrix), u_world: new c.bJ(h, e.u_world), u_image: new c.bE(h, e.u_image), u_color_ramp: new c.bE(h, e.u_color_ramp), u_opacity: new c.b7(h, e.u_opacity) }), hillshade: (h, e) => ({ u_image: new c.bE(h, e.u_image), u_latrange: new c.bJ(h, e.u_latrange), u_light: new c.bJ(h, e.u_light), u_shadow: new c.bF(h, e.u_shadow), u_highlight: new c.bF(h, e.u_highlight), u_accent: new c.bF(h, e.u_accent) }), hillshadePrepare: (h, e) => ({ u_matrix: new c.bG(h, e.u_matrix), u_image: new c.bE(h, e.u_image), u_dimension: new c.bJ(h, e.u_dimension), u_zoom: new c.b7(h, e.u_zoom), u_unpack: new c.bH(h, e.u_unpack) }), line: (h, e) => ({ u_translation: new c.bJ(h, e.u_translation), u_ratio: new c.b7(h, e.u_ratio), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(h, e.u_units_to_pixels) }), lineGradient: (h, e) => ({ u_translation: new c.bJ(h, e.u_translation), u_ratio: new c.b7(h, e.u_ratio), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(h, e.u_units_to_pixels), u_image: new c.bE(h, e.u_image), u_image_height: new c.b7(h, e.u_image_height) }), linePattern: (h, e) => ({ u_translation: new c.bJ(h, e.u_translation), u_texsize: new c.bJ(h, e.u_texsize), u_ratio: new c.b7(h, e.u_ratio), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_image: new c.bE(h, e.u_image), u_units_to_pixels: new c.bJ(h, e.u_units_to_pixels), u_scale: new c.bI(h, e.u_scale), u_fade: new c.b7(h, e.u_fade) }), lineSDF: (h, e) => ({ u_translation: new c.bJ(h, e.u_translation), u_ratio: new c.b7(h, e.u_ratio), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(h, e.u_units_to_pixels), u_patternscale_a: new c.bJ(h, e.u_patternscale_a), u_patternscale_b: new c.bJ(h, e.u_patternscale_b), u_sdfgamma: new c.b7(h, e.u_sdfgamma), u_image: new c.bE(h, e.u_image), u_tex_y_a: new c.b7(h, e.u_tex_y_a), u_tex_y_b: new c.b7(h, e.u_tex_y_b), u_mix: new c.b7(h, e.u_mix) }), raster: (h, e) => ({ u_tl_parent: new c.bJ(h, e.u_tl_parent), u_scale_parent: new c.b7(h, e.u_scale_parent), u_buffer_scale: new c.b7(h, e.u_buffer_scale), u_fade_t: new c.b7(h, e.u_fade_t), u_opacity: new c.b7(h, e.u_opacity), u_image0: new c.bE(h, e.u_image0), u_image1: new c.bE(h, e.u_image1), u_brightness_low: new c.b7(h, e.u_brightness_low), u_brightness_high: new c.b7(h, e.u_brightness_high), u_saturation_factor: new c.b7(h, e.u_saturation_factor), u_contrast_factor: new c.b7(h, e.u_contrast_factor), u_spin_weights: new c.bI(h, e.u_spin_weights), u_coords_top: new c.bH(h, e.u_coords_top), u_coords_bottom: new c.bH(h, e.u_coords_bottom) }), symbolIcon: (h, e) => ({ u_is_size_zoom_constant: new c.bE(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(h, e.u_is_size_feature_constant), u_size_t: new c.b7(h, e.u_size_t), u_size: new c.b7(h, e.u_size), u_camera_to_center_distance: new c.b7(h, e.u_camera_to_center_distance), u_pitch: new c.b7(h, e.u_pitch), u_rotate_symbol: new c.bE(h, e.u_rotate_symbol), u_aspect_ratio: new c.b7(h, e.u_aspect_ratio), u_fade_change: new c.b7(h, e.u_fade_change), u_label_plane_matrix: new c.bG(h, e.u_label_plane_matrix), u_coord_matrix: new c.bG(h, e.u_coord_matrix), u_is_text: new c.bE(h, e.u_is_text), u_pitch_with_map: new c.bE(h, e.u_pitch_with_map), u_is_along_line: new c.bE(h, e.u_is_along_line), u_is_variable_anchor: new c.bE(h, e.u_is_variable_anchor), u_texsize: new c.bJ(h, e.u_texsize), u_texture: new c.bE(h, e.u_texture), u_translation: new c.bJ(h, e.u_translation), u_pitched_scale: new c.b7(h, e.u_pitched_scale) }), symbolSDF: (h, e) => ({ u_is_size_zoom_constant: new c.bE(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(h, e.u_is_size_feature_constant), u_size_t: new c.b7(h, e.u_size_t), u_size: new c.b7(h, e.u_size), u_camera_to_center_distance: new c.b7(h, e.u_camera_to_center_distance), u_pitch: new c.b7(h, e.u_pitch), u_rotate_symbol: new c.bE(h, e.u_rotate_symbol), u_aspect_ratio: new c.b7(h, e.u_aspect_ratio), u_fade_change: new c.b7(h, e.u_fade_change), u_label_plane_matrix: new c.bG(h, e.u_label_plane_matrix), u_coord_matrix: new c.bG(h, e.u_coord_matrix), u_is_text: new c.bE(h, e.u_is_text), u_pitch_with_map: new c.bE(h, e.u_pitch_with_map), u_is_along_line: new c.bE(h, e.u_is_along_line), u_is_variable_anchor: new c.bE(h, e.u_is_variable_anchor), u_texsize: new c.bJ(h, e.u_texsize), u_texture: new c.bE(h, e.u_texture), u_gamma_scale: new c.b7(h, e.u_gamma_scale), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_is_halo: new c.bE(h, e.u_is_halo), u_translation: new c.bJ(h, e.u_translation), u_pitched_scale: new c.b7(h, e.u_pitched_scale) }), symbolTextAndIcon: (h, e) => ({ u_is_size_zoom_constant: new c.bE(h, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(h, e.u_is_size_feature_constant), u_size_t: new c.b7(h, e.u_size_t), u_size: new c.b7(h, e.u_size), u_camera_to_center_distance: new c.b7(h, e.u_camera_to_center_distance), u_pitch: new c.b7(h, e.u_pitch), u_rotate_symbol: new c.bE(h, e.u_rotate_symbol), u_aspect_ratio: new c.b7(h, e.u_aspect_ratio), u_fade_change: new c.b7(h, e.u_fade_change), u_label_plane_matrix: new c.bG(h, e.u_label_plane_matrix), u_coord_matrix: new c.bG(h, e.u_coord_matrix), u_is_text: new c.bE(h, e.u_is_text), u_pitch_with_map: new c.bE(h, e.u_pitch_with_map), u_is_along_line: new c.bE(h, e.u_is_along_line), u_is_variable_anchor: new c.bE(h, e.u_is_variable_anchor), u_texsize: new c.bJ(h, e.u_texsize), u_texsize_icon: new c.bJ(h, e.u_texsize_icon), u_texture: new c.bE(h, e.u_texture), u_texture_icon: new c.bE(h, e.u_texture_icon), u_gamma_scale: new c.b7(h, e.u_gamma_scale), u_device_pixel_ratio: new c.b7(h, e.u_device_pixel_ratio), u_is_halo: new c.bE(h, e.u_is_halo), u_translation: new c.bJ(h, e.u_translation), u_pitched_scale: new c.b7(h, e.u_pitched_scale) }), background: (h, e) => ({ u_opacity: new c.b7(h, e.u_opacity), u_color: new c.bF(h, e.u_color) }), backgroundPattern: (h, e) => ({ u_opacity: new c.b7(h, e.u_opacity), u_image: new c.bE(h, e.u_image), u_pattern_tl_a: new c.bJ(h, e.u_pattern_tl_a), u_pattern_br_a: new c.bJ(h, e.u_pattern_br_a), u_pattern_tl_b: new c.bJ(h, e.u_pattern_tl_b), u_pattern_br_b: new c.bJ(h, e.u_pattern_br_b), u_texsize: new c.bJ(h, e.u_texsize), u_mix: new c.b7(h, e.u_mix), u_pattern_size_a: new c.bJ(h, e.u_pattern_size_a), u_pattern_size_b: new c.bJ(h, e.u_pattern_size_b), u_scale_a: new c.b7(h, e.u_scale_a), u_scale_b: new c.b7(h, e.u_scale_b), u_pixel_coord_upper: new c.bJ(h, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(h, e.u_pixel_coord_lower), u_tile_units_to_pixels: new c.b7(h, e.u_tile_units_to_pixels) }), terrain: (h, e) => ({ u_texture: new c.bE(h, e.u_texture), u_ele_delta: new c.b7(h, e.u_ele_delta), u_fog_matrix: new c.bG(h, e.u_fog_matrix), u_fog_color: new c.bF(h, e.u_fog_color), u_fog_ground_blend: new c.b7(h, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.b7(h, e.u_fog_ground_blend_opacity), u_horizon_color: new c.bF(h, e.u_horizon_color), u_horizon_fog_blend: new c.b7(h, e.u_horizon_fog_blend), u_is_globe_mode: new c.b7(h, e.u_is_globe_mode) }), terrainDepth: (h, e) => ({ u_ele_delta: new c.b7(h, e.u_ele_delta) }), terrainCoords: (h, e) => ({ u_texture: new c.bE(h, e.u_texture), u_terrain_coords_id: new c.b7(h, e.u_terrain_coords_id), u_ele_delta: new c.b7(h, e.u_ele_delta) }), projectionErrorMeasurement: (h, e) => ({ u_input: new c.b7(h, e.u_input), u_output_expected: new c.b7(h, e.u_output_expected) }), atmosphere: (h, e) => ({ u_sun_pos: new c.bI(h, e.u_sun_pos), u_atmosphere_blend: new c.b7(h, e.u_atmosphere_blend), u_globe_position: new c.bI(h, e.u_globe_position), u_globe_radius: new c.b7(h, e.u_globe_radius), u_inv_proj_matrix: new c.bG(h, e.u_inv_proj_matrix) }), sky: (h, e) => ({ u_sky_color: new c.bF(h, e.u_sky_color), u_horizon_color: new c.bF(h, e.u_horizon_color), u_horizon: new c.bJ(h, e.u_horizon), u_horizon_normal: new c.bJ(h, e.u_horizon_normal), u_sky_horizon_blend: new c.b7(h, e.u_sky_horizon_blend), u_sky_blend: new c.b7(h, e.u_sky_blend) }) };
        class Ml {
          constructor(e, i, a) {
            this.context = e;
            const o = e.gl;
            this.buffer = o.createBuffer(), this.dynamicDraw = !!a, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const i = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const mo = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class pn {
          constructor(e, i, a, o) {
            this.length = i.length, this.attributes = a, this.itemSize = i.bytesPerElement, this.dynamicDraw = o, this.context = e;
            const u = e.gl;
            this.buffer = u.createBuffer(), e.bindVertexBuffer.set(this.buffer), u.bufferData(u.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const i = this.context.gl;
            this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, i) {
            for (let a = 0; a < this.attributes.length; a++) {
              const o = i.attributes[this.attributes[a].name];
              o !== void 0 && e.enableVertexAttribArray(o);
            }
          }
          setVertexAttribPointers(e, i, a) {
            for (let o = 0; o < this.attributes.length; o++) {
              const u = this.attributes[o], f = i.attributes[u.name];
              f !== void 0 && e.vertexAttribPointer(f, u.components, e[mo[u.type]], !1, this.itemSize, u.offset + this.itemSize * (a || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class ot {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Fc extends ot {
          getDefault() {
            return c.b6.transparent;
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Oc extends ot {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
          }
        }
        class jc extends ot {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
          }
        }
        class Vc extends ot {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class Il extends ot {
          getDefault() {
            return !0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
          }
        }
        class Nc extends ot {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
          }
        }
        class Cl extends ot {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const i = this.current;
            (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
          }
        }
        class ea extends ot {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
          }
        }
        class ta extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1;
          }
        }
        class ia extends ot {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class _o extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1;
          }
        }
        class fn extends ot {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
          }
        }
        class Nn extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1;
          }
        }
        class Vi extends ot {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
          }
        }
        class El extends ot {
          getDefault() {
            return c.b6.transparent;
          }
          set(e) {
            const i = this.current;
            (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
          }
        }
        class Al extends ot {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
          }
        }
        class go extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1;
          }
        }
        class mn extends ot {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
          }
        }
        class ra extends ot {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
          }
        }
        class na extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
          }
        }
        class xs extends ot {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
          }
        }
        class sa extends ot {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const i = this.current;
            (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
          }
        }
        class zl extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Zn extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Un extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1;
          }
        }
        class kl extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class yo extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            const i = this.gl;
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class at extends ot {
          getDefault() {
            return null;
          }
          set(e) {
            var i;
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            ji(a) ? a.bindVertexArray(e) : (i = a.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
          }
        }
        class aa extends ot {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
          }
        }
        class Zc extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class Dl extends ot {
          getDefault() {
            return !1;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const i = this.gl;
            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
          }
        }
        class _n extends ot {
          constructor(e, i) {
            super(e), this.context = e, this.parent = i;
          }
          getDefault() {
            return null;
          }
        }
        class Uc extends _n {
          setDirty() {
            this.dirty = !0;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
          }
        }
        class Gc extends _n {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        class Rl extends _n {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const i = this.gl;
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1;
          }
        }
        const Ll = "Framebuffer is not complete";
        class xo {
          constructor(e, i, a, o, u) {
            this.context = e, this.width = i, this.height = a;
            const f = e.gl, _ = this.framebuffer = f.createFramebuffer();
            if (this.colorAttachment = new Uc(e, _), o) this.depthAttachment = u ? new Rl(e, _) : new Gc(e, _);
            else if (u) throw new Error("Stencil cannot be set without depth");
            if (f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE) throw new Error(Ll);
          }
          destroy() {
            const e = this.context.gl, i = this.colorAttachment.get();
            if (i && e.deleteTexture(i), this.depthAttachment) {
              const a = this.depthAttachment.get();
              a && e.deleteRenderbuffer(a);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class oa {
          constructor(e) {
            var i, a;
            if (this.gl = e, this.clearColor = new Fc(this), this.clearDepth = new Oc(this), this.clearStencil = new jc(this), this.colorMask = new Vc(this), this.depthMask = new Il(this), this.stencilMask = new Nc(this), this.stencilFunc = new Cl(this), this.stencilOp = new ea(this), this.stencilTest = new ta(this), this.depthRange = new ia(this), this.depthTest = new _o(this), this.depthFunc = new fn(this), this.blend = new Nn(this), this.blendFunc = new Vi(this), this.blendColor = new El(this), this.blendEquation = new Al(this), this.cullFace = new go(this), this.cullFaceSide = new mn(this), this.frontFace = new ra(this), this.program = new na(this), this.activeTexture = new xs(this), this.viewport = new sa(this), this.bindFramebuffer = new zl(this), this.bindRenderbuffer = new Zn(this), this.bindTexture = new Un(this), this.bindVertexBuffer = new kl(this), this.bindElementBuffer = new yo(this), this.bindVertexArray = new at(this), this.pixelStoreUnpack = new aa(this), this.pixelStoreUnpackPremultiplyAlpha = new Zc(this), this.pixelStoreUnpackFlipY = new Dl(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), ji(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const o = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : o == null ? void 0 : o.RGBA16F_EXT, this.RGB16F = (a = e.RGB16F) !== null && a !== void 0 ? a : o == null ? void 0 : o.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const o = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = o == null ? void 0 : o.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(e, i) {
            return new Ml(this, e, i);
          }
          createVertexBuffer(e, i, a) {
            return new pn(this, e, i, a);
          }
          createRenderbuffer(e, i, a) {
            const o = this.gl, u = o.createRenderbuffer();
            return this.bindRenderbuffer.set(u), o.renderbufferStorage(o.RENDERBUFFER, e, i, a), this.bindRenderbuffer.set(null), u;
          }
          createFramebuffer(e, i, a, o) {
            return new xo(this, e, i, a, o);
          }
          clear({ color: e, depth: i, stencil: a }) {
            const o = this.gl;
            let u = 0;
            e && (u |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (u |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), a !== void 0 && (u |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(a), this.stencilMask.set(255)), o.clear(u);
          }
          setCullFace(e) {
            e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(e) {
            c.bB(e.blendFunction, wt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return ji(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var i;
            return ji(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let gn;
        function la(h, e, i, a, o) {
          const u = h.context, f = h.transform, _ = u.gl, y = h.useProgram("collisionBox"), v = [];
          let T = 0, S = 0;
          for (let N = 0; N < a.length; N++) {
            const G = a[N], W = e.getTile(G).getBucket(i);
            if (!W) continue;
            const H = o ? W.textCollisionBox : W.iconCollisionBox, K = W.collisionCircleArray;
            K.length > 0 && (v.push({ circleArray: K, circleOffset: S, coord: G }), T += K.length / 4, S = T), H && y.draw(u, _.LINES, Xe.disabled, rt.disabled, h.colorModeForRenderPass(), it.disabled, ao(h.transform), h.style.map.terrain && h.style.map.terrain.getTerrainData(G), f.getProjectionData({ overscaledTileID: G, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), i.id, H.layoutVertexBuffer, H.indexBuffer, H.segments, null, h.transform.zoom, null, null, H.collisionVertexBuffer);
          }
          if (!o || !v.length) return;
          const M = h.useProgram("collisionCircle"), k = new c.bO();
          k.resize(4 * T), k._trim();
          let R = 0;
          for (const N of v) for (let G = 0; G < N.circleArray.length / 4; G++) {
            const W = 4 * G, H = N.circleArray[W + 0], K = N.circleArray[W + 1], Q = N.circleArray[W + 2], J = N.circleArray[W + 3];
            k.emplace(R++, H, K, Q, J, 0), k.emplace(R++, H, K, Q, J, 1), k.emplace(R++, H, K, Q, J, 2), k.emplace(R++, H, K, Q, J, 3);
          }
          (!gn || gn.length < 2 * T) && (gn = function(N) {
            const G = 2 * N, W = new c.bQ();
            W.resize(G), W._trim();
            for (let H = 0; H < G; H++) {
              const K = 6 * H;
              W.uint16[K + 0] = 4 * H + 0, W.uint16[K + 1] = 4 * H + 1, W.uint16[K + 2] = 4 * H + 2, W.uint16[K + 3] = 4 * H + 2, W.uint16[K + 4] = 4 * H + 3, W.uint16[K + 5] = 4 * H + 0;
            }
            return W;
          }(T));
          const V = u.createIndexBuffer(gn, !0), j = u.createVertexBuffer(k, c.bP.members, !0);
          for (const N of v) {
            const G = vl(h.transform);
            M.draw(u, _.TRIANGLES, Xe.disabled, rt.disabled, h.colorModeForRenderPass(), it.disabled, G, h.style.map.terrain && h.style.map.terrain.getTerrainData(N.coord), null, i.id, j, V, c.aF.simpleSegment(0, 2 * N.circleOffset, N.circleArray.length, N.circleArray.length / 2), null, h.transform.zoom, null, null, null);
          }
          j.destroy(), V.destroy();
        }
        const vo = c.as(new Float32Array(16));
        function Bl(h, e, i, a, o, u) {
          const { horizontalAlign: f, verticalAlign: _ } = c.aA(h);
          return new c.P((-(f - 0.5) * e / o + a[0]) * u, (-(_ - 0.5) * i / o + a[1]) * u);
        }
        function ca(h, e, i, a, o, u) {
          const f = e.tileAnchorPoint.add(new c.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let _ = a.mult(u);
            i || (_ = _.rotate(-o));
            const y = f.add(_);
            return he(y.x, y.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (i) {
            const _ = De(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(h), y = Math.atan(_.y / _.x) + (_.x < 0 ? Math.PI : 0);
            return h.add(a.rotate(y));
          }
          return h.add(a);
        }
        function ha(h, e, i, a, o, u, f, _, y, v, T, S) {
          const M = h.text.placedSymbolArray, k = h.text.dynamicLayoutVertexArray, R = h.icon.dynamicLayoutVertexArray, V = {};
          k.clear();
          for (let j = 0; j < M.length; j++) {
            const N = M.get(j), G = N.hidden || !N.crossTileID || h.allowVerticalPlacement && !N.placedOrientation ? null : a[N.crossTileID];
            if (G) {
              const W = new c.P(N.anchorX, N.anchorY), H = { getElevation: S, width: o.width, height: o.height, pitchedLabelPlaneMatrix: u, pitchWithMap: i, transform: o, tileAnchorPoint: W, translation: v, unwrappedTileID: T }, K = i ? Ke(W.x, W.y, H) : De(W.x, W.y, H), Q = re(o.cameraToCenterDistance, K.signedDistanceFromCamera);
              let J = c.ah(h.textSizeData, _, N) * Q / c.au;
              i && (J *= h.tilePixelRatio / f);
              const { width: se, height: oe, anchor: fe, textOffset: _e, textBoxScale: pe } = G, Ie = Bl(fe, se, oe, _e, pe, J), Se = o.getPitchedTextCorrection(W.x + v[0], W.y + v[1], T), be = ca(K.point, H, e, Ie, -o.bearingInRadians, Se), Re = h.allowVerticalPlacement && N.placedOrientation === c.ag.vertical ? Math.PI / 2 : 0;
              for (let Oe = 0; Oe < N.numGlyphs; Oe++) c.an(k, be, Re);
              y && N.associatedIconIndex >= 0 && (V[N.associatedIconIndex] = { shiftedAnchor: be, angle: Re });
            } else Ft(N.numGlyphs, k);
          }
          if (y) {
            R.clear();
            const j = h.icon.placedSymbolArray;
            for (let N = 0; N < j.length; N++) {
              const G = j.get(N);
              if (G.hidden) Ft(G.numGlyphs, R);
              else {
                const W = V[N];
                if (W) for (let H = 0; H < G.numGlyphs; H++) c.an(R, W.shiftedAnchor, W.angle);
                else Ft(G.numGlyphs, R);
              }
            }
            h.icon.dynamicLayoutVertexBuffer.updateData(R);
          }
          h.text.dynamicLayoutVertexBuffer.updateData(k);
        }
        function bo(h, e, i) {
          return i.iconsInText && e ? "symbolTextAndIcon" : h ? "symbolSDF" : "symbolIcon";
        }
        function Fl(h, e, i, a, o, u, f, _, y, v, T, S, M) {
          const k = h.context, R = k.gl, V = h.transform, j = _ === "map", N = y === "map", G = _ !== "viewport" && i.layout.get("symbol-placement") !== "point", W = j && !N && !G, H = !i.layout.get("symbol-sort-key").isConstant();
          let K = !1;
          const Q = h.getDepthModeForSublayer(0, Xe.ReadOnly), J = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"), se = [], oe = V.getCircleRadiusCorrection();
          for (const fe of a) {
            const _e = e.getTile(fe), pe = _e.getBucket(i);
            if (!pe) continue;
            const Ie = o ? pe.text : pe.icon;
            if (!Ie || !Ie.segments.get().length || !Ie.hasVisibleVertices) continue;
            const Se = Ie.programConfigurations.get(i.id), be = o || pe.sdfIcons, Re = o ? pe.textSizeData : pe.iconSizeData, Oe = N || V.pitch !== 0, lt = h.useProgram(bo(be, o, pe), Se), _t = c.af(Re, V.zoom), ut = h.style.map.terrain && h.style.map.terrain.getTerrainData(fe);
            let Pt, xt, ct, dt, Kt = [0, 0], Jt = null;
            if (o) xt = _e.glyphAtlasTexture, ct = R.LINEAR, Pt = _e.glyphAtlasTexture.size, pe.iconsInText && (Kt = _e.imageAtlasTexture.size, Jt = _e.imageAtlasTexture, dt = Oe || h.options.rotating || h.options.zooming || Re.kind === "composite" || Re.kind === "camera" ? R.LINEAR : R.NEAREST);
            else {
              const gt = i.layout.get("icon-size").constantOr(0) !== 1 || pe.iconsNeedLinear;
              xt = _e.imageAtlasTexture, ct = be || h.options.rotating || h.options.zooming || gt || Oe ? R.LINEAR : R.NEAREST, Pt = _e.imageAtlasTexture.size;
            }
            const Zt = c.av(_e, 1, h.transform.zoom), ni = le(j, h.transform, Zt), Ur = c.K();
            c.ai(Ur, ni);
            const br = ee(N, j, h.transform, Zt), ur = c.aw(V, _e, u, f), Ui = V.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !M, applyTerrainMatrix: !0 }), Tn = J && pe.hasTextData(), As = i.layout.get("icon-text-fit") !== "none" && Tn && pe.hasIconData();
            if (G) {
              const gt = h.style.map.terrain ? (Ut, Gt) => h.style.map.terrain.getElevation(fe, Ut, Gt) : null, ft = i.layout.get("text-rotation-alignment") === "map";
              ne(pe, h, o, ni, Ur, N, v, ft, fe.toUnwrapped(), V.width, V.height, ur, gt);
            }
            const Pn = o && J || As, Gi = G || Pn ? vo : N ? ni : h.transform.clipSpaceToPixelsMatrix, dr = be && i.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Yi;
            Yi = be ? pe.iconsInText ? Ys(Re.kind, _t, W, N, G, Pn, h, Gi, br, ur, Pt, Kt, oe) : uo(Re.kind, _t, W, N, G, Pn, h, Gi, br, ur, o, Pt, 0, oe) : Js(Re.kind, _t, W, N, G, Pn, h, Gi, br, ur, o, Pt, oe);
            const pr = { program: lt, buffers: Ie, uniformValues: Yi, projectionData: Ui, atlasTexture: xt, atlasTextureIcon: Jt, atlasInterpolation: ct, atlasInterpolationIcon: dt, isSDF: be, hasHalo: dr };
            if (H && pe.canOverlap) {
              K = !0;
              const gt = Ie.segments.get();
              for (const ft of gt) se.push({ segments: new c.aF([ft]), sortKey: ft.sortKey, state: pr, terrainData: ut });
            } else se.push({ segments: Ie.segments, sortKey: 0, state: pr, terrainData: ut });
          }
          K && se.sort((fe, _e) => fe.sortKey - _e.sortKey);
          for (const fe of se) {
            const _e = fe.state;
            if (k.activeTexture.set(R.TEXTURE0), _e.atlasTexture.bind(_e.atlasInterpolation, R.CLAMP_TO_EDGE), _e.atlasTextureIcon && (k.activeTexture.set(R.TEXTURE1), _e.atlasTextureIcon && _e.atlasTextureIcon.bind(_e.atlasInterpolationIcon, R.CLAMP_TO_EDGE)), _e.isSDF) {
              const pe = _e.uniformValues;
              _e.hasHalo && (pe.u_is_halo = 1, ua(_e.buffers, fe.segments, i, h, _e.program, Q, T, S, pe, _e.projectionData, fe.terrainData)), pe.u_is_halo = 0;
            }
            ua(_e.buffers, fe.segments, i, h, _e.program, Q, T, S, _e.uniformValues, _e.projectionData, fe.terrainData);
          }
        }
        function ua(h, e, i, a, o, u, f, _, y, v, T) {
          const S = a.context;
          o.draw(S, S.gl.TRIANGLES, u, f, _, it.backCCW, y, T, v, i.id, h.layoutVertexBuffer, h.indexBuffer, e, i.paint, a.transform.zoom, h.programConfigurations.get(i.id), h.dynamicLayoutVertexBuffer, h.opacityVertexBuffer);
        }
        function $c(h, e, i, a, o) {
          const u = h.context, f = u.gl, _ = rt.disabled, y = new wt([f.ONE, f.ONE], c.b6.transparent, [!0, !0, !0, !0]), v = e.getBucket(i);
          if (!v) return;
          const T = a.key;
          let S = i.heatmapFbos.get(T);
          S || (S = vs(u, e.tileSize, e.tileSize), i.heatmapFbos.set(T, S)), u.bindFramebuffer.set(S.framebuffer), u.viewport.set([0, 0, e.tileSize, e.tileSize]), u.clear({ color: c.b6.transparent });
          const M = v.programConfigurations.get(i.id), k = h.useProgram("heatmap", M, !o), R = h.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), V = h.style.map.terrain.getTerrainData(a);
          k.draw(u, f.TRIANGLES, Xe.disabled, _, y, it.disabled, lo(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1), V, R, i.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, i.paint, h.transform.zoom, M);
        }
        function Ol(h, e, i, a, o) {
          const u = h.context, f = u.gl, _ = h.transform;
          u.setColorMode(h.colorModeForRenderPass());
          const y = da(u, e), v = i.key, T = e.heatmapFbos.get(v);
          if (!T) return;
          u.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, T.colorAttachment.get()), u.activeTexture.set(f.TEXTURE1), y.bind(f.LINEAR, f.CLAMP_TO_EDGE);
          const S = _.getProjectionData({ overscaledTileID: i, applyTerrainMatrix: o, applyGlobeMatrix: !a });
          h.useProgram("heatmapTexture").draw(u, f.TRIANGLES, Xe.disabled, rt.disabled, h.colorModeForRenderPass(), it.disabled, co(h, e, 0, 1), null, S, e.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments, e.paint, _.zoom), T.destroy(), e.heatmapFbos.delete(v);
        }
        function vs(h, e, i) {
          var a, o;
          const u = h.gl, f = u.createTexture();
          u.bindTexture(u.TEXTURE_2D, f), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.LINEAR), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.LINEAR);
          const _ = (a = h.HALF_FLOAT) !== null && a !== void 0 ? a : u.UNSIGNED_BYTE, y = (o = h.RGBA16F) !== null && o !== void 0 ? o : u.RGBA;
          u.texImage2D(u.TEXTURE_2D, 0, y, e, i, 0, u.RGBA, _, null);
          const v = h.createFramebuffer(e, i, !1, !1);
          return v.colorAttachment.set(f), v;
        }
        function da(h, e) {
          return e.colorRampTexture || (e.colorRampTexture = new zt(h, e.colorRamp, h.gl.RGBA)), e.colorRampTexture;
        }
        function wo(h, e, i, a, o) {
          if (!i || !a || !a.imageAtlas) return;
          const u = a.imageAtlas.patternPositions;
          let f = u[i.to.toString()], _ = u[i.from.toString()];
          if (!f && _ && (f = _), !_ && f && (_ = f), !f || !_) {
            const y = o.getPaintProperty(e);
            f = u[y], _ = u[y];
          }
          f && _ && h.setConstantPatternPositions(f, _);
        }
        function To(h, e, i, a, o, u, f, _) {
          const y = h.context.gl, v = "fill-pattern", T = i.paint.get(v), S = T && T.constantOr(1), M = i.getCrossfadeParameters();
          let k, R, V, j, N;
          const G = h.transform, W = i.paint.get("fill-translate"), H = i.paint.get("fill-translate-anchor");
          f ? (R = S && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", k = y.LINES) : (R = S ? "fillPattern" : "fill", k = y.TRIANGLES);
          const K = T.constantOr(null);
          for (const Q of a) {
            const J = e.getTile(Q);
            if (S && !J.patternsLoaded()) continue;
            const se = J.getBucket(i);
            if (!se) continue;
            const oe = se.programConfigurations.get(i.id), fe = h.useProgram(R, oe), _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(Q);
            S && (h.context.activeTexture.set(y.TEXTURE0), J.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), oe.updatePaintBuffers(M)), wo(oe, v, K, J, i);
            const pe = G.getProjectionData({ overscaledTileID: Q, applyGlobeMatrix: !_, applyTerrainMatrix: !0 }), Ie = c.aw(G, J, W, H);
            if (f) {
              j = se.indexBuffer2, N = se.segments2;
              const be = [y.drawingBufferWidth, y.drawingBufferHeight];
              V = R === "fillOutlinePattern" && S ? Rc(h, M, J, be, Ie) : yl(be, Ie);
            } else j = se.indexBuffer, N = se.segments, V = S ? gl(h, M, J, Ie) : { u_fill_translate: Ie };
            let Se;
            if (h.renderPass === "translucent" && _) {
              const [be] = h.getStencilConfigForOverlapAndUpdateStencilID(a);
              Se = be[Q.overscaledZ];
            } else Se = h.stencilModeForClipping(Q);
            fe.draw(h.context, k, o, Se, u, it.backCCW, V, _e, pe, i.id, se.layoutVertexBuffer, j, N, i.paint, h.transform.zoom, oe);
          }
        }
        function Gn(h, e, i, a, o, u, f, _) {
          const y = h.context, v = y.gl, T = "fill-extrusion-pattern", S = i.paint.get(T), M = S.constantOr(1), k = i.getCrossfadeParameters(), R = i.paint.get("fill-extrusion-opacity"), V = S.constantOr(null), j = h.transform;
          for (const N of a) {
            const G = e.getTile(N), W = G.getBucket(i);
            if (!W) continue;
            const H = h.style.map.terrain && h.style.map.terrain.getTerrainData(N), K = W.programConfigurations.get(i.id), Q = h.useProgram(M ? "fillExtrusionPattern" : "fillExtrusion", K);
            M && (h.context.activeTexture.set(v.TEXTURE0), G.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), K.updatePaintBuffers(k));
            const J = j.getProjectionData({ overscaledTileID: N, applyGlobeMatrix: !_, applyTerrainMatrix: !0 });
            wo(K, T, V, G, i);
            const se = c.aw(j, G, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), oe = i.paint.get("fill-extrusion-vertical-gradient"), fe = M ? Vn(h, oe, R, se, N, k, G) : _l(h, oe, R, se);
            Q.draw(y, y.gl.TRIANGLES, o, u, f, it.backCCW, fe, H, J, i.id, W.layoutVertexBuffer, W.indexBuffer, W.segments, i.paint, h.transform.zoom, K, h.style.map.terrain && W.centroidVertexBuffer);
          }
        }
        function bs(h, e, i, a, o, u, f, _, y) {
          var v;
          const T = h.style.projection, S = h.context, M = h.transform, k = S.gl, R = h.useProgram("hillshade"), V = !h.options.moving;
          for (const j of a) {
            const N = e.getTile(j), G = N.fbo;
            if (!G) continue;
            const W = T.getMeshFromTileID(S, j.canonical, _, !0, "raster"), H = (v = h.style.map.terrain) === null || v === void 0 ? void 0 : v.getTerrainData(j);
            S.activeTexture.set(k.TEXTURE0), k.bindTexture(k.TEXTURE_2D, G.colorAttachment.get());
            const K = M.getProjectionData({ overscaledTileID: j, aligned: V, applyGlobeMatrix: !y, applyTerrainMatrix: !0 });
            R.draw(S, k.TRIANGLES, u, o[j.overscaledZ], f, it.backCCW, un(h, N, i), H, K, i.id, W.vertexBuffer, W.indexBuffer, W.segments);
          }
        }
        const Po = [new c.P(0, 0), new c.P(c.Z, 0), new c.P(c.Z, c.Z), new c.P(0, c.Z)];
        function ws(h, e, i, a, o, u, f, _, y = !1, v = !1) {
          const T = a[a.length - 1].overscaledZ, S = h.context, M = S.gl, k = h.useProgram("raster"), R = h.transform, V = h.style.projection, j = h.colorModeForRenderPass(), N = !h.options.moving;
          for (const G of a) {
            const W = h.getDepthModeForSublayer(G.overscaledZ - T, i.paint.get("raster-opacity") === 1 ? Xe.ReadWrite : Xe.ReadOnly, M.LESS), H = e.getTile(G);
            H.registerFadeDuration(i.paint.get("raster-fade-duration"));
            const K = e.findLoadedParent(G, 0), Q = e.findLoadedSibling(G), J = kt(H, K || Q || null, e, i, h.transform, h.style.map.terrain);
            let se, oe;
            const fe = i.paint.get("raster-resampling") === "nearest" ? M.NEAREST : M.LINEAR;
            S.activeTexture.set(M.TEXTURE0), H.texture.bind(fe, M.CLAMP_TO_EDGE, M.LINEAR_MIPMAP_NEAREST), S.activeTexture.set(M.TEXTURE1), K ? (K.texture.bind(fe, M.CLAMP_TO_EDGE, M.LINEAR_MIPMAP_NEAREST), se = Math.pow(2, K.tileID.overscaledZ - H.tileID.overscaledZ), oe = [H.tileID.canonical.x * se % 1, H.tileID.canonical.y * se % 1]) : H.texture.bind(fe, M.CLAMP_TO_EDGE, M.LINEAR_MIPMAP_NEAREST), H.texture.useMipmap && S.extTextureFilterAnisotropic && h.transform.pitch > 20 && M.texParameterf(M.TEXTURE_2D, S.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, S.extTextureFilterAnisotropicMax);
            const _e = h.style.map.terrain && h.style.map.terrain.getTerrainData(G), pe = R.getProjectionData({ overscaledTileID: G, aligned: N, applyGlobeMatrix: !v, applyTerrainMatrix: !0 }), Ie = Pl(oe || [0, 0], se || 1, J, i, _), Se = V.getMeshFromTileID(S, G.canonical, u, f, "raster");
            k.draw(S, M.TRIANGLES, W, o ? o[G.overscaledZ] : rt.disabled, j, y ? it.frontCCW : it.backCCW, Ie, _e, pe, i.id, Se.vertexBuffer, Se.indexBuffer, Se.segments);
          }
        }
        function kt(h, e, i, a, o, u) {
          const f = a.paint.get("raster-fade-duration");
          if (!u && f > 0) {
            const _ = He.now(), y = (_ - h.timeAdded) / f, v = e ? (_ - e.timeAdded) / f : -1, T = i.getSource(), S = yr(o, { tileSize: T.tileSize, roundZoom: T.roundZoom }), M = !e || Math.abs(e.tileID.overscaledZ - S) > Math.abs(h.tileID.overscaledZ - S), k = M && h.refreshedUponExpiration ? 1 : c.ad(M ? y : 1 - v, 0, 1);
            return h.refreshedUponExpiration && y >= 1 && (h.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - k } : { opacity: k, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const yn = new c.b6(1, 0, 0, 1), Ni = new c.b6(0, 1, 0, 1), So = new c.b6(0, 0, 1, 1), Mo = new c.b6(1, 0, 1, 1), jl = new c.b6(0, 1, 1, 1);
        function xn(h, e, i, a) {
          qn(h, 0, e + i / 2, h.transform.width, i, a);
        }
        function $n(h, e, i, a) {
          qn(h, e - i / 2, 0, i, h.transform.height, a);
        }
        function qn(h, e, i, a, o, u) {
          const f = h.context, _ = f.gl;
          _.enable(_.SCISSOR_TEST), _.scissor(e * h.pixelRatio, i * h.pixelRatio, a * h.pixelRatio, o * h.pixelRatio), f.clear({ color: u }), _.disable(_.SCISSOR_TEST);
        }
        function Vl(h, e, i) {
          const a = h.context, o = a.gl, u = h.useProgram("debug"), f = Xe.disabled, _ = rt.disabled, y = h.colorModeForRenderPass(), v = "$debug", T = h.style.map.terrain && h.style.map.terrain.getTerrainData(i);
          a.activeTexture.set(o.TEXTURE0);
          const S = e.getTileByID(i.key).latestRawTileData, M = Math.floor((S && S.byteLength || 0) / 1024), k = e.getTile(i).tileSize, R = 512 / Math.min(k, 512) * (i.overscaledZ / h.transform.zoom) * 0.5;
          let V = i.canonical.toString();
          i.overscaledZ !== i.canonical.z && (V += ` => ${i.overscaledZ}`), function(N, G) {
            N.initDebugOverlayCanvas();
            const W = N.debugOverlayCanvas, H = N.context.gl, K = N.debugOverlayCanvas.getContext("2d");
            K.clearRect(0, 0, W.width, W.height), K.shadowColor = "white", K.shadowBlur = 2, K.lineWidth = 1.5, K.strokeStyle = "white", K.textBaseline = "top", K.font = "bold 36px Open Sans, sans-serif", K.fillText(G, 5, 5), K.strokeText(G, 5, 5), N.debugOverlayTexture.update(W), N.debugOverlayTexture.bind(H.LINEAR, H.CLAMP_TO_EDGE);
          }(h, `${V} ${M}kB`);
          const j = h.transform.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          u.draw(a, o.TRIANGLES, f, _, wt.alphaBlended, it.disabled, oo(c.b6.transparent, R), null, j, v, h.debugBuffer, h.quadTriangleIndexBuffer, h.debugSegments), u.draw(a, o.LINE_STRIP, f, _, y, it.disabled, oo(c.b6.red), T, j, v, h.debugBuffer, h.tileBorderIndexBuffer, h.debugSegments);
        }
        function Io(h, e, i, a) {
          const { isRenderingGlobe: o } = a, u = h.context, f = u.gl, _ = h.transform, y = h.colorModeForRenderPass(), v = h.getDepthModeFor3D(), T = h.useProgram("terrain");
          u.bindFramebuffer.set(null), u.viewport.set([0, 0, h.width, h.height]);
          for (const S of i) {
            const M = e.getTerrainMesh(S.tileID), k = h.renderToTexture.getTexture(S), R = e.getTerrainData(S.tileID);
            u.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, k.texture);
            const V = e.getMeshFrameDelta(_.zoom), j = _.calculateFogMatrix(S.tileID.toUnwrapped()), N = so(V, j, h.style.sky, _.pitch, o), G = _.getProjectionData({ overscaledTileID: S.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            T.draw(u, f.TRIANGLES, v, rt.disabled, y, it.backCCW, N, R, G, "terrain", M.vertexBuffer, M.indexBuffer, M.segments);
          }
        }
        function Co(h, e) {
          if (!e.mesh) {
            const i = new c.aE();
            i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
            const a = new c.aG();
            a.emplaceBack(0, 1, 2), a.emplaceBack(0, 2, 3), e.mesh = new Si(h.createVertexBuffer(i, Li.members), h.createIndexBuffer(a), c.aF.simpleSegment(0, 0, i.length, a.length));
          }
          return e.mesh;
        }
        class Nl {
          constructor(e, i) {
            this.context = new oa(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.as(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = P.maxUnderzooming + P.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ja();
          }
          resize(e, i, a) {
            if (this.width = Math.floor(e * a), this.height = Math.floor(i * a), this.pixelRatio = a, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const o of this.style._order) this.style._layers[o].resize();
          }
          setup() {
            const e = this.context, i = new c.aE();
            i.emplaceBack(0, 0), i.emplaceBack(c.Z, 0), i.emplaceBack(0, c.Z), i.emplaceBack(c.Z, c.Z), this.tileExtentBuffer = e.createVertexBuffer(i, Li.members), this.tileExtentSegments = c.aF.simpleSegment(0, 0, 4, 2);
            const a = new c.aE();
            a.emplaceBack(0, 0), a.emplaceBack(c.Z, 0), a.emplaceBack(0, c.Z), a.emplaceBack(c.Z, c.Z), this.debugBuffer = e.createVertexBuffer(a, Li.members), this.debugSegments = c.aF.simpleSegment(0, 0, 4, 5);
            const o = new c.bV();
            o.emplaceBack(0, 0, 0, 0), o.emplaceBack(c.Z, 0, c.Z, 0), o.emplaceBack(0, c.Z, 0, c.Z), o.emplaceBack(c.Z, c.Z, c.Z, c.Z), this.rasterBoundsBuffer = e.createVertexBuffer(o, or.members), this.rasterBoundsSegments = c.aF.simpleSegment(0, 0, 4, 2);
            const u = new c.aE();
            u.emplaceBack(0, 0), u.emplaceBack(c.Z, 0), u.emplaceBack(0, c.Z), u.emplaceBack(c.Z, c.Z), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(u, Li.members), this.rasterBoundsSegmentsPosOnly = c.aF.simpleSegment(0, 0, 4, 5);
            const f = new c.aE();
            f.emplaceBack(0, 0), f.emplaceBack(1, 0), f.emplaceBack(0, 1), f.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(f, Li.members), this.viewportSegments = c.aF.simpleSegment(0, 0, 4, 2);
            const _ = new c.bW();
            _.emplaceBack(0), _.emplaceBack(1), _.emplaceBack(3), _.emplaceBack(2), _.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(_);
            const y = new c.aG();
            y.emplaceBack(1, 0, 2), y.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(y);
            const v = this.context.gl;
            this.stencilClearMode = new rt({ func: v.ALWAYS, mask: 0 }, 0, 255, v.ZERO, v.ZERO, v.ZERO), this.tileExtentMesh = new Si(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, i = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const a = c.K();
            c.bN(a, 0, this.width, this.height, 0, 0, 1), c.M(a, a, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
            const o = { mainMatrix: a, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: a };
            this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, Xe.disabled, this.stencilClearMode, wt.disabled, it.disabled, null, null, o, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, i, a) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil();
            const o = this.context;
            o.setColorMode(wt.disabled), o.setDepthMode(Xe.disabled);
            const u = {};
            for (const f of i) u[f.key] = this.nextStencilID++;
            this._renderTileMasks(u, i, a, !0), this._renderTileMasks(u, i, a, !1), this._tileClippingMaskIDs = u;
          }
          _renderTileMasks(e, i, a, o) {
            const u = this.context, f = u.gl, _ = this.style.projection, y = this.transform, v = this.useProgram("clippingMask");
            for (const T of i) {
              const S = e[T.key], M = this.style.map.terrain && this.style.map.terrain.getTerrainData(T), k = _.getMeshFromTileID(this.context, T.canonical, o, !0, "stencil"), R = y.getProjectionData({ overscaledTileID: T, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              v.draw(u, f.TRIANGLES, Xe.disabled, new rt({ func: f.ALWAYS, mask: 0 }, S, 255, f.KEEP, f.KEEP, f.REPLACE), wt.disabled, a ? it.disabled : it.backCCW, null, M, R, "$clipping", k.vertexBuffer, k.indexBuffer, k.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, i = e.gl, a = this.style.projection, o = this.transform, u = this.useProgram("depth"), f = this.getDepthModeFor3D(), _ = ie(o, { tileSize: o.tileSize });
            for (const y of _) {
              const v = this.style.map.terrain && this.style.map.terrain.getTerrainData(y), T = a.getMeshFromTileID(this.context, y.canonical, !0, !0, "raster"), S = o.getProjectionData({ overscaledTileID: y, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              u.draw(e, i.TRIANGLES, f, rt.disabled, wt.disabled, it.backCCW, null, v, S, "$clipping", T.vertexBuffer, T.indexBuffer, T.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, i = this.context.gl;
            return new rt({ func: i.NOTEQUAL, mask: 255 }, e, 255, i.KEEP, i.KEEP, i.REPLACE);
          }
          stencilModeForClipping(e) {
            const i = this.context.gl;
            return new rt({ func: i.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const i = this.context.gl, a = e.sort((f, _) => _.overscaledZ - f.overscaledZ), o = a[a.length - 1].overscaledZ, u = a[0].overscaledZ - o + 1;
            if (u > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + u > 256 && this.clearStencil();
              const f = {};
              for (let _ = 0; _ < u; _++) f[_ + o] = new rt({ func: i.GEQUAL, mask: 255 }, _ + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID += u, [f, a];
            }
            return [{ [o]: rt.disabled }, a];
          }
          stencilConfigForOverlapTwoPass(e) {
            const i = this.context.gl, a = e.sort((f, _) => _.overscaledZ - f.overscaledZ), o = a[a.length - 1].overscaledZ, u = a[0].overscaledZ - o + 1;
            if (this.clearStencil(), u > 1) {
              const f = {}, _ = {};
              for (let y = 0; y < u; y++) f[y + o] = new rt({ func: i.GREATER, mask: 255 }, u + 1 + y, 255, i.KEEP, i.KEEP, i.REPLACE), _[y + o] = new rt({ func: i.GREATER, mask: 255 }, 1 + y, 255, i.KEEP, i.KEEP, i.REPLACE);
              return this.nextStencilID = 2 * u + 1, [f, _, a];
            }
            return this.nextStencilID = 3, [{ [o]: new rt({ func: i.GREATER, mask: 255 }, 2, 255, i.KEEP, i.KEEP, i.REPLACE) }, { [o]: new rt({ func: i.GREATER, mask: 255 }, 1, 255, i.KEEP, i.KEEP, i.REPLACE) }, a];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new wt([e.CONSTANT_COLOR, e.ONE], new c.b6(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? wt.unblended : wt.alphaBlended;
          }
          getDepthModeForSublayer(e, i, a) {
            if (!this.opaquePassEnabledForLayer()) return Xe.disabled;
            const o = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new Xe(a || this.context.gl.LEQUAL, i, [o, o]);
          }
          getDepthModeFor3D() {
            return new Xe(this.context.gl.LEQUAL, Xe.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, i) {
            var a, o;
            this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(He.now()), this.imageManager.beginFrame();
            const u = this.style._order, f = this.style.sourceCaches, _ = {}, y = {}, v = {}, T = { isRenderingToTexture: !1, isRenderingGlobe: ((a = e.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 };
            for (const M in f) {
              const k = f[M];
              k.used && k.prepare(this.context), _[M] = k.getVisibleCoordinates(!1), y[M] = _[M].slice().reverse(), v[M] = k.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let M = 0; M < u.length; M++) if (this.style._layers[u[M]].is3D()) {
              this.opaquePassCutoff = M;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const M of u) {
              const k = this.style._layers[M];
              if (!k.hasOffscreenPass() || k.isHidden(this.transform.zoom)) continue;
              const R = y[k.source];
              (k.type === "custom" || R.length) && this.renderLayer(this, f[k.source], k, R, T);
            }
            if ((o = this.style.projection) === null || o === void 0 || o.updateGPUdependent({ context: this.context, useProgram: (M) => this.useProgram(M) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i.showOverdrawInspector ? c.b6.black : c.b6.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(M, k) {
              const R = M.context, V = R.gl, j = ((Q, J, se) => {
                const oe = Math.cos(J.rollInRadians), fe = Math.sin(J.rollInRadians), _e = Ht(J), pe = J.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Q.properties.get("sky-color"), u_horizon_color: Q.properties.get("horizon-color"), u_horizon: [(J.width / 2 - _e * fe) * se, (J.height / 2 + _e * oe) * se], u_horizon_normal: [-fe, oe], u_sky_horizon_blend: Q.properties.get("sky-horizon-blend") * J.height / 2 * se, u_sky_blend: pe };
              })(k, M.style.map.transform, M.pixelRatio), N = new Xe(V.LEQUAL, Xe.ReadWrite, [0, 1]), G = rt.disabled, W = M.colorModeForRenderPass(), H = M.useProgram("sky"), K = Co(R, k);
              H.draw(R, V.TRIANGLES, N, G, W, it.disabled, j, null, void 0, "sky", K.vertexBuffer, K.indexBuffer, K.segments);
            }(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = u.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const M = this.style._layers[u[this.currentLayer]], k = f[M.source], R = _[M.source];
              this._renderTileClippingMasks(M, R, !1), this.renderLayer(this, k, M, R, T);
            }
            this.renderPass = "translucent";
            let S = !1;
            for (this.currentLayer = 0; this.currentLayer < u.length; this.currentLayer++) {
              const M = this.style._layers[u[this.currentLayer]], k = f[M.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(M, T)) continue;
              this.opaquePassEnabledForLayer() || S || (S = !0, T.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const R = (M.type === "symbol" ? v : y)[M.source];
              this._renderTileClippingMasks(M, _[M.source], !1), this.renderLayer(this, k, M, R, T);
            }
            if (T.isRenderingGlobe && function(M, k, R) {
              const V = M.context, j = V.gl, N = M.useProgram("atmosphere"), G = new Xe(j.LEQUAL, Xe.ReadOnly, [0, 1]), W = M.transform, H = function(pe, Ie) {
                const Se = pe.properties.get("position"), be = [-Se.x, -Se.y, -Se.z], Re = c.as(new Float64Array(16));
                return pe.properties.get("anchor") === "map" && (c.aZ(Re, Re, Ie.rollInRadians), c.a_(Re, Re, -Ie.pitchInRadians), c.aZ(Re, Re, Ie.bearingInRadians), c.a_(Re, Re, Ie.center.lat * Math.PI / 180), c.bl(Re, Re, -Ie.center.lng * Math.PI / 180)), c.bU(be, be, Re), be;
              }(R, M.transform), K = W.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Q = k.properties.get("atmosphere-blend") * K.projectionTransition;
              if (Q === 0) return;
              const J = ui(W.worldSize, W.center.lat), se = W.inverseProjectionMatrix, oe = new Float64Array(4);
              oe[3] = 1, c.ao(oe, oe, W.modelViewProjectionMatrix), oe[0] /= oe[3], oe[1] /= oe[3], oe[2] /= oe[3], oe[3] = 1, c.ao(oe, oe, se), oe[0] /= oe[3], oe[1] /= oe[3], oe[2] /= oe[3], oe[3] = 1;
              const fe = /* @__PURE__ */ ((pe, Ie, Se, be, Re) => ({ u_sun_pos: pe, u_atmosphere_blend: Ie, u_globe_position: Se, u_globe_radius: be, u_inv_proj_matrix: Re }))(H, Q, [oe[0], oe[1], oe[2]], J, se), _e = Co(V, k);
              N.draw(V, j.TRIANGLES, G, rt.disabled, wt.alphaBlended, it.disabled, fe, null, null, "atmosphere", _e.vertexBuffer, _e.indexBuffer, _e.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const M = function(k, R) {
                let V = null;
                const j = Object.values(k._layers).flatMap((H) => H.source && !H.isHidden(R) ? [k.sourceCaches[H.source]] : []), N = j.filter((H) => H.getSource().type === "vector"), G = j.filter((H) => H.getSource().type !== "vector"), W = (H) => {
                  (!V || V.getSource().maxzoom < H.getSource().maxzoom) && (V = H);
                };
                return N.forEach((H) => W(H)), V || G.forEach((H) => W(H)), V;
              }(this.style, this.transform.zoom);
              M && function(k, R, V) {
                for (let j = 0; j < V.length; j++) Vl(k, R, V[j]);
              }(this, M, M.getVisibleCoordinates());
            }
            this.options.showPadding && function(M) {
              const k = M.transform.padding;
              xn(M, M.transform.height - (k.top || 0), 3, yn), xn(M, k.bottom || 0, 3, Ni), $n(M, k.left || 0, 3, So), $n(M, M.transform.width - (k.right || 0), 3, Mo);
              const R = M.transform.centerPoint;
              (function(V, j, N, G) {
                qn(V, j - 1, N - 10, 2, 20, G), qn(V, j - 10, N - 1, 20, 2, G);
              })(M, R.x, M.transform.height - R.y, jl);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i = this.terrainFacilitator.matrix, a = this.transform.modelViewProjectionMatrix;
            let o = this.terrainFacilitator.dirty;
            o || (o = e ? !c.bX(i, a) : !c.bY(i, a)), o || (o = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o && (c.bZ(i, a), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(u, f) {
              const _ = u.context, y = _.gl, v = u.transform, T = wt.unblended, S = new Xe(y.LEQUAL, Xe.ReadWrite, [0, 1]), M = f.sourceCache.getRenderableTiles(), k = u.useProgram("terrainDepth");
              _.bindFramebuffer.set(f.getFramebuffer("depth").framebuffer), _.viewport.set([0, 0, u.width / devicePixelRatio, u.height / devicePixelRatio]), _.clear({ color: c.b6.transparent, depth: 1 });
              for (const R of M) {
                const V = f.getTerrainMesh(R.tileID), j = f.getTerrainData(R.tileID), N = v.getProjectionData({ overscaledTileID: R.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), G = { u_ele_delta: f.getMeshFrameDelta(v.zoom) };
                k.draw(_, y.TRIANGLES, S, rt.disabled, T, it.backCCW, G, j, N, "terrain", V.vertexBuffer, V.indexBuffer, V.segments);
              }
              _.bindFramebuffer.set(null), _.viewport.set([0, 0, u.width, u.height]);
            }(this, this.style.map.terrain), function(u, f) {
              const _ = u.context, y = _.gl, v = u.transform, T = wt.unblended, S = new Xe(y.LEQUAL, Xe.ReadWrite, [0, 1]), M = f.getCoordsTexture(), k = f.sourceCache.getRenderableTiles(), R = u.useProgram("terrainCoords");
              _.bindFramebuffer.set(f.getFramebuffer("coords").framebuffer), _.viewport.set([0, 0, u.width / devicePixelRatio, u.height / devicePixelRatio]), _.clear({ color: c.b6.transparent, depth: 1 }), f.coordsIndex = [];
              for (const V of k) {
                const j = f.getTerrainMesh(V.tileID), N = f.getTerrainData(V.tileID);
                _.activeTexture.set(y.TEXTURE0), y.bindTexture(y.TEXTURE_2D, M.texture);
                const G = { u_terrain_coords_id: (255 - f.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: f.getMeshFrameDelta(v.zoom) }, W = v.getProjectionData({ overscaledTileID: V.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                R.draw(_, y.TRIANGLES, S, rt.disabled, T, it.backCCW, G, N, W, "terrain", j.vertexBuffer, j.indexBuffer, j.segments), f.coordsIndex.push(V.tileID.key);
              }
              _.bindFramebuffer.set(null), _.viewport.set([0, 0, u.width, u.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(e, i, a, o, u) {
            a.isHidden(this.transform.zoom) || (a.type === "background" || a.type === "custom" || (o || []).length) && (this.id = a.id, c.b_(a) ? function(f, _, y, v, T, S) {
              if (f.renderPass !== "translucent") return;
              const { isRenderingToTexture: M } = S, k = rt.disabled, R = f.colorModeForRenderPass();
              (y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(V, j, N, G, W, H, K, Q, J) {
                const se = j.transform, oe = j.style.map.terrain, fe = W === "map", _e = H === "map";
                for (const pe of V) {
                  const Ie = G.getTile(pe), Se = Ie.getBucket(N);
                  if (!Se || !Se.text || !Se.text.segments.get().length) continue;
                  const be = c.af(Se.textSizeData, se.zoom), Re = c.av(Ie, 1, j.transform.zoom), Oe = le(fe, j.transform, Re), lt = N.layout.get("icon-text-fit") !== "none" && Se.hasIconData();
                  if (be) {
                    const _t = Math.pow(2, se.zoom - Ie.tileID.overscaledZ), ut = oe ? (Pt, xt) => oe.getElevation(pe, Pt, xt) : null;
                    ha(Se, fe, _e, J, se, Oe, _t, be, lt, c.aw(se, Ie, K, Q), pe.toUnwrapped(), ut);
                  }
                }
              }(v, f, y, _, y.layout.get("text-rotation-alignment"), y.layout.get("text-pitch-alignment"), y.paint.get("text-translate"), y.paint.get("text-translate-anchor"), T), y.paint.get("icon-opacity").constantOr(1) !== 0 && Fl(f, _, y, v, !1, y.paint.get("icon-translate"), y.paint.get("icon-translate-anchor"), y.layout.get("icon-rotation-alignment"), y.layout.get("icon-pitch-alignment"), y.layout.get("icon-keep-upright"), k, R, M), y.paint.get("text-opacity").constantOr(1) !== 0 && Fl(f, _, y, v, !0, y.paint.get("text-translate"), y.paint.get("text-translate-anchor"), y.layout.get("text-rotation-alignment"), y.layout.get("text-pitch-alignment"), y.layout.get("text-keep-upright"), k, R, M), _.map.showCollisionBoxes && (la(f, _, y, v, !0), la(f, _, y, v, !1));
            }(e, i, a, o, this.style.placement.variableOffsets, u) : c.b$(a) ? function(f, _, y, v, T) {
              if (f.renderPass !== "translucent") return;
              const { isRenderingToTexture: S } = T, M = y.paint.get("circle-opacity"), k = y.paint.get("circle-stroke-width"), R = y.paint.get("circle-stroke-opacity"), V = !y.layout.get("circle-sort-key").isConstant();
              if (M.constantOr(1) === 0 && (k.constantOr(1) === 0 || R.constantOr(1) === 0)) return;
              const j = f.context, N = j.gl, G = f.transform, W = f.getDepthModeForSublayer(0, Xe.ReadOnly), H = rt.disabled, K = f.colorModeForRenderPass(), Q = [], J = G.getCircleRadiusCorrection();
              for (let se = 0; se < v.length; se++) {
                const oe = v[se], fe = _.getTile(oe), _e = fe.getBucket(y);
                if (!_e) continue;
                const pe = y.paint.get("circle-translate"), Ie = y.paint.get("circle-translate-anchor"), Se = c.aw(G, fe, pe, Ie), be = _e.programConfigurations.get(y.id), Re = f.useProgram("circle", be), Oe = _e.layoutVertexBuffer, lt = _e.indexBuffer, _t = f.style.map.terrain && f.style.map.terrain.getTerrainData(oe), ut = { programConfiguration: be, program: Re, layoutVertexBuffer: Oe, indexBuffer: lt, uniformValues: xl(f, fe, y, Se, J), terrainData: _t, projectionData: G.getProjectionData({ overscaledTileID: oe, applyGlobeMatrix: !S, applyTerrainMatrix: !0 }) };
                if (V) {
                  const Pt = _e.segments.get();
                  for (const xt of Pt) Q.push({ segments: new c.aF([xt]), sortKey: xt.sortKey, state: ut });
                } else Q.push({ segments: _e.segments, sortKey: 0, state: ut });
              }
              V && Q.sort((se, oe) => se.sortKey - oe.sortKey);
              for (const se of Q) {
                const { programConfiguration: oe, program: fe, layoutVertexBuffer: _e, indexBuffer: pe, uniformValues: Ie, terrainData: Se, projectionData: be } = se.state;
                fe.draw(j, N.TRIANGLES, W, H, K, it.backCCW, Ie, Se, be, y.id, _e, pe, se.segments, y.paint, f.transform.zoom, oe);
              }
            }(e, i, a, o, u) : c.c0(a) ? function(f, _, y, v, T) {
              if (y.paint.get("heatmap-opacity") === 0) return;
              const S = f.context, { isRenderingToTexture: M, isRenderingGlobe: k } = T;
              if (f.style.map.terrain) {
                for (const R of v) {
                  const V = _.getTile(R);
                  _.hasRenderableParent(R) || (f.renderPass === "offscreen" ? $c(f, V, y, R, k) : f.renderPass === "translucent" && Ol(f, y, R, M, k));
                }
                S.viewport.set([0, 0, f.width, f.height]);
              } else f.renderPass === "offscreen" ? function(R, V, j, N) {
                const G = R.context, W = G.gl, H = R.transform, K = rt.disabled, Q = new wt([W.ONE, W.ONE], c.b6.transparent, [!0, !0, !0, !0]);
                (function(J, se, oe) {
                  const fe = J.gl;
                  J.activeTexture.set(fe.TEXTURE1), J.viewport.set([0, 0, se.width / 4, se.height / 4]);
                  let _e = oe.heatmapFbos.get(c.bR);
                  _e ? (fe.bindTexture(fe.TEXTURE_2D, _e.colorAttachment.get()), J.bindFramebuffer.set(_e.framebuffer)) : (_e = vs(J, se.width / 4, se.height / 4), oe.heatmapFbos.set(c.bR, _e));
                })(G, R, j), G.clear({ color: c.b6.transparent });
                for (let J = 0; J < N.length; J++) {
                  const se = N[J];
                  if (V.hasRenderableParent(se)) continue;
                  const oe = V.getTile(se), fe = oe.getBucket(j);
                  if (!fe) continue;
                  const _e = fe.programConfigurations.get(j.id), pe = R.useProgram("heatmap", _e), Ie = H.getProjectionData({ overscaledTileID: se, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), Se = H.getCircleRadiusCorrection();
                  pe.draw(G, W.TRIANGLES, Xe.disabled, K, Q, it.backCCW, lo(oe, H.zoom, j.paint.get("heatmap-intensity"), Se), null, Ie, j.id, fe.layoutVertexBuffer, fe.indexBuffer, fe.segments, j.paint, H.zoom, _e);
                }
                G.viewport.set([0, 0, R.width, R.height]);
              }(f, _, y, v) : f.renderPass === "translucent" && function(R, V) {
                const j = R.context, N = j.gl;
                j.setColorMode(R.colorModeForRenderPass());
                const G = V.heatmapFbos.get(c.bR);
                G && (j.activeTexture.set(N.TEXTURE0), N.bindTexture(N.TEXTURE_2D, G.colorAttachment.get()), j.activeTexture.set(N.TEXTURE1), da(j, V).bind(N.LINEAR, N.CLAMP_TO_EDGE), R.useProgram("heatmapTexture").draw(j, N.TRIANGLES, Xe.disabled, rt.disabled, R.colorModeForRenderPass(), it.disabled, co(R, V, 0, 1), null, null, V.id, R.viewportBuffer, R.quadTriangleIndexBuffer, R.viewportSegments, V.paint, R.transform.zoom));
              }(f, y);
            }(e, i, a, o, u) : c.c1(a) ? function(f, _, y, v, T) {
              if (f.renderPass !== "translucent") return;
              const { isRenderingToTexture: S } = T, M = y.paint.get("line-opacity"), k = y.paint.get("line-width");
              if (M.constantOr(1) === 0 || k.constantOr(1) === 0) return;
              const R = f.getDepthModeForSublayer(0, Xe.ReadOnly), V = f.colorModeForRenderPass(), j = y.paint.get("line-dasharray"), N = y.paint.get("line-pattern"), G = N.constantOr(1), W = y.paint.get("line-gradient"), H = y.getCrossfadeParameters(), K = G ? "linePattern" : j ? "lineSDF" : W ? "lineGradient" : "line", Q = f.context, J = Q.gl, se = f.transform;
              let oe = !0;
              for (const fe of v) {
                const _e = _.getTile(fe);
                if (G && !_e.patternsLoaded()) continue;
                const pe = _e.getBucket(y);
                if (!pe) continue;
                const Ie = pe.programConfigurations.get(y.id), Se = f.context.program.get(), be = f.useProgram(K, Ie), Re = oe || be.program !== Se, Oe = f.style.map.terrain && f.style.map.terrain.getTerrainData(fe), lt = N.constantOr(null);
                if (lt && _e.imageAtlas) {
                  const ct = _e.imageAtlas, dt = ct.patternPositions[lt.to.toString()], Kt = ct.patternPositions[lt.from.toString()];
                  dt && Kt && Ie.setConstantPatternPositions(dt, Kt);
                }
                const _t = se.getProjectionData({ overscaledTileID: fe, applyGlobeMatrix: !S, applyTerrainMatrix: !0 }), ut = se.getPixelScale(), Pt = G ? Ks(f, _e, y, ut, H) : j ? Bc(f, _e, y, ut, j, H) : W ? Lc(f, _e, y, ut, pe.lineClipsArray.length) : dn(f, _e, y, ut);
                if (G) Q.activeTexture.set(J.TEXTURE0), _e.imageAtlasTexture.bind(J.LINEAR, J.CLAMP_TO_EDGE), Ie.updatePaintBuffers(H);
                else if (j && (Re || f.lineAtlas.dirty)) Q.activeTexture.set(J.TEXTURE0), f.lineAtlas.bind(Q);
                else if (W) {
                  const ct = pe.gradients[y.id];
                  let dt = ct.texture;
                  if (y.gradientVersion !== ct.version) {
                    let Kt = 256;
                    if (y.stepInterpolant) {
                      const Jt = _.getSource().maxzoom, Zt = fe.canonical.z === Jt ? Math.ceil(1 << f.transform.maxZoom - fe.canonical.z) : 1;
                      Kt = c.ad(c.bS(pe.maxLineLength / c.Z * 1024 * Zt), 256, Q.maxTextureSize);
                    }
                    ct.gradient = c.bT({ expression: y.gradientExpression(), evaluationKey: "lineProgress", resolution: Kt, image: ct.gradient || void 0, clips: pe.lineClipsArray }), ct.texture ? ct.texture.update(ct.gradient) : ct.texture = new zt(Q, ct.gradient, J.RGBA), ct.version = y.gradientVersion, dt = ct.texture;
                  }
                  Q.activeTexture.set(J.TEXTURE0), dt.bind(y.stepInterpolant ? J.NEAREST : J.LINEAR, J.CLAMP_TO_EDGE);
                }
                let xt;
                if (S) {
                  const [ct] = f.getStencilConfigForOverlapAndUpdateStencilID(v);
                  xt = ct[fe.overscaledZ];
                } else xt = f.stencilModeForClipping(fe);
                be.draw(Q, J.TRIANGLES, R, xt, V, it.disabled, Pt, Oe, _t, y.id, pe.layoutVertexBuffer, pe.indexBuffer, pe.segments, y.paint, f.transform.zoom, Ie, pe.layoutVertexBuffer2), oe = !1;
              }
            }(e, i, a, o, u) : c.c2(a) ? function(f, _, y, v, T) {
              const S = y.paint.get("fill-color"), M = y.paint.get("fill-opacity");
              if (M.constantOr(1) === 0) return;
              const { isRenderingToTexture: k } = T, R = f.colorModeForRenderPass(), V = y.paint.get("fill-pattern"), j = f.opaquePassEnabledForLayer() && !V.constantOr(1) && S.constantOr(c.b6.transparent).a === 1 && M.constantOr(0) === 1 ? "opaque" : "translucent";
              if (f.renderPass === j) {
                const N = f.getDepthModeForSublayer(1, f.renderPass === "opaque" ? Xe.ReadWrite : Xe.ReadOnly);
                To(f, _, y, v, N, R, !1, k);
              }
              if (f.renderPass === "translucent" && y.paint.get("fill-antialias")) {
                const N = f.getDepthModeForSublayer(y.getPaintProperty("fill-outline-color") ? 2 : 0, Xe.ReadOnly);
                To(f, _, y, v, N, R, !0, k);
              }
            }(e, i, a, o, u) : c.c3(a) ? function(f, _, y, v, T) {
              const S = y.paint.get("fill-extrusion-opacity");
              if (S === 0) return;
              const { isRenderingToTexture: M } = T;
              if (f.renderPass === "translucent") {
                const k = new Xe(f.context.gl.LEQUAL, Xe.ReadWrite, f.depthRangeFor3D);
                if (S !== 1 || y.paint.get("fill-extrusion-pattern").constantOr(1)) Gn(f, _, y, v, k, rt.disabled, wt.disabled, M), Gn(f, _, y, v, k, f.stencilModeFor3D(), f.colorModeForRenderPass(), M);
                else {
                  const R = f.colorModeForRenderPass();
                  Gn(f, _, y, v, k, rt.disabled, R, M);
                }
              }
            }(e, i, a, o, u) : c.c4(a) ? function(f, _, y, v, T) {
              if (f.renderPass !== "offscreen" && f.renderPass !== "translucent") return;
              const { isRenderingToTexture: S } = T, M = f.context, k = f.style.projection.useSubdivision, R = f.getDepthModeForSublayer(0, Xe.ReadOnly), V = f.colorModeForRenderPass();
              if (f.renderPass === "offscreen") (function(j, N, G, W, H, K, Q) {
                const J = j.context, se = J.gl;
                for (const oe of G) {
                  const fe = N.getTile(oe), _e = fe.dem;
                  if (!_e || !_e.data || !fe.needsHillshadePrepare) continue;
                  const pe = _e.dim, Ie = _e.stride, Se = _e.getPixels();
                  if (J.activeTexture.set(se.TEXTURE1), J.pixelStoreUnpackPremultiplyAlpha.set(!1), fe.demTexture = fe.demTexture || j.getTileTexture(Ie), fe.demTexture) {
                    const Re = fe.demTexture;
                    Re.update(Se, { premultiply: !1 }), Re.bind(se.NEAREST, se.CLAMP_TO_EDGE);
                  } else fe.demTexture = new zt(J, Se, se.RGBA, { premultiply: !1 }), fe.demTexture.bind(se.NEAREST, se.CLAMP_TO_EDGE);
                  J.activeTexture.set(se.TEXTURE0);
                  let be = fe.fbo;
                  if (!be) {
                    const Re = new zt(J, { width: pe, height: pe, data: null }, se.RGBA);
                    Re.bind(se.LINEAR, se.CLAMP_TO_EDGE), be = fe.fbo = J.createFramebuffer(pe, pe, !0, !1), be.colorAttachment.set(Re.texture);
                  }
                  J.bindFramebuffer.set(be.framebuffer), J.viewport.set([0, 0, pe, pe]), j.useProgram("hillshadePrepare").draw(J, se.TRIANGLES, H, K, Q, it.disabled, bl(fe.tileID, _e), null, null, W.id, j.rasterBoundsBuffer, j.quadTriangleIndexBuffer, j.rasterBoundsSegments), fe.needsHillshadePrepare = !1;
                }
              })(f, _, v, y, R, rt.disabled, V), M.viewport.set([0, 0, f.width, f.height]);
              else if (f.renderPass === "translucent") if (k) {
                const [j, N, G] = f.stencilConfigForOverlapTwoPass(v);
                bs(f, _, y, G, j, R, V, !1, S), bs(f, _, y, G, N, R, V, !0, S);
              } else {
                const [j, N] = f.getStencilConfigForOverlapAndUpdateStencilID(v);
                bs(f, _, y, N, j, R, V, !1, S);
              }
            }(e, i, a, o, u) : c.c5(a) ? function(f, _, y, v, T) {
              if (f.renderPass !== "translucent" || y.paint.get("raster-opacity") === 0 || !v.length) return;
              const { isRenderingToTexture: S } = T, M = _.getSource(), k = f.style.projection.useSubdivision;
              if (M instanceof ar) ws(f, _, y, v, null, !1, !1, M.tileCoords, M.flippedWindingOrder, S);
              else if (k) {
                const [R, V, j] = f.stencilConfigForOverlapTwoPass(v);
                ws(f, _, y, j, R, !1, !0, Po, !1, S), ws(f, _, y, j, V, !0, !0, Po, !1, S);
              } else {
                const [R, V] = f.getStencilConfigForOverlapAndUpdateStencilID(v);
                ws(f, _, y, V, R, !1, !0, Po, !1, S);
              }
            }(e, i, a, o, u) : c.c6(a) ? function(f, _, y, v, T) {
              const S = y.paint.get("background-color"), M = y.paint.get("background-opacity");
              if (M === 0) return;
              const { isRenderingToTexture: k } = T, R = f.context, V = R.gl, j = f.style.projection, N = f.transform, G = N.tileSize, W = y.paint.get("background-pattern");
              if (f.isPatternMissing(W)) return;
              const H = !W && S.a === 1 && M === 1 && f.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (f.renderPass !== H) return;
              const K = rt.disabled, Q = f.getDepthModeForSublayer(0, H === "opaque" ? Xe.ReadWrite : Xe.ReadOnly), J = f.colorModeForRenderPass(), se = f.useProgram(W ? "backgroundPattern" : "background"), oe = v || ie(N, { tileSize: G, terrain: f.style.map.terrain });
              W && (R.activeTexture.set(V.TEXTURE0), f.imageManager.bind(f.context));
              const fe = y.getCrossfadeParameters();
              for (const _e of oe) {
                const pe = N.getProjectionData({ overscaledTileID: _e, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }), Ie = W ? po(M, f, W, { tileID: _e, tileSize: G }, fe) : xr(M, S), Se = f.style.map.terrain && f.style.map.terrain.getTerrainData(_e), be = j.getMeshFromTileID(R, _e.canonical, !1, !0, "raster");
                se.draw(R, V.TRIANGLES, Q, K, J, it.backCCW, Ie, Se, pe, y.id, be.vertexBuffer, be.indexBuffer, be.segments);
              }
            }(e, 0, a, o, u) : c.c7(a) && function(f, _, y, v) {
              const { isRenderingGlobe: T } = v, S = f.context, M = y.implementation, k = f.style.projection, R = f.transform, V = R.getProjectionDataForCustomLayer(T), j = { farZ: R.farZ, nearZ: R.nearZ, fov: R.fov * Math.PI / 180, modelViewProjectionMatrix: R.modelViewProjectionMatrix, projectionMatrix: R.projectionMatrix, shaderData: { variantName: k.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${k.shaderPreludeCode.vertexSource}`, define: k.shaderDefine }, defaultProjectionData: V }, N = M.renderingMode ? M.renderingMode : "2d";
              if (f.renderPass === "offscreen") {
                const G = M.prerender;
                G && (f.setCustomLayerDefaults(), S.setColorMode(f.colorModeForRenderPass()), G.call(M, S.gl, j), S.setDirty(), f.setBaseState());
              } else if (f.renderPass === "translucent") {
                f.setCustomLayerDefaults(), S.setColorMode(f.colorModeForRenderPass()), S.setStencilMode(rt.disabled);
                const G = N === "3d" ? f.getDepthModeFor3D() : f.getDepthModeForSublayer(0, Xe.ReadOnly);
                S.setDepthMode(G), M.render(S.gl, j), S.setDirty(), f.setBaseState(), S.bindFramebuffer.set(null);
              }
            }(e, 0, a, u));
          }
          saveTileTexture(e) {
            const i = this._tileTextures[e.size[0]];
            i ? i.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const i = this._tileTextures[e];
            return i && i.length > 0 ? i.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return !1;
            if (!e.from || !e.to) return !0;
            const i = this.imageManager.getPattern(e.from.toString()), a = this.imageManager.getPattern(e.to.toString());
            return !i || !a;
          }
          useProgram(e, i, a = !1) {
            this.cache = this.cache || {};
            const o = !!this.style.map.terrain, u = this.style.projection, f = e + (i ? i.cacheKey : "") + `/${a ? js : u.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (o ? "/terrain" : "");
            return this.cache[f] || (this.cache[f] = new Dc(this.context, Xi[e], i, fo[e], this._showOverdrawInspector, o, a ? Xi.projectionMercator : u.shaderPreludeCode, a ? st : u.shaderDefine)), this.cache[f];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new zt(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: i } = this.context.gl;
            return this.width !== e || this.height !== i;
          }
        }
        function Eo(h, e) {
          let i, a = !1, o = null, u = null;
          const f = () => {
            o = null, a && (h.apply(u, i), o = setTimeout(f, e), a = !1);
          };
          return (..._) => (a = !0, u = this, i = _, o || f(), o);
        }
        class jr {
          constructor(e) {
            this._getCurrentHash = () => {
              const i = window.location.hash.replace("#", "");
              if (this._hashName) {
                let a;
                return i.split("&").map((o) => o.split("=")).forEach((o) => {
                  o[0] === this._hashName && (a = o);
                }), (a && a[1] || "").split("/");
              }
              return i.split("/");
            }, this._onHashChange = () => {
              const i = this._getCurrentHash();
              if (!this._isValidHash(i)) return !1;
              const a = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+i[2], +i[1]], zoom: +i[0], bearing: a, pitch: +(i[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, i);
            }, this._removeHash = () => {
              const i = this._getCurrentHash();
              if (i.length === 0) return;
              const a = i.join("/");
              let o = a;
              o.split("&").length > 0 && (o = o.split("&")[0]), this._hashName && (o = `${this._hashName}=${a}`);
              let u = window.location.hash.replace(o, "");
              u.startsWith("#&") ? u = u.slice(0, 1) + u.slice(2) : u === "#" && (u = "");
              let f = window.location.href.replace(/(#.+)?$/, u);
              f = f.replace("&&", "&"), window.history.replaceState(window.history.state, null, f);
            }, this._updateHash = Eo(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const i = this._map.getCenter(), a = Math.round(100 * this._map.getZoom()) / 100, o = Math.ceil((a * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), u = Math.pow(10, o), f = Math.round(i.lng * u) / u, _ = Math.round(i.lat * u) / u, y = this._map.getBearing(), v = this._map.getPitch();
            let T = "";
            if (T += e ? `/${f}/${_}/${a}` : `${a}/${_}/${f}`, (y || v) && (T += "/" + Math.round(10 * y) / 10), v && (T += `/${Math.round(v)}`), this._hashName) {
              const S = this._hashName;
              let M = !1;
              const k = window.location.hash.slice(1).split("&").map((R) => {
                const V = R.split("=")[0];
                return V === S ? (M = !0, `${V}=${T}`) : R;
              }).filter((R) => R);
              return M || k.push(`${S}=${T}`), `#${k.join("&")}`;
            }
            return `#${T}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return !1;
            try {
              new c.Q(+e[2], +e[1]);
            } catch {
              return !1;
            }
            const i = +e[0], a = +(e[3] || 0), o = +(e[4] || 0);
            return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && a >= -180 && a <= 180 && o >= this._map.getMinPitch() && o <= this._map.getMaxPitch();
          }
        }
        const Wn = { linearity: 0.3, easing: c.c8(0, 0, 0.3, 1) }, Zl = c.e({ deceleration: 2500, maxSpeed: 1400 }, Wn), Ul = c.e({ deceleration: 20, maxSpeed: 1400 }, Wn), Gl = c.e({ deceleration: 1e3, maxSpeed: 360 }, Wn), $l = c.e({ deceleration: 1e3, maxSpeed: 90 }, Wn), ql = c.e({ deceleration: 1e3, maxSpeed: 360 }, Wn);
        class Wl {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: He.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, i = He.now();
            for (; e.length > 0 && i - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: u } of this._inertiaBuffer) i.zoom += u.zoomDelta || 0, i.bearing += u.bearingDelta || 0, i.pitch += u.pitchDelta || 0, i.roll += u.rollDelta || 0, u.panDelta && i.pan._add(u.panDelta), u.around && (i.around = u.around), u.pinchAround && (i.pinchAround = u.pinchAround);
            const a = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {};
            if (i.pan.mag()) {
              const u = Hn(i.pan.mag(), a, c.e({}, Zl, e || {})), f = i.pan.mult(u.amount / i.pan.mag()), _ = this._map.cameraHelper.handlePanInertia(f, this._map.transform);
              o.center = _.easingCenter, o.offset = _.easingOffset, Vr(o, u);
            }
            if (i.zoom) {
              const u = Hn(i.zoom, a, Ul);
              o.zoom = this._map.transform.zoom + u.amount, Vr(o, u);
            }
            if (i.bearing) {
              const u = Hn(i.bearing, a, Gl);
              o.bearing = this._map.transform.bearing + c.ad(u.amount, -179, 179), Vr(o, u);
            }
            if (i.pitch) {
              const u = Hn(i.pitch, a, $l);
              o.pitch = this._map.transform.pitch + u.amount, Vr(o, u);
            }
            if (i.roll) {
              const u = Hn(i.roll, a, ql);
              o.roll = this._map.transform.roll + c.ad(u.amount, -179, 179), Vr(o, u);
            }
            if (o.zoom || o.bearing) {
              const u = i.pinchAround === void 0 ? i.around : i.pinchAround;
              o.around = u ? this._map.unproject(u) : this._map.getCenter();
            }
            return this.clear(), c.e(o, { noMoveStart: !0 });
          }
        }
        function Vr(h, e) {
          (!h.duration || h.duration < e.duration) && (h.duration = e.duration, h.easing = e.easing);
        }
        function Hn(h, e, i) {
          const { maxSpeed: a, linearity: o, deceleration: u } = i, f = c.ad(h * o / (e / 1e3), -a, a), _ = Math.abs(f) / (u * o);
          return { easing: i.easing, duration: 1e3 * _, amount: f * (_ / 2) };
        }
        class Ct extends c.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, a, o = {}) {
            const u = ue.mousePos(i.getCanvas(), a), f = i.unproject(u);
            super(e, c.e({ point: u, lngLat: f, originalEvent: a }, o)), this._defaultPrevented = !1, this.target = i;
          }
        }
        class bi extends c.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, a) {
            const o = e === "touchend" ? a.changedTouches : a.touches, u = ue.touchPos(i.getCanvasContainer(), o), f = u.map((y) => i.unproject(y)), _ = u.reduce((y, v, T, S) => y.add(v.div(S.length)), new c.P(0, 0));
            super(e, { points: u, point: _, lngLats: f, lngLat: i.unproject(_), originalEvent: a }), this._defaultPrevented = !1;
          }
        }
        class Ao extends c.l {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, i, a) {
            super(e, { originalEvent: a }), this._defaultPrevented = !1;
          }
        }
        class lr {
          constructor(e, i) {
            this._map = e, this._clickTolerance = i.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Ao(e.type, this._map, e));
          }
          mousedown(e, i) {
            return this._mousedownPos = i, this._firePreventable(new Ct(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Ct(e.type, this._map, e));
          }
          click(e, i) {
            this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new Ct(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Ct(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Ct(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Ct(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new bi(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new bi(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new bi(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new bi(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Xn {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Ct(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ct("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Ct(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ts {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(c.P.convert(e), this._map.terrain);
          }
        }
        class Hl {
          constructor(e, i) {
            this._map = e, this._tr = new Ts(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(e, i) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (ue.disableDrag(), this._startPos = this._lastPos = i, this._active = !0);
          }
          mousemoveWindow(e, i) {
            if (!this._active) return;
            const a = i;
            if (this._lastPos.equals(a) || !this._box && a.dist(this._startPos) < this._clickTolerance) return;
            const o = this._startPos;
            this._lastPos = a, this._box || (this._box = ue.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const u = Math.min(o.x, a.x), f = Math.max(o.x, a.x), _ = Math.min(o.y, a.y), y = Math.max(o.y, a.y);
            ue.setTransform(this._box, `translate(${u}px,${_}px)`), this._box.style.width = f - u + "px", this._box.style.height = y - _ + "px";
          }
          mouseupWindow(e, i) {
            if (!this._active || e.button !== 0) return;
            const a = this._startPos, o = i;
            if (this.reset(), ue.suppressClick(), a.x !== o.x || a.y !== o.y) return this._map.fire(new c.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (u) => u.fitScreenCoordinates(a, o, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (ue.remove(this._box), this._box = null), ue.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, i) {
            return this._map.fire(new c.l(e, { originalEvent: i }));
          }
        }
        function zo(h, e) {
          if (h.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`);
          const i = {};
          for (let a = 0; a < h.length; a++) i[h[a].identifier] = e[a];
          return i;
        }
        class qc {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(e, i, a) {
            (this.centroid || a.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), a.length === this.numTouches && (this.centroid = function(o) {
              const u = new c.P(0, 0);
              for (const f of o) u._add(f);
              return u.div(o.length);
            }(i), this.touches = zo(a, i)));
          }
          touchmove(e, i, a) {
            if (this.aborted || !this.centroid) return;
            const o = zo(a, i);
            for (const u in this.touches) {
              const f = o[u];
              (!f || f.dist(this.touches[u]) > 30) && (this.aborted = !0);
            }
          }
          touchend(e, i, a) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), a.length === 0) {
              const o = !this.aborted && this.centroid;
              if (this.reset(), o) return o;
            }
          }
        }
        class pa {
          constructor(e) {
            this.singleTap = new qc(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, i, a) {
            this.singleTap.touchstart(e, i, a);
          }
          touchmove(e, i, a) {
            this.singleTap.touchmove(e, i, a);
          }
          touchend(e, i, a) {
            const o = this.singleTap.touchend(e, i, a);
            if (o) {
              const u = e.timeStamp - this.lastTime < 500, f = !this.lastTap || this.lastTap.dist(o) < 30;
              if (u && f || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
            }
          }
        }
        class Ps {
          constructor(e) {
            this._tr = new Ts(e), this._zoomIn = new pa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new pa({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, i, a) {
            this._zoomIn.touchstart(e, i, a), this._zoomOut.touchstart(e, i, a);
          }
          touchmove(e, i, a) {
            this._zoomIn.touchmove(e, i, a), this._zoomOut.touchmove(e, i, a);
          }
          touchend(e, i, a) {
            const o = this._zoomIn.touchend(e, i, a), u = this._zoomOut.touchend(e, i, a), f = this._tr;
            return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (_) => _.easeTo({ duration: 300, zoom: f.zoom + 1, around: f.unproject(o) }, { originalEvent: e }) }) : u ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (_) => _.easeTo({ duration: 300, zoom: f.zoom - 1, around: f.unproject(u) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ii {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const i = this._moveFunction(...e);
            if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i;
          }
          dragStart(e, i) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(e, i) {
            if (!this.isEnabled()) return;
            const a = this._lastPoint;
            if (!a) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const o = Array.isArray(i) ? i[0] : i;
            return !this._moved && o.dist(a) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = o, this._move(a, o));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && ue.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Ae = { 0: 1, 2: 2 };
        class Kn {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const i = ue.mouseButton(e);
            this._eventButton = i;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !function(i, a) {
              const o = Ae[a];
              return i.buttons === void 0 || (i.buttons & o) !== o;
            }(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return ue.mouseButton(e) === this._eventButton;
          }
        }
        class ko {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class Xl {
          constructor(e = new Kn({ checkCorrectEvent: () => !0 }), i = new ko()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i;
          }
          _executeRelevantHandler(e, i, a) {
            return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? a(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.startMove(i), (i) => this.oneFingerTouchMoveStateManager.startMove(i));
          }
          endMove(e) {
            this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.endMove(i), (i) => this.oneFingerTouchMoveStateManager.endMove(i));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidStartEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidStartEvent(i));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidMoveEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, (i) => this.mouseMoveStateManager.isValidEndEvent(i), (i) => this.oneFingerTouchMoveStateManager.isValidEndEvent(i));
          }
        }
        const Nr = (h) => {
          h.mousedown = h.dragStart, h.mousemoveWindow = h.dragMove, h.mouseup = h.dragEnd, h.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class Ss {
          constructor(e, i) {
            this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new c.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, i, a) {
            return this._calculateTransform(e, i, a);
          }
          touchmove(e, i, a) {
            if (this._active) {
              if (!this._shouldBePrevented(a.length)) return e.preventDefault(), this._calculateTransform(e, i, a);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, i, a) {
            this._calculateTransform(e, i, a), this._active && this._shouldBePrevented(a.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, i, a) {
            a.length > 0 && (this._active = !0);
            const o = zo(a, i), u = new c.P(0, 0), f = new c.P(0, 0);
            let _ = 0;
            for (const v in o) {
              const T = o[v], S = this._touches[v];
              S && (u._add(T), f._add(T.sub(S)), _++, o[v] = T);
            }
            if (this._touches = o, this._shouldBePrevented(_) || !f.mag()) return;
            const y = f.div(_);
            return this._sum._add(y), this._sum.mag() < this._clickTolerance ? void 0 : { around: u.div(_), panDelta: y };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class fa {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(e, i, a) {
            this._firstTwoTouches || a.length < 2 || (this._firstTwoTouches = [a[0].identifier, a[1].identifier], this._start([i[0], i[1]]));
          }
          touchmove(e, i, a) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [o, u] = this._firstTwoTouches, f = Ye(a, i, o), _ = Ye(a, i, u);
            if (!f || !_) return;
            const y = this._aroundCenter ? null : f.add(_).div(2);
            return this._move([f, _], y, e);
          }
          touchend(e, i, a) {
            if (!this._firstTwoTouches) return;
            const [o, u] = this._firstTwoTouches, f = Ye(a, i, o), _ = Ye(a, i, u);
            f && _ || (this._active && ue.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Ye(h, e, i) {
          for (let a = 0; a < h.length; a++) if (h[a].identifier === i) return e[a];
        }
        function ma(h, e) {
          return Math.log(h / e) / Math.LN2;
        }
        class Kl extends fa {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, i) {
            const a = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(ma(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: ma(this._distance, a), pinchAround: i };
          }
        }
        function _a(h, e) {
          return 180 * h.angleWith(e) / Math.PI;
        }
        class Jl extends fa {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, i, a) {
            const o = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: _a(this._vector, o), pinchAround: i };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const i = 25 / (Math.PI * this._minDiameter) * 360, a = _a(e, this._startVector);
            return Math.abs(a) < i;
          }
        }
        function Do(h) {
          return Math.abs(h.y) > Math.abs(h.x);
        }
        class Ro extends fa {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, i, a) {
            super.touchstart(e, i, a), this._currentTouchCount = a.length;
          }
          _start(e) {
            this._lastPoints = e, Do(e[0].sub(e[1])) && (this._valid = !1);
          }
          _move(e, i, a) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const o = e[0].sub(this._lastPoints[0]), u = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(o, u, a.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (o.y + u.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, i, a) {
            if (this._valid !== void 0) return this._valid;
            const o = e.mag() >= 2, u = i.mag() >= 2;
            if (!o && !u) return;
            if (!o || !u) return this._firstMove === void 0 && (this._firstMove = a), a - this._firstMove < 100 && void 0;
            const f = e.y > 0 == i.y > 0;
            return Do(e) && Do(i) && f;
          }
        }
        const Lo = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Bo {
          constructor(e) {
            this._tr = new Ts(e);
            const i = Lo;
            this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let i = 0, a = 0, o = 0, u = 0, f = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i = 1;
                break;
              case 189:
              case 109:
              case 173:
                i = -1;
                break;
              case 37:
                e.shiftKey ? a = -1 : (e.preventDefault(), u = -1);
                break;
              case 39:
                e.shiftKey ? a = 1 : (e.preventDefault(), u = 1);
                break;
              case 38:
                e.shiftKey ? o = 1 : (e.preventDefault(), f = -1);
                break;
              case 40:
                e.shiftKey ? o = -1 : (e.preventDefault(), f = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (a = 0, o = 0), { cameraAnimation: (_) => {
              const y = this._tr;
              _.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Wc, zoom: i ? Math.round(y.zoom) + i * (e.shiftKey ? 2 : 1) : y.zoom, bearing: y.bearing + a * this._bearingStep, pitch: y.pitch + o * this._pitchStep, offset: [-u * this._panStep, -f * this._panStep], center: y.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Wc(h) {
          return h * (2 - h);
        }
        const Fo = 4.000244140625;
        class Yl {
          constructor(e, i) {
            this._onTimeout = (a) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(a);
            }, this._map = e, this._tr = new Ts(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const a = He.now(), o = a - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = a, i !== 0 && i % Fo == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : o > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(o * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i = ue.mousePos(this._map.getCanvas(), e), a = this._tr;
            this._aroundPoint = this._aroundCenter ? a.transform.locationToScreenPoint(c.Q.convert(a.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const _ = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += _), typeof this._targetZoom == "number" && (this._targetZoom += _);
            }
            if (this._delta !== 0) {
              const _ = this._type === "wheel" && Math.abs(this._delta) > Fo ? this._wheelZoomRate : this._defaultZoomRate;
              let y = 2 / (1 + Math.exp(-Math.abs(this._delta * _)));
              this._delta < 0 && y !== 0 && (y = 1 / y);
              const v = typeof this._targetZoom != "number" ? e.scale : c.aH(this._targetZoom);
              this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, c.aa(v * y))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, a = this._startZoom, o = this._easing;
            let u, f = !1;
            if (this._type === "wheel" && a && o) {
              const _ = He.now() - this._lastWheelEventTime, y = Math.min((_ + 5) / 200, 1), v = o(y);
              u = c.B.number(a, i, v), y < 1 ? this._frameId || (this._frameId = !0) : f = !0;
            } else u = i, f = !0;
            return this._active = !0, f && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = u, { noInertia: !0, needsRenderFrame: !f, zoomDelta: u - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let i = c.ca;
            if (this._prevEase) {
              const a = this._prevEase, o = (He.now() - a.start) / a.duration, u = a.easing(o + 0.01) - a.easing(o), f = 0.27 / Math.sqrt(u * u + 1e-4) * 0.01, _ = Math.sqrt(0.0729 - f * f);
              i = c.c8(f, _, 0.25, 1);
            }
            return this._prevEase = { start: He.now(), duration: e, easing: i }, i;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Ql {
          constructor(e, i) {
            this._clickZoom = e, this._tapZoom = i;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Zr {
          constructor(e) {
            this._tr = new Ts(e), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(e, i) {
            return e.preventDefault(), { cameraAnimation: (a) => {
              a.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(i) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Tt {
          constructor() {
            this._tap = new pa({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, i, a) {
            if (!this._swipePoint) if (this._tapTime) {
              const o = i[0], u = e.timeStamp - this._tapTime < 500, f = this._tapPoint.dist(o) < 30;
              u && f ? a.length > 0 && (this._swipePoint = o, this._swipeTouch = a[0].identifier) : this.reset();
            } else this._tap.touchstart(e, i, a);
          }
          touchmove(e, i, a) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (a[0].identifier !== this._swipeTouch) return;
                const o = i[0], u = o.y - this._swipePoint.y;
                return this._swipePoint = o, e.preventDefault(), this._active = !0, { zoomDelta: u / 128 };
              }
            } else this._tap.touchmove(e, i, a);
          }
          touchend(e, i, a) {
            if (this._tapTime) this._swipePoint && a.length === 0 && this.reset();
            else {
              const o = this._tap.touchend(e, i, a);
              o && (this._tapTime = e.timeStamp, this._tapPoint = o);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ms {
          constructor(e, i, a) {
            this._el = e, this._mousePan = i, this._touchPan = a;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class ga {
          constructor(e, i, a, o) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = a, this._mouseRoll = o;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Oo {
          constructor(e, i, a, o) {
            this._el = e, this._touchZoom = i, this._touchRotate = a, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class jo {
          constructor(e, i) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = ue.create("div", "maplibregl-cooperative-gesture-screen", e);
            let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const a = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), o = document.createElement("div");
            o.className = "maplibregl-desktop-message", o.textContent = i, this._container.appendChild(o);
            const u = document.createElement("div");
            u.className = "maplibregl-mobile-message", u.textContent = a, this._container.appendChild(u), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (ue.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, i) {
            this._enabled && (this._map.fire(new c.l("cooperativegestureprevented", { gestureType: e, originalEvent: i })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const Is = (h) => h.zoom || h.drag || h.roll || h.pitch || h.rotate;
        class Hc extends c.l {
        }
        function Zi(h) {
          return h.panDelta && h.panDelta.mag() || h.zoomDelta || h.bearingDelta || h.pitchDelta || h.rollDelta;
        }
        class ya {
          constructor(e, i) {
            this.handleWindowEvent = (o) => {
              this.handleEvent(o, `${o.type}Window`);
            }, this.handleEvent = (o, u) => {
              if (o.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const f = o.type === "renderFrame" ? void 0 : o, _ = { needsRenderFrame: !1 }, y = {}, v = {}, T = o.touches, S = T ? this._getMapTouches(T) : void 0, M = S ? ue.touchPos(this._map.getCanvas(), S) : ue.mousePos(this._map.getCanvas(), o);
              for (const { handlerName: V, handler: j, allowed: N } of this._handlers) {
                if (!j.isEnabled()) continue;
                let G;
                this._blockedByActive(v, N, V) ? j.reset() : j[u || o.type] && (G = j[u || o.type](o, M, S), this.mergeHandlerResult(_, y, G, V, f), G && G.needsRenderFrame && this._triggerRenderFrame()), (G || j.isActive()) && (v[V] = j);
              }
              const k = {};
              for (const V in this._previousActiveHandlers) v[V] || (k[V] = f);
              this._previousActiveHandlers = v, (Object.keys(k).length || Zi(_)) && (this._changes.push([_, y, k]), this._triggerRenderFrame()), (Object.keys(v).length || Zi(_)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: R } = _;
              R && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], R(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Wl(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i);
            const a = this._el;
            this._listeners = [[a, "touchstart", { passive: !0 }], [a, "touchmove", { passive: !1 }], [a, "touchend", void 0], [a, "touchcancel", void 0], [a, "mousedown", void 0], [a, "mousemove", void 0], [a, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [a, "mouseover", void 0], [a, "mouseout", void 0], [a, "dblclick", void 0], [a, "click", void 0], [a, "keydown", { capture: !1 }], [a, "keyup", void 0], [a, "wheel", { passive: !1 }], [a, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [o, u, f] of this._listeners) ue.addEventListener(o, u, o === document ? this.handleWindowEvent : this.handleEvent, f);
          }
          destroy() {
            for (const [e, i, a] of this._listeners) ue.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, a);
          }
          _addDefaultHandlers(e) {
            const i = this._map, a = i.getCanvasContainer();
            this._add("mapEvent", new lr(i, e));
            const o = i.boxZoom = new Hl(i, e);
            this._add("boxZoom", o), e.interactive && e.boxZoom && o.enable();
            const u = i.cooperativeGestures = new jo(i, e.cooperativeGestures);
            this._add("cooperativeGestures", u), e.cooperativeGestures && u.enable();
            const f = new Ps(i), _ = new Zr(i);
            i.doubleClickZoom = new Ql(_, f), this._add("tapZoom", f), this._add("clickZoom", _), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
            const y = new Tt();
            this._add("tapDragZoom", y);
            const v = i.touchPitch = new Ro(i);
            this._add("touchPitch", v), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
            const T = () => i.project(i.getCenter()), S = function({ enable: H, clickTolerance: K, aroundCenter: Q = !0, minPixelCenterThreshold: J = 100, rotateDegreesPerPixelMoved: se = 0.8 }, oe) {
              const fe = new Kn({ checkCorrectEvent: (_e) => ue.mouseButton(_e) === 0 && _e.ctrlKey || ue.mouseButton(_e) === 2 && !_e.ctrlKey });
              return new Ii({ clickTolerance: K, move: (_e, pe) => {
                const Ie = oe();
                if (Q && Math.abs(Ie.y - _e.y) > J) return { bearingDelta: c.c9(new c.P(_e.x, pe.y), pe, Ie) };
                let Se = (pe.x - _e.x) * se;
                return Q && pe.y < Ie.y && (Se = -Se), { bearingDelta: Se };
              }, moveStateManager: fe, enable: H, assignEvents: Nr });
            }(e, T), M = function({ enable: H, clickTolerance: K, pitchDegreesPerPixelMoved: Q = -0.5 }) {
              const J = new Kn({ checkCorrectEvent: (se) => ue.mouseButton(se) === 0 && se.ctrlKey || ue.mouseButton(se) === 2 });
              return new Ii({ clickTolerance: K, move: (se, oe) => ({ pitchDelta: (oe.y - se.y) * Q }), moveStateManager: J, enable: H, assignEvents: Nr });
            }(e), k = function({ enable: H, clickTolerance: K, rollDegreesPerPixelMoved: Q = 0.3 }, J) {
              const se = new Kn({ checkCorrectEvent: (oe) => ue.mouseButton(oe) === 2 && oe.ctrlKey });
              return new Ii({ clickTolerance: K, move: (oe, fe) => {
                const _e = J();
                let pe = (fe.x - oe.x) * Q;
                return fe.y < _e.y && (pe = -pe), { rollDelta: pe };
              }, moveStateManager: se, enable: H, assignEvents: Nr });
            }(e, T);
            i.dragRotate = new ga(e, S, M, k), this._add("mouseRotate", S, ["mousePitch"]), this._add("mousePitch", M, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", k, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable();
            const R = function({ enable: H, clickTolerance: K }) {
              const Q = new Kn({ checkCorrectEvent: (J) => ue.mouseButton(J) === 0 && !J.ctrlKey });
              return new Ii({ clickTolerance: K, move: (J, se) => ({ around: se, panDelta: se.sub(J) }), activateOnStart: !0, moveStateManager: Q, enable: H, assignEvents: Nr });
            }(e), V = new Ss(e, i);
            i.dragPan = new Ms(a, R, V), this._add("mousePan", R), this._add("touchPan", V, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
            const j = new Jl(), N = new Kl();
            i.touchZoomRotate = new Oo(a, N, j, y), this._add("touchRotate", j, ["touchPan", "touchZoom"]), this._add("touchZoom", N, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate);
            const G = i.scrollZoom = new Yl(i, () => this._triggerRenderFrame());
            this._add("scrollZoom", G, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
            const W = i.keyboard = new Bo(i);
            this._add("keyboard", W), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new Xn(i));
          }
          _add(e, i, a) {
            this._handlers.push({ handlerName: e, handler: i, allowed: a }), this._handlersById[e] = i;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: i } of this._handlers) i.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Is(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, i, a) {
            for (const o in e) if (o !== a && (!i || i.indexOf(o) < 0)) return !0;
            return !1;
          }
          _getMapTouches(e) {
            const i = [];
            for (const a of e) this._el.contains(a.target) && i.push(a);
            return i;
          }
          mergeHandlerResult(e, i, a, o, u) {
            if (!a) return;
            c.e(e, a);
            const f = { handlerName: o, originalEvent: a.originalEvent || u };
            a.zoomDelta !== void 0 && (i.zoom = f), a.panDelta !== void 0 && (i.drag = f), a.rollDelta !== void 0 && (i.roll = f), a.pitchDelta !== void 0 && (i.pitch = f), a.bearingDelta !== void 0 && (i.rotate = f);
          }
          _applyChanges() {
            const e = {}, i = {}, a = {};
            for (const [o, u, f] of this._changes) o.panDelta && (e.panDelta = (e.panDelta || new c.P(0, 0))._add(o.panDelta)), o.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + o.zoomDelta), o.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + o.bearingDelta), o.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + o.pitchDelta), o.rollDelta && (e.rollDelta = (e.rollDelta || 0) + o.rollDelta), o.around !== void 0 && (e.around = o.around), o.pinchAround !== void 0 && (e.pinchAround = o.pinchAround), o.noInertia && (e.noInertia = o.noInertia), c.e(i, u), c.e(a, f);
            this._updateMapTransform(e, i, a), this._changes = [];
          }
          _updateMapTransform(e, i, a) {
            const o = this._map, u = o._getTransformForUpdate(), f = o.terrain;
            if (!(Zi(e) || f && this._terrainMovement)) return this._fireEvents(i, a, !0);
            o._stop(!0);
            let { panDelta: _, zoomDelta: y, bearingDelta: v, pitchDelta: T, rollDelta: S, around: M, pinchAround: k } = e;
            k !== void 0 && (M = k), M = M || o.transform.centerPoint, f && !u.isPointOnMapSurface(M) && (M = u.centerPoint);
            const R = { panDelta: _, zoomDelta: y, rollDelta: S, pitchDelta: T, bearingDelta: v, around: M };
            this._map.cameraHelper.useGlobeControls && !u.isPointOnMapSurface(M) && (M = u.centerPoint);
            const V = M.distSqr(u.centerPoint) < 0.01 ? u.center : u.screenPointToLocation(_ ? M.sub(_) : M);
            f ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(R, u), this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? u.setCenter(u.screenPointToLocation(u.centerPoint.sub(_))) : this._map.cameraHelper.handleMapControlsPan(R, u, V) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(R, u, V))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(R, u), this._map.cameraHelper.handleMapControlsPan(R, u, V)), o._applyUpdatedTransform(u), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, a, !0);
          }
          _fireEvents(e, i, a) {
            const o = Is(this._eventsInProgress), u = Is(e), f = {};
            for (const S in e) {
              const { originalEvent: M } = e[S];
              this._eventsInProgress[S] || (f[`${S}start`] = M), this._eventsInProgress[S] = e[S];
            }
            !o && u && this._fireEvent("movestart", u.originalEvent);
            for (const S in f) this._fireEvent(S, f[S]);
            u && this._fireEvent("move", u.originalEvent);
            for (const S in e) {
              const { originalEvent: M } = e[S];
              this._fireEvent(S, M);
            }
            const _ = {};
            let y;
            for (const S in this._eventsInProgress) {
              const { handlerName: M, originalEvent: k } = this._eventsInProgress[S];
              this._handlersById[M].isActive() || (delete this._eventsInProgress[S], y = i[M] || k, _[`${S}end`] = y);
            }
            for (const S in _) this._fireEvent(S, _[S]);
            const v = Is(this._eventsInProgress), T = (o || u) && !v;
            if (T && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const S = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && S.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(S);
            }
            if (a && T) {
              this._updatingCamera = !0;
              const S = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), M = (k) => k !== 0 && -this._bearingSnap < k && k < this._bearingSnap;
              !S || !S.essential && He.prefersReducedMotion ? (this._map.fire(new c.l("moveend", { originalEvent: y })), M(this._map.getBearing()) && this._map.resetNorth()) : (M(S.bearing || this._map.getBearing()) && (S.bearing = 0), S.freezeElevation = !0, this._map.easeTo(S, { originalEvent: y })), this._updatingCamera = !1;
            }
          }
          _fireEvent(e, i) {
            this._map.fire(new c.l(e, i ? { originalEvent: i } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
              delete this._frameId, this.handleEvent(new Hc("renderFrame", { timeStamp: e })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Fe extends c.E {
          constructor(e, i, a) {
            super(), this._renderFrameCallback = () => {
              const o = Math.min((He.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(o)), o < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = a.bearingSnap, this.cameraHelper = i, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(e, i) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = i;
          }
          getCenter() {
            return new c.Q(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, i) {
            return this.jumpTo({ center: e }, i);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, i) {
            return this.jumpTo({ elevation: e }, i), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, i, a) {
            return e = c.P.convert(e).mult(-1), this.panTo(this.transform.center, c.e({ offset: e }, i), a);
          }
          panTo(e, i, a) {
            return this.easeTo(c.e({ center: e }, i), a);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, i) {
            return this.jumpTo({ zoom: e }, i), this;
          }
          zoomTo(e, i, a) {
            return this.easeTo(c.e({ zoom: e }, i), a);
          }
          zoomIn(e, i) {
            return this.zoomTo(this.getZoom() + 1, e, i), this;
          }
          zoomOut(e, i) {
            return this.zoomTo(this.getZoom() - 1, e, i), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, i) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)).fire(new c.l("moveend", i))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, i) {
            return this.jumpTo({ bearing: e }, i), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, i) {
            return this.jumpTo({ padding: e }, i), this;
          }
          rotateTo(e, i, a) {
            return this.easeTo(c.e({ bearing: e }, i), a);
          }
          resetNorth(e, i) {
            return this.rotateTo(0, c.e({ duration: 1e3 }, e), i), this;
          }
          resetNorthPitch(e, i) {
            return this.easeTo(c.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), i), this;
          }
          snapToNorth(e, i) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, i) {
            return this.jumpTo({ pitch: e }, i), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, i) {
            return this.jumpTo({ roll: e }, i), this;
          }
          cameraForBounds(e, i) {
            e = Dt.convert(e).adjustAntiMeridian();
            const a = i && i.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), a, i);
          }
          _cameraForBoxAndBearing(e, i, a, o) {
            const u = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (o = c.e({ padding: u, offset: [0, 0], maxZoom: this.transform.maxZoom }, o)).padding == "number") {
              const v = o.padding;
              o.padding = { top: v, bottom: v, right: v, left: v };
            }
            const f = c.e(u, o.padding);
            o.padding = f;
            const _ = this.transform, y = new Dt(e, i);
            return this.cameraHelper.cameraForBoxAndBearing(o, f, y, a, _);
          }
          fitBounds(e, i, a) {
            return this._fitInternal(this.cameraForBounds(e, i), i, a);
          }
          fitScreenCoordinates(e, i, a, o, u) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(c.P.convert(e)), this.transform.screenPointToLocation(c.P.convert(i)), a, o), o, u);
          }
          _fitInternal(e, i, a) {
            return e ? (delete (i = c.e(e, i)).padding, i.linear ? this.easeTo(i, a) : this.flyTo(i, a)) : this;
          }
          jumpTo(e, i) {
            this.stop();
            const a = this._getTransformForUpdate();
            let o = !1, u = !1, f = !1;
            const _ = a.zoom;
            this.cameraHelper.handleJumpToCenterZoom(a, e);
            const y = a.zoom !== _;
            return "elevation" in e && a.elevation !== +e.elevation && a.setElevation(+e.elevation), "bearing" in e && a.bearing !== +e.bearing && (o = !0, a.setBearing(+e.bearing)), "pitch" in e && a.pitch !== +e.pitch && (u = !0, a.setPitch(+e.pitch)), "roll" in e && a.roll !== +e.roll && (f = !0, a.setRoll(+e.roll)), e.padding == null || a.isPaddingEqual(e.padding) || a.setPadding(e.padding), this._applyUpdatedTransform(a), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)), y && this.fire(new c.l("zoomstart", i)).fire(new c.l("zoom", i)).fire(new c.l("zoomend", i)), o && this.fire(new c.l("rotatestart", i)).fire(new c.l("rotate", i)).fire(new c.l("rotateend", i)), u && this.fire(new c.l("pitchstart", i)).fire(new c.l("pitch", i)).fire(new c.l("pitchend", i)), f && this.fire(new c.l("rollstart", i)).fire(new c.l("roll", i)).fire(new c.l("rollend", i)), this.fire(new c.l("moveend", i));
          }
          calculateCameraOptionsFromTo(e, i, a, o = 0) {
            const u = c.$.fromLngLat(e, i), f = c.$.fromLngLat(a, o), _ = f.x - u.x, y = f.y - u.y, v = f.z - u.z, T = Math.hypot(_, y, v);
            if (T === 0) throw new Error("Can't calculate camera options with same From and To");
            const S = Math.hypot(_, y), M = c.aa(this.transform.cameraToCenterDistance / T / this.transform.tileSize), k = 180 * Math.atan2(_, -y) / Math.PI;
            let R = 180 * Math.acos(S / T) / Math.PI;
            return R = v < 0 ? 90 - R : 90 + R, { center: f.toLngLat(), elevation: o, zoom: M, pitch: R, bearing: k };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, i, a, o, u) {
            const f = this.transform.calculateCenterFromCameraLngLatAlt(e, i, a, o);
            return { center: f.center, elevation: f.elevation, zoom: f.zoom, bearing: a, pitch: o, roll: u };
          }
          easeTo(e, i) {
            this._stop(!1, e.easeId), ((e = c.e({ offset: [0, 0], duration: 500, easing: c.ca }, e)).animate === !1 || !e.essential && He.prefersReducedMotion) && (e.duration = 0);
            const a = this._getTransformForUpdate(), o = this.getBearing(), u = a.pitch, f = a.roll, _ = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, y = "pitch" in e ? +e.pitch : u, v = "roll" in e ? this._normalizeBearing(e.roll, f) : f, T = "padding" in e ? e.padding : a.padding, S = c.P.convert(e.offset);
            let M, k;
            e.around && (M = c.Q.convert(e.around), k = a.locationToScreenPoint(M));
            const R = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, V = this.cameraHelper.handleEaseTo(a, { bearing: _, pitch: y, roll: v, padding: T, around: M, aroundPoint: k, offsetAsPoint: S, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || o !== _, this._pitching = this._pitching || y !== u, this._rolling = this._rolling || v !== f, this._padding = !a.isPaddingEqual(T), this._zooming = this._zooming || V.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, R), this.terrain && this._prepareElevation(V.elevationCenter), this._ease((j) => {
              V.easeFunc(j), this.terrain && !e.freezeElevation && this._updateElevation(j), this._applyUpdatedTransform(a), this._fireMoveEvents(i);
            }, (j) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, j);
            }, e), this;
          }
          _prepareEase(e, i, a = {}) {
            this._moving = !0, i || a.moving || this.fire(new c.l("movestart", e)), this._zooming && !a.zooming && this.fire(new c.l("zoomstart", e)), this._rotating && !a.rotating && this.fire(new c.l("rotatestart", e)), this._pitching && !a.pitching && this.fire(new c.l("pitchstart", e)), this._rolling && !a.rolling && this.fire(new c.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(e) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && i !== this._elevationTarget) {
              const a = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (a - (i - (a * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i;
            }
            this.transform.setElevation(c.B.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const i = e.getCameraLngLat(), a = e.getCameraAltitude(), o = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
            if (a < o) {
              const u = this.calculateCameraOptionsFromTo(i, o, e.center, e.elevation);
              return { pitch: u.pitch, zoom: u.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const i = [];
            if (i.push((o) => this._elevateCameraIfInsideTerrain(o)), this.transformCameraUpdate && i.push((o) => this.transformCameraUpdate(o)), !i.length) return;
            const a = e.clone();
            for (const o of i) {
              const u = a.clone(), { center: f, zoom: _, roll: y, pitch: v, bearing: T, elevation: S } = o(u);
              f && u.setCenter(f), S !== void 0 && u.setElevation(S), _ !== void 0 && u.setZoom(_), y !== void 0 && u.setRoll(y), v !== void 0 && u.setPitch(v), T !== void 0 && u.setBearing(T), a.apply(u);
            }
            this.transform.apply(a);
          }
          _fireMoveEvents(e) {
            this.fire(new c.l("move", e)), this._zooming && this.fire(new c.l("zoom", e)), this._rotating && this.fire(new c.l("rotate", e)), this._pitching && this.fire(new c.l("pitch", e)), this._rolling && this.fire(new c.l("roll", e));
          }
          _afterEase(e, i) {
            if (this._easeId && i && this._easeId === i) return;
            delete this._easeId;
            const a = this._zooming, o = this._rotating, u = this._pitching, f = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, a && this.fire(new c.l("zoomend", e)), o && this.fire(new c.l("rotateend", e)), u && this.fire(new c.l("pitchend", e)), f && this.fire(new c.l("rollend", e)), this.fire(new c.l("moveend", e));
          }
          flyTo(e, i) {
            if (!e.essential && He.prefersReducedMotion) {
              const pe = c.O(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(pe, i);
            }
            this.stop(), e = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.ca }, e);
            const a = this._getTransformForUpdate(), o = a.bearing, u = a.pitch, f = a.roll, _ = a.padding, y = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, v = "pitch" in e ? +e.pitch : u, T = "roll" in e ? this._normalizeBearing(e.roll, f) : f, S = "padding" in e ? e.padding : a.padding, M = c.P.convert(e.offset);
            let k = a.centerPoint.add(M);
            const R = a.screenPointToLocation(k), V = this.cameraHelper.handleFlyTo(a, { bearing: y, pitch: v, roll: T, padding: S, locationAtOffset: R, offsetAsPoint: M, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let j = e.curve;
            const N = Math.max(a.width, a.height), G = N / V.scaleOfZoom, W = V.pixelPathLength;
            typeof V.scaleOfMinZoom == "number" && (j = Math.sqrt(N / V.scaleOfMinZoom / W * 2));
            const H = j * j;
            function K(pe) {
              const Ie = (G * G - N * N + (pe ? -1 : 1) * H * H * W * W) / (2 * (pe ? G : N) * H * W);
              return Math.log(Math.sqrt(Ie * Ie + 1) - Ie);
            }
            function Q(pe) {
              return (Math.exp(pe) - Math.exp(-pe)) / 2;
            }
            function J(pe) {
              return (Math.exp(pe) + Math.exp(-pe)) / 2;
            }
            const se = K(!1);
            let oe = function(pe) {
              return J(se) / J(se + j * pe);
            }, fe = function(pe) {
              return N * ((J(se) * (Q(Ie = se + j * pe) / J(Ie)) - Q(se)) / H) / W;
              var Ie;
            }, _e = (K(!0) - se) / j;
            if (Math.abs(W) < 2e-6 || !isFinite(_e)) {
              if (Math.abs(N - G) < 1e-6) return this.easeTo(e, i);
              const pe = G < N ? -1 : 1;
              _e = Math.abs(Math.log(G / N)) / j, fe = () => 0, oe = (Ie) => Math.exp(pe * j * Ie);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * _e / ("screenSpeed" in e ? +e.screenSpeed / j : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = o !== y, this._pitching = v !== u, this._rolling = T !== f, this._padding = !a.isPaddingEqual(S), this._prepareEase(i, !1), this.terrain && this._prepareElevation(V.targetCenter), this._ease((pe) => {
              const Ie = pe * _e, Se = 1 / oe(Ie), be = fe(Ie);
              this._rotating && a.setBearing(c.B.number(o, y, pe)), this._pitching && a.setPitch(c.B.number(u, v, pe)), this._rolling && a.setRoll(c.B.number(f, T, pe)), this._padding && (a.interpolatePadding(_, S, pe), k = a.centerPoint.add(M)), V.easeFunc(pe, Se, be, k), this.terrain && !e.freezeElevation && this._updateElevation(pe), this._applyUpdatedTransform(a), this._fireMoveEvents(i);
            }, () => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i);
            }, e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, i) {
            var a;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const o = this._onEaseEnd;
              delete this._onEaseEnd, o.call(this, i);
            }
            return e || (a = this.handlers) === null || a === void 0 || a.stop(!1), this;
          }
          _ease(e, i, a) {
            a.animate === !1 || a.duration === 0 ? (e(1), i()) : (this._easeStart = He.now(), this._easeOptions = a, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, i) {
            e = c.aK(e, -180, 180);
            const a = Math.abs(e - i);
            return Math.abs(e - 360 - i) < a && (e -= 360), Math.abs(e + 360 - i) < a && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(c.Q.convert(e), this.transform.tileZoom) : null;
          }
        }
        const Ge = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Cs {
          constructor(e = Ge) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (i) => {
              !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = ue.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = ue.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = ue.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            ue.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._sanitizedAttributionHTML = void 0;
          }
          _setElementTitle(e, i) {
            const a = this._map._getUIString(`AttributionControl.${i}`);
            e.title = a, e.setAttribute("aria-label", a);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((o) => typeof o != "string" ? "" : o)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const o = this._map.style.stylesheet;
              this.styleOwner = o.owner, this.styleId = o.id;
            }
            const i = this._map.style.sourceCaches;
            for (const o in i) {
              const u = i[o];
              if (u.used || u.usedForTerrain) {
                const f = u.getSource();
                f.attribution && e.indexOf(f.attribution) < 0 && e.push(f.attribution);
              }
            }
            e = e.filter((o) => String(o).trim()), e.sort((o, u) => o.length - u.length), e = e.filter((o, u) => {
              for (let f = u + 1; f < e.length; f++) if (e[f].indexOf(o) >= 0) return !1;
              return !0;
            });
            const a = e.join(" | ");
            a !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = ue.sanitize(a), e.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class xa {
          constructor(e = {}) {
            this._updateCompact = () => {
              const i = this._container.children;
              if (i.length) {
                const a = i[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && a.classList.add("maplibregl-compact") : a.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = ue.create("div", "maplibregl-ctrl");
            const i = ue.create("a", "maplibregl-ctrl-logo");
            return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            ue.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Vo {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(e) {
            const i = ++this._id;
            return this._queue.push({ callback: e, id: i, cancelled: !1 }), i;
          }
          remove(e) {
            const i = this._currentlyRunning, a = i ? this._queue.concat(i) : this._queue;
            for (const o of a) if (o.id === e) return void (o.cancelled = !0);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const i = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const a of i) if (!a.cancelled && (a.callback(e), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var wi = c.aC([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class ec extends c.E {
          constructor(e) {
            super(), this._lastTilesetChange = He.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(e, i) {
            this.sourceCache.update(e, i), this._renderableTilesKeys = [];
            const a = {};
            for (const o of ie(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: i, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) a[o.key] = !0, this._renderableTilesKeys.push(o.key), this._tiles[o.key] || (o.terrainRttPosMatrix32f = new Float64Array(16), c.bN(o.terrainRttPosMatrix32f, 0, c.Z, c.Z, 0, 0, 1), this._tiles[o.key] = new Rr(o, this.tileSize), this._lastTilesetChange = He.now());
            for (const o in this._tiles) a[o] || delete this._tiles[o];
          }
          freeRtt(e) {
            for (const i in this._tiles) {
              const a = this._tiles[i];
              (!e || a.tileID.equals(e) || a.tileID.isChildOf(e) || e.isChildOf(a.tileID)) && (a.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e) => this.getTileByID(e));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e) {
            const i = {};
            for (const a of this._renderableTilesKeys) {
              const o = this._tiles[a].tileID, u = e.clone(), f = c.b1();
              if (o.canonical.equals(e.canonical)) c.bN(f, 0, c.Z, c.Z, 0, 0, 1);
              else if (o.canonical.isChildOf(e.canonical)) {
                const _ = o.canonical.z - e.canonical.z, y = o.canonical.x - (o.canonical.x >> _ << _), v = o.canonical.y - (o.canonical.y >> _ << _), T = c.Z >> _;
                c.bN(f, 0, T, T, 0, 0, 1), c.L(f, f, [-y * T, -v * T, 0]);
              } else {
                if (!e.canonical.isChildOf(o.canonical)) continue;
                {
                  const _ = e.canonical.z - o.canonical.z, y = e.canonical.x - (e.canonical.x >> _ << _), v = e.canonical.y - (e.canonical.y >> _ << _), T = c.Z >> _;
                  c.bN(f, 0, c.Z, c.Z, 0, 0, 1), c.L(f, f, [y * T, v * T, 0]), c.M(f, f, [1 / 2 ** _, 1 / 2 ** _, 0]);
                }
              }
              u.terrainRttPosMatrix32f = new Float32Array(f), i[a] = u;
            }
            return i;
          }
          getSourceTile(e, i) {
            const a = this.sourceCache._source;
            let o = e.overscaledZ - this.deltaZoom;
            if (o > a.maxzoom && (o = a.maxzoom), o < a.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(o).key);
            let u = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!u || !u.dem) && i) for (; o >= a.minzoom && (!u || !u.dem); ) u = this.sourceCache.getTileByID(e.scaledTo(o--).key);
            return u;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
        }
        class cr {
          constructor(e, i, a) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new ec(i), this.options = a, this.exaggeration = typeof a.exaggeration == "number" ? a.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, i, a, o = c.Z) {
            var u;
            if (!(i >= 0 && i < o && a >= 0 && a < o)) return 0;
            const f = this.getTerrainData(e), _ = (u = f.tile) === null || u === void 0 ? void 0 : u.dem;
            if (!_) return 0;
            const y = c.cb([], [i / o * c.Z, a / o * c.Z], f.u_terrain_matrix), v = [y[0] * _.dim, y[1] * _.dim], T = Math.floor(v[0]), S = Math.floor(v[1]), M = v[0] - T, k = v[1] - S;
            return _.get(T, S) * (1 - M) * (1 - k) + _.get(T + 1, S) * M * (1 - k) + _.get(T, S + 1) * (1 - M) * k + _.get(T + 1, S + 1) * M * k;
          }
          getElevationForLngLatZoom(e, i) {
            if (!c.cc(i, e.wrap())) return 0;
            const { tileID: a, mercatorX: o, mercatorY: u } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return this.getElevation(a, o % c.Z, u % c.Z, c.Z);
          }
          getElevation(e, i, a, o = c.Z) {
            return this.getDEMElevation(e, i, a, o) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const o = this.painter.context, u = new c.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new zt(o, u, o.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new zt(o, new c.R({ width: 1, height: 1 }), o.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(o.gl.NEAREST, o.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.as([]);
            }
            const i = this.sourceCache.getSourceTile(e, !0);
            if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
              const o = this.painter.context;
              i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 }) : i.demTexture = new zt(o, i.dem.getPixels(), o.gl.RGBA, { premultiply: !1 }), i.demTexture.bind(o.gl.NEAREST, o.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1;
            }
            const a = i && i + i.tileID.key + e.key;
            if (a && !this._demMatrixCache[a]) {
              const o = this.sourceCache.sourceCache._source.maxzoom;
              let u = e.canonical.z - i.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= o ? u = e.canonical.z - o : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const f = e.canonical.x - (e.canonical.x >> u << u), _ = e.canonical.y - (e.canonical.y >> u << u), y = c.cd(new Float64Array(16), [1 / (c.Z << u), 1 / (c.Z << u), 0]);
              c.L(y, y, [f * c.Z, _ * c.Z, 0]), this._demMatrixCache[e.key] = { matrix: y, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i && i.dem && i.dem.dim || 1, u_terrain_matrix: a ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i && i.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i };
          }
          getFramebuffer(e) {
            const i = this.painter, a = i.width / devicePixelRatio, o = i.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === a && this._fbo.height === o || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new zt(i.context, { width: a, height: o, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new zt(i.context, { width: a, height: o, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(a, o, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, a, o))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let u = 0, f = 0; u < this._coordsTextureSize; u++) for (let _ = 0; _ < this._coordsTextureSize; _++, f += 4) i[f + 0] = 255 & _, i[f + 1] = 255 & u, i[f + 2] = _ >> 8 << 4 | u >> 8, i[f + 3] = 0;
            const a = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i.buffer)), o = new zt(e, a, e.gl.RGBA, { premultiply: !1 });
            return o.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = o, o;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const i = new Uint8Array(4), a = this.painter.context, o = a.gl, u = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), f = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), _ = Math.round(this.painter.height / devicePixelRatio);
            a.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o.readPixels(u, _ - f - 1, 1, 1, o.RGBA, o.UNSIGNED_BYTE, i), a.bindFramebuffer.set(null);
            const y = i[0] + (i[2] >> 4 << 8), v = i[1] + ((15 & i[2]) << 8), T = this.coordsIndex[255 - i[3]], S = T && this.sourceCache.getTileByID(T);
            if (!S) return null;
            const M = this._coordsTextureSize, k = (1 << S.tileID.canonical.z) * M;
            return new c.$((S.tileID.canonical.x * M + y) / k + S.tileID.wrap, (S.tileID.canonical.y * M + v) / k, this.getElevation(S.tileID, y, v, M));
          }
          depthAtPoint(e) {
            const i = new Uint8Array(4), a = this.painter.context, o = a.gl;
            return a.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), o.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, o.RGBA, o.UNSIGNED_BYTE, i), a.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256;
          }
          getTerrainMesh(e) {
            var i;
            const a = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0, o = a && e.canonical.y === 0, u = a && e.canonical.y === (1 << e.canonical.z) - 1, f = `m_${o ? "n" : ""}_${u ? "s" : ""}`;
            if (this._meshCache[f]) return this._meshCache[f];
            const _ = this.painter.context, y = new c.ce(), v = new c.aG(), T = this.meshSize, S = c.Z / T, M = T * T;
            for (let J = 0; J <= T; J++) for (let se = 0; se <= T; se++) y.emplaceBack(se * S, J * S, 0);
            for (let J = 0; J < M; J += T + 1) for (let se = 0; se < T; se++) v.emplaceBack(se + J, T + se + J + 1, T + se + J + 2), v.emplaceBack(se + J, T + se + J + 2, se + J + 1);
            const k = y.length, R = k + (T + 1), V = (T + 1) * T, j = o ? c.b8 : 0, N = o ? 0 : 1, G = u ? c.b9 : c.Z, W = u ? 0 : 1;
            for (let J = 0; J <= T; J++) y.emplaceBack(J * S, j, N);
            for (let J = 0; J <= T; J++) y.emplaceBack(J * S, G, W);
            for (let J = 0; J < T; J++) v.emplaceBack(V + J, R + J, R + J + 1), v.emplaceBack(V + J, R + J + 1, V + J + 1), v.emplaceBack(0 + J, k + J + 1, k + J), v.emplaceBack(0 + J, 0 + J + 1, k + J + 1);
            const H = y.length, K = H + 2 * (T + 1);
            for (const J of [0, 1]) for (let se = 0; se <= T; se++) for (const oe of [0, 1]) y.emplaceBack(J * c.Z, se * S, oe);
            for (let J = 0; J < 2 * T; J += 2) v.emplaceBack(H + J, H + J + 1, H + J + 3), v.emplaceBack(H + J, H + J + 3, H + J + 2), v.emplaceBack(K + J, K + J + 3, K + J + 1), v.emplaceBack(K + J, K + J + 2, K + J + 3);
            const Q = new Si(_.createVertexBuffer(y, wi.members), _.createIndexBuffer(v), c.aF.simpleSegment(0, 0, y.length, v.length));
            return this._meshCache[f] = Q, Q;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * c.bq / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, i) {
            var a;
            const { tileID: o } = this._getOverscaledTileIDFromLngLatZoom(e, i);
            return (a = this.getMinMaxElevation(o).minElevation) !== null && a !== void 0 ? a : 0;
          }
          getMinMaxElevation(e) {
            const i = this.getTerrainData(e).tile, a = { minElevation: null, maxElevation: null };
            return i && i.dem && (a.minElevation = i.dem.min * this.exaggeration, a.maxElevation = i.dem.max * this.exaggeration), a;
          }
          _getOverscaledTileIDFromLngLatZoom(e, i) {
            const a = c.$.fromLngLat(e.wrap()), o = (1 << i) * c.Z, u = a.x * o, f = a.y * o, _ = Math.floor(u / c.Z), y = Math.floor(f / c.Z);
            return { tileID: new c.Y(i, 0, i, _, y), mercatorX: u, mercatorY: f };
          }
        }
        class Xc {
          constructor(e, i, a) {
            this._context = e, this._size = i, this._tileSize = a, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), a = new zt(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return a.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(a.texture), { id: e, fbo: i, texture: a, stamp: -1, inUse: !1 };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((i) => e.id !== i), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const i of this._recentlyUsed) if (!this._objects[i].inUse) return this._objects[i];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = !1;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
          }
        }
        const hr = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
        class Et {
          constructor(e, i) {
            this.painter = e, this.terrain = i, this.pool = new Xc(e.context, 30, i.sourceCache.tileSize * i.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, i) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((a) => !e._layers[a].isHidden(i)), this._coordsAscending = {};
            for (const a in e.sourceCaches) {
              this._coordsAscending[a] = {};
              const o = e.sourceCaches[a].getVisibleCoordinates();
              for (const u of o) {
                const f = this.terrain.sourceCache.getTerrainCoords(u);
                for (const _ in f) this._coordsAscending[a][_] || (this._coordsAscending[a][_] = []), this._coordsAscending[a][_].push(f[_]);
              }
            }
            this._coordsAscendingStr = {};
            for (const a of e._order) {
              const o = e._layers[a], u = o.source;
              if (hr[o.type] && !this._coordsAscendingStr[u]) {
                this._coordsAscendingStr[u] = {};
                for (const f in this._coordsAscending[u]) this._coordsAscendingStr[u][f] = this._coordsAscending[u][f].map((_) => _.key).sort().join();
              }
            }
            for (const a of this._renderableTiles) for (const o in this._coordsAscendingStr) {
              const u = this._coordsAscendingStr[o][a.tileID.key];
              u && u !== a.rttCoords[o] && (a.rtt = []);
            }
          }
          renderLayer(e, i) {
            if (e.isHidden(this.painter.transform.zoom)) return !1;
            const a = Object.assign(Object.assign({}, i), { isRenderingToTexture: !0 }), o = e.type, u = this.painter, f = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (hr[o] && (this._prevType && hr[this._prevType] || this._stacks.push([]), this._prevType = o, this._stacks[this._stacks.length - 1].push(e.id), !f)) return !0;
            if (hr[this._prevType] || hr[o] && f) {
              this._prevType = o;
              const _ = this._stacks.length - 1, y = this._stacks[_] || [];
              for (const v of this._renderableTiles) {
                if (this.pool.isFull() && (Io(this.painter, this.terrain, this._rttTiles, a), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(v), v.rtt[_]) {
                  const S = this.pool.getObjectForId(v.rtt[_].id);
                  if (S.stamp === v.rtt[_].stamp) {
                    this.pool.useObject(S);
                    continue;
                  }
                }
                const T = this.pool.getOrCreateFreeObject();
                this.pool.useObject(T), this.pool.stampObject(T), v.rtt[_] = { id: T.id, stamp: T.stamp }, u.context.bindFramebuffer.set(T.fbo.framebuffer), u.context.clear({ color: c.b6.transparent, stencil: 0 }), u.currentStencilSource = void 0;
                for (let S = 0; S < y.length; S++) {
                  const M = u.style._layers[y[S]], k = M.source ? this._coordsAscending[M.source][v.tileID.key] : [v.tileID];
                  u.context.viewport.set([0, 0, T.fbo.width, T.fbo.height]), u._renderTileClippingMasks(M, k, !0), u.renderLayer(u, u.style.sourceCaches[M.source], M, k, a), M.source && (v.rttCoords[M.source] = this._coordsAscendingStr[M.source][v.tileID.key]);
                }
              }
              return Io(this.painter, this.terrain, this._rttTiles, a), this._rttTiles = [], this.pool.freeAllObjects(), hr[o];
            }
            return !1;
          }
        }
        const Lt = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, tc = fi, Jn = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: Ge, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, va = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class No {
          constructor(e, i, a = !1) {
            this.mousedown = (u) => {
              this.startMove(u, ue.mousePos(this.element, u)), ue.addEventListener(window, "mousemove", this.mousemove), ue.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (u) => {
              this.move(u, ue.mousePos(this.element, u));
            }, this.mouseup = (u) => {
              this._rotatePitchHanlder.dragEnd(u), this.offTemp();
            }, this.touchstart = (u) => {
              u.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ue.touchPos(this.element, u.targetTouches)[0], this.startMove(u, this._startPos), ue.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ue.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (u) => {
              u.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ue.touchPos(this.element, u.targetTouches)[0], this.move(u, this._lastPos));
            }, this.touchend = (u) => {
              u.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = i;
            const o = new Xl();
            this._rotatePitchHanlder = new Ii({ clickTolerance: 3, move: (u, f) => {
              const _ = i.getBoundingClientRect(), y = new c.P((_.bottom - _.top) / 2, (_.right - _.left) / 2);
              return { bearingDelta: c.c9(new c.P(u.x, f.y), f, y), pitchDelta: a ? -0.5 * (f.y - u.y) : void 0 };
            }, moveStateManager: o, enable: !0, assignEvents: () => {
            } }), this.map = e, ue.addEventListener(i, "mousedown", this.mousedown), ue.addEventListener(i, "touchstart", this.touchstart, { passive: !1 }), ue.addEventListener(i, "touchcancel", this.reset);
          }
          startMove(e, i) {
            this._rotatePitchHanlder.dragStart(e, i), ue.disableDrag();
          }
          move(e, i) {
            const a = this.map, { bearingDelta: o, pitchDelta: u } = this._rotatePitchHanlder.dragMove(e, i) || {};
            o && a.setBearing(a.getBearing() + o), u && a.setPitch(a.getPitch() + u);
          }
          off() {
            const e = this.element;
            ue.removeEventListener(e, "mousedown", this.mousedown), ue.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), ue.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ue.removeEventListener(window, "touchend", this.touchend), ue.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            ue.enableDrag(), ue.removeEventListener(window, "mousemove", this.mousemove), ue.removeEventListener(window, "mouseup", this.mouseup), ue.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ue.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let vr;
        function ba(h, e, i) {
          const a = new c.Q(h.lng, h.lat);
          if (h = new c.Q(h.lng, h.lat), e) {
            const o = new c.Q(h.lng - 360, h.lat), u = new c.Q(h.lng + 360, h.lat), f = i.locationToScreenPoint(h).distSqr(e);
            i.locationToScreenPoint(o).distSqr(e) < f ? h = o : i.locationToScreenPoint(u).distSqr(e) < f && (h = u);
          }
          for (; Math.abs(h.lng - i.center.lng) > 180; ) {
            const o = i.locationToScreenPoint(h);
            if (o.x >= 0 && o.y >= 0 && o.x <= i.width && o.y <= i.height) break;
            h.lng > i.center.lng ? h.lng -= 360 : h.lng += 360;
          }
          return h.lng !== a.lng && i.isPointOnMapSurface(i.locationToScreenPoint(h)) ? h : a;
        }
        const vn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function wa(h, e, i) {
          const a = h.classList;
          for (const o in vn) a.remove(`maplibregl-${i}-anchor-${o}`);
          a.add(`maplibregl-${i}-anchor-${e}`);
        }
        class Es extends c.E {
          constructor(e) {
            if (super(), this._onKeyPress = (i) => {
              const a = i.code, o = i.charCode || i.keyCode;
              a !== "Space" && a !== "Enter" && o !== 32 && o !== 13 || this.togglePopup();
            }, this._onMapClick = (i) => {
              const a = i.originalEvent.target, o = this._element;
              this._popup && (a === o || o.contains(a)) && this.togglePopup();
            }, this._update = (i) => {
              var a;
              if (!this._map) return;
              const o = this._map.loaded() && !this._map.isMoving();
              ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !o) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? ba(this._lngLat, this._flatPos, this._map.transform) : (a = this._lngLat) === null || a === void 0 ? void 0 : a.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let u = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? u = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (u = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let f = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? f = "rotateX(0deg)" : this._pitchAlignment === "map" && (f = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), ue.setTransform(this._element, `${vn[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${u}`), He.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(i && i.type === "moveend");
              }).catch(() => {
              });
            }, this._onMove = (i) => {
              if (!this._isDragging) {
                const a = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = i.point.dist(this._pointerdownPos) >= a;
              }
              this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.l("dragstart"))), this.fire(new c.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (i) => {
              this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = c.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = ue.create("div");
              const i = ue.createNS("http://www.w3.org/2000/svg", "svg"), a = 41, o = 27;
              i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${a}px`), i.setAttributeNS(null, "width", `${o}px`), i.setAttributeNS(null, "viewBox", `0 0 ${o} ${a}`);
              const u = ue.createNS("http://www.w3.org/2000/svg", "g");
              u.setAttributeNS(null, "stroke", "none"), u.setAttributeNS(null, "stroke-width", "1"), u.setAttributeNS(null, "fill", "none"), u.setAttributeNS(null, "fill-rule", "evenodd");
              const f = ue.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "fill-rule", "nonzero");
              const _ = ue.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), _.setAttributeNS(null, "fill", "#000000");
              const y = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const N of y) {
                const G = ue.createNS("http://www.w3.org/2000/svg", "ellipse");
                G.setAttributeNS(null, "opacity", "0.04"), G.setAttributeNS(null, "cx", "10.5"), G.setAttributeNS(null, "cy", "5.80029008"), G.setAttributeNS(null, "rx", N.rx), G.setAttributeNS(null, "ry", N.ry), _.appendChild(G);
              }
              const v = ue.createNS("http://www.w3.org/2000/svg", "g");
              v.setAttributeNS(null, "fill", this._color);
              const T = ue.createNS("http://www.w3.org/2000/svg", "path");
              T.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), v.appendChild(T);
              const S = ue.createNS("http://www.w3.org/2000/svg", "g");
              S.setAttributeNS(null, "opacity", "0.25"), S.setAttributeNS(null, "fill", "#000000");
              const M = ue.createNS("http://www.w3.org/2000/svg", "path");
              M.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), S.appendChild(M);
              const k = ue.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), k.setAttributeNS(null, "fill", "#FFFFFF");
              const R = ue.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const V = ue.createNS("http://www.w3.org/2000/svg", "circle");
              V.setAttributeNS(null, "fill", "#000000"), V.setAttributeNS(null, "opacity", "0.25"), V.setAttributeNS(null, "cx", "5.5"), V.setAttributeNS(null, "cy", "5.5"), V.setAttributeNS(null, "r", "5.4999962");
              const j = ue.createNS("http://www.w3.org/2000/svg", "circle");
              j.setAttributeNS(null, "fill", "#FFFFFF"), j.setAttributeNS(null, "cx", "5.5"), j.setAttributeNS(null, "cy", "5.5"), j.setAttributeNS(null, "r", "5.4999962"), R.appendChild(V), R.appendChild(j), f.appendChild(_), f.appendChild(v), f.appendChild(S), f.appendChild(k), f.appendChild(R), i.appendChild(f), i.setAttributeNS(null, "height", a * this._scale + "px"), i.setAttributeNS(null, "width", o * this._scale + "px"), this._element.appendChild(i), this._offset = c.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (i) => {
              i.preventDefault();
            }), this._element.addEventListener("mousedown", (i) => {
              i.preventDefault();
            }), wa(this._element, this._anchor, "marker"), e && e.className) for (const i of e.className.split(" ")) this._element.classList.add(i);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), ue.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = c.Q.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const o = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [o, -1 * (38.1 - 13.5 + o)], "bottom-right": [-o, -1 * (38.1 - 13.5 + o)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = !1) {
            var i, a;
            if (!(!((i = this._map) === null || i === void 0) && i.terrain)) {
              const S = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== S && (this._element.style.opacity = S));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const o = this._map, u = o.terrain.depthAtPoint(this._pos), f = o.terrain.getElevationForLngLatZoom(this._lngLat, o.transform.tileZoom);
            if (o.transform.lngLatToCameraDepth(this._lngLat, f) - u < 6e-3) return void (this._element.style.opacity = this._opacity);
            const _ = -this._offset.y / o.transform.pixelsPerMeter, y = Math.sin(o.getPitch() * Math.PI / 180) * _, v = o.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), T = o.transform.lngLatToCameraDepth(this._lngLat, f + y) - v > 6e-3;
            !((a = this._popup) === null || a === void 0) && a.isOpen() && T && this._popup.remove(), this._element.style.opacity = T ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = c.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, i) {
            return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this;
          }
        }
        const Zo = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Yn = 0, bn = !1;
        const Uo = { maxWidth: 100, unit: "metric" };
        function Ta(h, e, i) {
          const a = i && i.maxWidth || 100, o = h._container.clientHeight / 2, u = h._container.clientWidth / 2, f = h.unproject([u - a / 2, o]), _ = h.unproject([u + a / 2, o]), y = Math.round(h.project(_).x - h.project(f).x), v = Math.min(a, y, h._container.clientWidth), T = f.distanceTo(_);
          if (i && i.unit === "imperial") {
            const S = 3.2808 * T;
            S > 5280 ? wn(e, v, S / 5280, h._getUIString("ScaleControl.Miles")) : wn(e, v, S, h._getUIString("ScaleControl.Feet"));
          } else i && i.unit === "nautical" ? wn(e, v, T / 1852, h._getUIString("ScaleControl.NauticalMiles")) : T >= 1e3 ? wn(e, v, T / 1e3, h._getUIString("ScaleControl.Kilometers")) : wn(e, v, T, h._getUIString("ScaleControl.Meters"));
        }
        function wn(h, e, i, a) {
          const o = function(u) {
            const f = Math.pow(10, `${Math.floor(u)}`.length - 1);
            let _ = u / f;
            return _ = _ >= 10 ? 10 : _ >= 5 ? 5 : _ >= 3 ? 3 : _ >= 2 ? 2 : _ >= 1 ? 1 : function(y) {
              const v = Math.pow(10, Math.ceil(-Math.log(y) / Math.LN10));
              return Math.round(y * v) / v;
            }(_), f * _;
          }(i);
          h.style.width = e * (o / i) + "px", h.innerHTML = `${o}&nbsp;${a}`;
        }
        const Pa = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Go = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Sa(h) {
          if (h) {
            if (typeof h == "number") {
              const e = Math.round(Math.abs(h) / Math.SQRT2);
              return { center: new c.P(0, 0), top: new c.P(0, h), "top-left": new c.P(e, e), "top-right": new c.P(-e, e), bottom: new c.P(0, -h), "bottom-left": new c.P(e, -e), "bottom-right": new c.P(-e, -e), left: new c.P(h, 0), right: new c.P(-h, 0) };
            }
            if (h instanceof c.P || Array.isArray(h)) {
              const e = c.P.convert(h);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: c.P.convert(h.center || [0, 0]), top: c.P.convert(h.top || [0, 0]), "top-left": c.P.convert(h["top-left"] || [0, 0]), "top-right": c.P.convert(h["top-right"] || [0, 0]), bottom: c.P.convert(h.bottom || [0, 0]), "bottom-left": c.P.convert(h["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(h["bottom-right"] || [0, 0]), left: c.P.convert(h.left || [0, 0]), right: c.P.convert(h.right || [0, 0]) };
          }
          return Sa(new c.P(0, 0));
        }
        const Ma = fi;
        z.AJAXError = c.ci, z.Event = c.l, z.Evented = c.E, z.LngLat = c.Q, z.MercatorCoordinate = c.$, z.Point = c.P, z.addProtocol = c.cj, z.config = c.a, z.removeProtocol = c.ck, z.AttributionControl = Cs, z.BoxZoomHandler = Hl, z.CanvasSource = An, z.CooperativeGesturesHandler = jo, z.DoubleClickZoomHandler = Ql, z.DragPanHandler = Ms, z.DragRotateHandler = ga, z.EdgeInsets = Xt, z.FullscreenControl = class extends c.E {
          constructor(h = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) i = i.shadowRoot.fullscreenElement;
              i === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, h && h.container && (h.container instanceof HTMLElement ? this._container = h.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(h) {
            return this._map = h, this._container || (this._container = this._map.getContainer()), this._controlContainer = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            ue.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const h = this._fullscreenButton = ue.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            ue.create("span", "maplibregl-ctrl-icon", h).setAttribute("aria-hidden", "true"), h.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const h = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", h), this._fullscreenButton.title = h;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, z.GeoJSONSource = Dr, z.GeolocateControl = class extends c.E {
          constructor(h) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new c.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const i = new c.Q(e.coords.longitude, e.coords.latitude), a = e.coords.accuracy, o = this._map.getBearing(), u = c.e({ bearing: o }, this.options.fitBoundsOptions), f = Dt.fromLngLat(i, a);
              this._map.fitBounds(f, u, { geolocateSource: !0 });
            }, this._updateMarker = (e) => {
              if (e) {
                const i = new c.Q(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e) => {
              if (this._map) {
                if (this.options.trackUserLocation) if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && bn) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = ue.create("button", "maplibregl-ctrl-geolocate", this._container), ue.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === !1) {
                  c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
                } else {
                  const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = ue.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Es({ element: this._dotElement }), this._circleElement = ue.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Es({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (i) => {
                  i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || i.originalEvent && i.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.l("trackuserlocationend")), this.fire(new c.l("userlocationlostfocus")));
                });
              }
            }, this.options = c.e({}, Zo, h);
          }
          onAdd(h) {
            return this._map = h, this._container = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return c._(this, arguments, void 0, function* (e = !1) {
                if (vr !== void 0 && !e) return vr;
                if (window.navigator.permissions === void 0) return vr = !!window.navigator.geolocation, vr;
                try {
                  vr = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  vr = !!window.navigator.geolocation;
                }
                return vr;
              });
            }().then((e) => this._finishSetupUI(e)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), ue.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Yn = 0, bn = !1;
          }
          _isOutOfMapMaxBounds(h) {
            const e = this._map.getMaxBounds(), i = h.coords;
            return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const h = this._map.getBounds(), e = h.getSouthEast(), i = h.getNorthEast(), a = e.distanceTo(i), o = Math.ceil(this._accuracy / (a / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
          }
          trigger() {
            if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new c.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Yn--, bn = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.l("trackuserlocationstart")), this.fire(new c.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let h;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Yn++, Yn > 1 ? (h = { maximumAge: 6e5, timeout: 0 }, bn = !0) : (h = this.options.positionOptions, bn = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, h);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, z.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var h;
              const e = (h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var h;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((h = this._map.getProjection()) === null || h === void 0 ? void 0 : h.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(h) {
            return this._map = h, this._container = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = ue.create("button", "maplibregl-ctrl-globe", this._container), ue.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            ue.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, z.Hash = jr, z.ImageSource = ar, z.KeyboardHandler = Bo, z.LngLatBounds = Dt, z.LogoControl = xa, z.Map = class extends Fe {
          constructor(h) {
            var e, i;
            c.cf.mark(c.cg.create);
            const a = Object.assign(Object.assign(Object.assign({}, Jn), h), { canvasContextAttributes: Object.assign(Object.assign({}, Jn.canvasContextAttributes), h.canvasContextAttributes) });
            if (a.minZoom != null && a.maxZoom != null && a.minZoom > a.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (a.minPitch != null && a.maxPitch != null && a.minPitch > a.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (a.minPitch != null && a.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (a.maxPitch != null && a.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const o = new Fi(), u = new Ji();
            if (a.minZoom !== void 0 && o.setMinZoom(a.minZoom), a.maxZoom !== void 0 && o.setMaxZoom(a.maxZoom), a.minPitch !== void 0 && o.setMinPitch(a.minPitch), a.maxPitch !== void 0 && o.setMaxPitch(a.maxPitch), a.renderWorldCopies !== void 0 && o.setRenderWorldCopies(a.renderWorldCopies), super(o, u, { bearingSnap: a.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Vo(), this._controls = [], this._mapId = c.a3(), this._contextLost = (_) => {
              _.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.l("webglcontextlost", { originalEvent: _ }));
            }, this._contextRestored = (_) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new c.l("webglcontextrestored", { originalEvent: _ }));
            }, this._onMapScroll = (_) => {
              if (_.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = a.interactive, this._maxTileCacheSize = a.maxTileCacheSize, this._maxTileCacheZoomLevels = a.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, a.canvasContextAttributes), this._trackResize = a.trackResize === !0, this._bearingSnap = a.bearingSnap, this._centerClampedToGround = a.centerClampedToGround, this._refreshExpiredTiles = a.refreshExpiredTiles === !0, this._fadeDuration = a.fadeDuration, this._crossSourceCollisions = a.crossSourceCollisions === !0, this._collectResourceTiming = a.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Lt), a.locale), this._clickTolerance = a.clickTolerance, this._overridePixelRatio = a.pixelRatio, this._maxCanvasSize = a.maxCanvasSize, this.transformCameraUpdate = a.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = a.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = mi.addThrottleControl(() => this.isMoving()), this._requestManager = new Er(a.transformRequest), typeof a.container == "string") {
              if (this._container = document.getElementById(a.container), !this._container) throw new Error(`Container '${a.container}' not found.`);
            } else {
              if (!(a.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = a.container;
            }
            if (a.maxBounds && this.setMaxBounds(a.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let _ = !1;
              const y = Eo((v) => {
                this._trackResize && !this._removed && (this.resize(v), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((v) => {
                _ ? y(v) : _ = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new ya(this, a), this._hash = a.hash && new jr(typeof a.hash == "string" && a.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: a.center, elevation: a.elevation, zoom: a.zoom, bearing: a.bearing, pitch: a.pitch, roll: a.roll }), a.bounds && (this.resize(), this.fitBounds(a.bounds, c.e({}, a.fitBoundsOptions, { duration: 0 }))));
            const f = typeof a.style == "string" || ((i = (e = a.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
            this.resize(null, f), this._localIdeographFontFamily = a.localIdeographFontFamily, this._validateStyle = a.validateStyle, a.style && this.setStyle(a.style, { localIdeographFontFamily: a.localIdeographFontFamily }), a.attributionControl && this.addControl(new Cs(typeof a.attributionControl == "boolean" ? void 0 : a.attributionControl)), a.maplibreLogo && this.addControl(new xa(), a.logoPosition), this.on("style.load", () => {
              if (f || this._resizeTransform(), this.transform.unmodified) {
                const _ = c.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(_);
              }
            }), this.on("data", (_) => {
              this._update(_.dataType === "style"), this.fire(new c.l(`${_.dataType}data`, _));
            }), this.on("dataloading", (_) => {
              this.fire(new c.l(`${_.dataType}dataloading`, _));
            }), this.on("dataabort", (_) => {
              this.fire(new c.l("sourcedataabort", _));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(h, e) {
            if (e === void 0 && (e = h.getDefaultPosition ? h.getDefaultPosition() : "top-right"), !h || !h.onAdd) return this.fire(new c.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i = h.onAdd(this);
            this._controls.push(h);
            const a = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? a.insertBefore(i, a.firstChild) : a.appendChild(i), this;
          }
          removeControl(h) {
            if (!h || !h.onRemove) return this.fire(new c.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(h);
            return e > -1 && this._controls.splice(e, 1), h.onRemove(this), this;
          }
          hasControl(h) {
            return this._controls.indexOf(h) > -1;
          }
          calculateCameraOptionsFromTo(h, e, i, a) {
            return a == null && this.terrain && (a = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(h, e, i, a);
          }
          resize(h, e = !0) {
            const [i, a] = this._containerDimensions(), o = this._getClampedPixelRatio(i, a);
            if (this._resizeCanvas(i, a, o), this.painter.resize(i, a, o), this.painter.overLimit()) {
              const f = this.painter.context.gl;
              this._maxCanvasSize = [f.drawingBufferWidth, f.drawingBufferHeight];
              const _ = this._getClampedPixelRatio(i, a);
              this._resizeCanvas(i, a, _), this.painter.resize(i, a, _);
            }
            this._resizeTransform(e);
            const u = !this._moving;
            return u && (this.stop(), this.fire(new c.l("movestart", h)).fire(new c.l("move", h))), this.fire(new c.l("resize", h)), u && this.fire(new c.l("moveend", h)), this;
          }
          _resizeTransform(h = !0) {
            var e;
            const [i, a] = this._containerDimensions();
            this.transform.resize(i, a, h), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, a, h);
          }
          _getClampedPixelRatio(h, e) {
            const { 0: i, 1: a } = this._maxCanvasSize, o = this.getPixelRatio(), u = h * o, f = e * o;
            return Math.min(u > i ? i / u : 1, f > a ? a / f : 1) * o;
          }
          getPixelRatio() {
            var h;
            return (h = this._overridePixelRatio) !== null && h !== void 0 ? h : devicePixelRatio;
          }
          setPixelRatio(h) {
            this._overridePixelRatio = h, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(h) {
            return this.transform.setMaxBounds(Dt.convert(h)), this._update();
          }
          setMinZoom(h) {
            if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom) return this.transform.setMinZoom(h), this._update(), this.getZoom() < h && this.setZoom(h), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(h) {
            if ((h = h ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(h), this._update(), this.getZoom() > h && this.setZoom(h), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(h) {
            if ((h = h ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (h >= 0 && h <= this.transform.maxPitch) return this.transform.setMinPitch(h), this._update(), this.getPitch() < h && this.setPitch(h), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(h) {
            if ((h = h ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (h >= this.transform.minPitch) return this.transform.setMaxPitch(h), this._update(), this.getPitch() > h && this.setPitch(h), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(h) {
            return this.transform.setRenderWorldCopies(h), this._update();
          }
          project(h) {
            return this.transform.locationToScreenPoint(c.Q.convert(h), this.style && this.terrain);
          }
          unproject(h) {
            return this.transform.screenPointToLocation(c.P.convert(h), this.terrain);
          }
          isMoving() {
            var h;
            return this._moving || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isMoving());
          }
          isZooming() {
            var h;
            return this._zooming || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isZooming());
          }
          isRotating() {
            var h;
            return this._rotating || ((h = this.handlers) === null || h === void 0 ? void 0 : h.isRotating());
          }
          _createDelegatedListener(h, e, i) {
            if (h === "mouseenter" || h === "mouseover") {
              let a = !1;
              return { layers: e, listener: i, delegates: { mousemove: (u) => {
                const f = e.filter((y) => this.getLayer(y)), _ = f.length !== 0 ? this.queryRenderedFeatures(u.point, { layers: f }) : [];
                _.length ? a || (a = !0, i.call(this, new Ct(h, this, u.originalEvent, { features: _ }))) : a = !1;
              }, mouseout: () => {
                a = !1;
              } } };
            }
            if (h === "mouseleave" || h === "mouseout") {
              let a = !1;
              return { layers: e, listener: i, delegates: { mousemove: (f) => {
                const _ = e.filter((y) => this.getLayer(y));
                (_.length !== 0 ? this.queryRenderedFeatures(f.point, { layers: _ }) : []).length ? a = !0 : a && (a = !1, i.call(this, new Ct(h, this, f.originalEvent)));
              }, mouseout: (f) => {
                a && (a = !1, i.call(this, new Ct(h, this, f.originalEvent)));
              } } };
            }
            {
              const a = (o) => {
                const u = e.filter((_) => this.getLayer(_)), f = u.length !== 0 ? this.queryRenderedFeatures(o.point, { layers: u }) : [];
                f.length && (o.features = f, i.call(this, o), delete o.features);
              };
              return { layers: e, listener: i, delegates: { [h]: a } };
            }
          }
          _saveDelegatedListener(h, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[h] = this._delegatedListeners[h] || [], this._delegatedListeners[h].push(e);
          }
          _removeDelegatedListener(h, e, i) {
            if (!this._delegatedListeners || !this._delegatedListeners[h]) return;
            const a = this._delegatedListeners[h];
            for (let o = 0; o < a.length; o++) {
              const u = a[o];
              if (u.listener === i && u.layers.length === e.length && u.layers.every((f) => e.includes(f))) {
                for (const f in u.delegates) this.off(f, u.delegates[f]);
                return void a.splice(o, 1);
              }
            }
          }
          on(h, e, i) {
            if (i === void 0) return super.on(h, e);
            const a = typeof e == "string" ? [e] : e, o = this._createDelegatedListener(h, a, i);
            this._saveDelegatedListener(h, o);
            for (const u in o.delegates) this.on(u, o.delegates[u]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(h, a, i);
            } };
          }
          once(h, e, i) {
            if (i === void 0) return super.once(h, e);
            const a = typeof e == "string" ? [e] : e, o = this._createDelegatedListener(h, a, i);
            for (const u in o.delegates) {
              const f = o.delegates[u];
              o.delegates[u] = (..._) => {
                this._removeDelegatedListener(h, a, i), f(..._);
              };
            }
            this._saveDelegatedListener(h, o);
            for (const u in o.delegates) this.once(u, o.delegates[u]);
            return this;
          }
          off(h, e, i) {
            return i === void 0 ? super.off(h, e) : (this._removeDelegatedListener(h, typeof e == "string" ? [e] : e, i), this);
          }
          queryRenderedFeatures(h, e) {
            if (!this.style) return [];
            let i;
            const a = h instanceof c.P || Array.isArray(h), o = a ? h : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (a ? {} : h) || {}, o instanceof c.P || typeof o[0] == "number") i = [c.P.convert(o)];
            else {
              const u = c.P.convert(o[0]), f = c.P.convert(o[1]);
              i = [u, new c.P(f.x, u.y), f, new c.P(u.x, f.y), u];
            }
            return this.style.queryRenderedFeatures(i, e, this.transform);
          }
          querySourceFeatures(h, e) {
            return this.style.querySourceFeatures(h, e);
          }
          setStyle(h, e) {
            return (e = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && h ? (this._diffStyle(h, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(h, e));
          }
          setTransformRequest(h) {
            return this._requestManager.setTransformRequest(h), this;
          }
          _getUIString(h) {
            const e = this._locale[h];
            if (e == null) throw new Error(`Missing UI string '${h}'`);
            return e;
          }
          _updateStyle(h, e) {
            var i, a;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(h, e));
            const o = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!h)), h ? (this.style = new _s(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof h == "string" ? this.style.loadURL(h, e, o) : this.style.loadJSON(h, e, o), this) : ((a = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || a === void 0 || a.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new _s(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(h, e) {
            if (typeof h == "string") {
              const i = this._requestManager.transformRequest(h, "Style");
              c.j(i, new AbortController()).then((a) => {
                this._updateDiff(a.data, e);
              }).catch((a) => {
                a && this.fire(new c.k(a));
              });
            } else typeof h == "object" && this._updateDiff(h, e);
          }
          _updateDiff(h, e) {
            try {
              this.style.setState(h, e) && this._update(!0);
            } catch (i) {
              c.w(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(h, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : c.w("There is no style added to the map.");
          }
          addSource(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(h, e), this._update(!0);
          }
          isSourceLoaded(h) {
            const e = this.style && this.style.sourceCaches[h];
            if (e !== void 0) return e.loaded();
            this.fire(new c.k(new Error(`There is no source with ID '${h}'`)));
          }
          setTerrain(h) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), h) {
              const e = this.style.sourceCaches[h.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${h.source}`);
              this.terrain === null && e.reload();
              for (const i in this.style._layers) {
                const a = this.style._layers[i];
                a.type === "hillshade" && a.source === h.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new cr(this.painter, e, h), this.painter.renderToTexture = new Et(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (i) => {
                i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== h.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this.terrain.sourceCache.freeRtt(i.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new c.l("terrain", { terrain: h })), this;
          }
          getTerrain() {
            var h, e;
            return (e = (h = this.terrain) === null || h === void 0 ? void 0 : h.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const h = this.style && this.style.sourceCaches;
            for (const e in h) {
              const i = h[e]._tiles;
              for (const a in i) {
                const o = i[a];
                if (o.state !== "loaded" && o.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(h) {
            return this.style.removeSource(h), this._update(!0);
          }
          getSource(h) {
            return this.style.getSource(h);
          }
          addImage(h, e, i = {}) {
            const { pixelRatio: a = 1, sdf: o = !1, stretchX: u, stretchY: f, content: _, textFitWidth: y, textFitHeight: v } = i;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || c.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: T, height: S, data: M } = e, k = e;
                return this.style.addImage(h, { data: new c.R({ width: T, height: S }, new Uint8Array(M)), pixelRatio: a, stretchX: u, stretchY: f, content: _, textFitWidth: y, textFitHeight: v, sdf: o, version: 0, userImage: k }), k.onAdd && k.onAdd(this, h), this;
              }
            }
            {
              const { width: T, height: S, data: M } = He.getImageData(e);
              this.style.addImage(h, { data: new c.R({ width: T, height: S }, M), pixelRatio: a, stretchX: u, stretchY: f, content: _, textFitWidth: y, textFitHeight: v, sdf: o, version: 0 });
            }
          }
          updateImage(h, e) {
            const i = this.style.getImage(h);
            if (!i) return this.fire(new c.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a = e instanceof HTMLImageElement || c.b(e) ? He.getImageData(e) : e, { width: o, height: u, data: f } = a;
            if (o === void 0 || u === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (o !== i.data.width || u !== i.data.height) return this.fire(new c.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const _ = !(e instanceof HTMLImageElement || c.b(e));
            return i.data.replace(f, _), this.style.updateImage(h, i), this;
          }
          getImage(h) {
            return this.style.getImage(h);
          }
          hasImage(h) {
            return h ? !!this.style.getImage(h) : (this.fire(new c.k(new Error("Missing required image id"))), !1);
          }
          removeImage(h) {
            this.style.removeImage(h);
          }
          loadImage(h) {
            return mi.getImage(this._requestManager.transformRequest(h, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(h, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(h, e), this._update(!0);
          }
          moveLayer(h, e) {
            return this.style.moveLayer(h, e), this._update(!0);
          }
          removeLayer(h) {
            return this.style.removeLayer(h), this._update(!0);
          }
          getLayer(h) {
            return this.style.getLayer(h);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(h, e, i) {
            return this.style.setLayerZoomRange(h, e, i), this._update(!0);
          }
          setFilter(h, e, i = {}) {
            return this.style.setFilter(h, e, i), this._update(!0);
          }
          getFilter(h) {
            return this.style.getFilter(h);
          }
          setPaintProperty(h, e, i, a = {}) {
            return this.style.setPaintProperty(h, e, i, a), this._update(!0);
          }
          getPaintProperty(h, e) {
            return this.style.getPaintProperty(h, e);
          }
          setLayoutProperty(h, e, i, a = {}) {
            return this.style.setLayoutProperty(h, e, i, a), this._update(!0);
          }
          getLayoutProperty(h, e) {
            return this.style.getLayoutProperty(h, e);
          }
          setGlyphs(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(h, e), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(h, e, i = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(h, e, i, (a) => {
              a || this._update(!0);
            }), this;
          }
          removeSprite(h) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(h), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(h, e, (i) => {
              i || this._update(!0);
            }), this;
          }
          setLight(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(h, e), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(h, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(h, e), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(h, e) {
            return this.style.setFeatureState(h, e), this._update();
          }
          removeFeatureState(h, e) {
            return this.style.removeFeatureState(h, e), this._update();
          }
          getFeatureState(h) {
            return this.style.getFeatureState(h);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let h = 0, e = 0;
            return this._container && (h = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [h, e];
          }
          _setupContainer() {
            const h = this._container;
            h.classList.add("maplibregl-map");
            const e = this._canvasContainer = ue.create("div", "maplibregl-canvas-container", h);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = ue.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i = this._containerDimensions(), a = this._getClampedPixelRatio(i[0], i[1]);
            this._resizeCanvas(i[0], i[1], a);
            const o = this._controlContainer = ue.create("div", "maplibregl-control-container", h), u = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((f) => {
              u[f] = ue.create("div", `maplibregl-ctrl-${f} `, o);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(h, e, i) {
            this._canvas.width = Math.floor(i * h), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${h}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const h = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", (a) => {
              e = { requestedAttributes: h }, a && (e.statusMessage = a.statusMessage, e.type = a.type);
            }, { once: !0 });
            let i = null;
            if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, h) : this._canvas.getContext("webgl2", h) || this._canvas.getContext("webgl", h), !i) {
              const a = "Failed to initialize WebGL";
              throw e ? (e.message = a, new Error(JSON.stringify(e))) : new Error(a);
            }
            this.painter = new Nl(i, this.transform), Ue.testSupport(i);
          }
          migrateProjection(h, e) {
            super.migrateProjection(h, e), this.painter.transform = h, this.fire(new c.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(h) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || h, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(h) {
            return this._update(), this._renderTaskQueue.add(h);
          }
          _cancelRenderFrame(h) {
            this._renderTaskQueue.remove(h);
          }
          _render(h) {
            var e, i, a, o, u;
            const f = this._idleTriggered ? this._fadeDuration : 0, _ = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(h), this._removed) return;
            let y = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const S = this.transform.zoom, M = He.now();
              this.style.zoomHistory.update(S, M);
              const k = new c.C(S, { now: M, fadeDuration: f, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), R = k.crossFadingFactor();
              R === 1 && R === this._crossFadingFactor || (y = !0, this._crossFadingFactor = R), this.style.update(k);
            }
            const v = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== _;
            (a = this.style.projection) === null || a === void 0 || a.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((o = this.style.projection) === null || o === void 0 ? void 0 : o.transitionState, (u = this.style.projection) === null || u === void 0 ? void 0 : u.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || v) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, f, this._crossSourceCollisions, v), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: f, showPadding: this.showPadding }), this.fire(new c.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.cf.mark(c.cg.load), this.fire(new c.l("load"))), this.style && (this.style.hasTransitions() || y) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const T = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return T || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.l("idle")), !this._loaded || this._fullyLoaded || T || (this._fullyLoaded = !0, c.cf.mark(c.cg.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var h;
            this._hash && this._hash.remove();
            for (const i of this._controls) i.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), mi.removeThrottleControl(this._imageQueueHandle), (h = this._resizeObserver) === null || h === void 0 || h.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), ue.remove(this._canvasContainer), ue.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), c.cf.clearMetrics(), this._removed = !0, this.fire(new c.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), He.frame(this._frameRequest, (h) => {
              c.cf.frame(h), this._frameRequest = null;
              try {
                this._render(h);
              } catch (e) {
                if (!c.ch(e) && !function(i) {
                  return i.message === Ll;
                }(e)) throw e;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(h) {
            this._showTileBoundaries !== h && (this._showTileBoundaries = h, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(h) {
            this._showPadding !== h && (this._showPadding = h, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(h) {
            this._showCollisionBoxes !== h && (this._showCollisionBoxes = h, h ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(h) {
            this._showOverdrawInspector !== h && (this._showOverdrawInspector = h, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(h) {
            this._repaint !== h && (this._repaint = h, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(h) {
            this._vertices = h, this._update();
          }
          get version() {
            return tc;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(h) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(h), this._update(!0);
          }
        }, z.MapMouseEvent = Ct, z.MapTouchEvent = bi, z.MapWheelEvent = Ao, z.Marker = Es, z.NavigationControl = class {
          constructor(h) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), i = e === this._map.getMaxZoom(), a = e === this._map.getMinZoom();
              this._zoomInButton.disabled = i, this._zoomOutButton.disabled = a, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", a.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, i) => {
              const a = this._map._getUIString(`NavigationControl.${i}`);
              e.title = a, e.setAttribute("aria-label", a);
            }, this.options = c.e({}, va, h), this._container = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), ue.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), ue.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            }), this._compassIcon = ue.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(h) {
            return this._map = h, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new No(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            ue.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(h, e) {
            const i = ue.create("button", h, this._container);
            return i.type = "button", i.addEventListener("click", e), i;
          }
        }, z.Popup = class extends c.E {
          constructor(h) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
            }, this.remove = () => (this._content && ue.remove(this._content), this._container && (ue.remove(this._container), delete this._container), this._closeButton && this._closeButton.removeEventListener("click", this._onClose), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              var i;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = ue.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = ue.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const _ of this.options.className.split(" ")) this._container.classList.add(_);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? ba(this._lngLat, this._flatPos, this._map.transform) : (i = this._lngLat) === null || i === void 0 ? void 0 : i.wrap(), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let o = this.options.anchor;
              const u = Sa(this.options.offset);
              if (!o) {
                const _ = this._container.offsetWidth, y = this._container.offsetHeight;
                let v;
                v = a.y + u.bottom.y < y ? ["top"] : a.y > this._map.transform.height - y ? ["bottom"] : [], a.x < _ / 2 ? v.push("left") : a.x > this._map.transform.width - _ / 2 && v.push("right"), o = v.length === 0 ? "bottom" : v.join("-");
              }
              let f = a.add(u[o]);
              this.options.subpixelPositioning || (f = f.round()), ue.setTransform(this._container, `${vn[o]} translate(${f.x}px,${f.y}px)`), wa(this._container, o, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = c.e(Object.create(Pa), h);
          }
          addTo(h) {
            return this._map && this.remove(), this._map = h, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(h) {
            return this._lngLat = c.Q.convert(h), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(h) {
            return this.setDOMContent(document.createTextNode(h));
          }
          setHTML(h) {
            const e = document.createDocumentFragment(), i = document.createElement("body");
            let a;
            for (i.innerHTML = h; a = i.firstChild, a; ) e.appendChild(a);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var h;
            return (h = this._container) === null || h === void 0 ? void 0 : h.style.maxWidth;
          }
          setMaxWidth(h) {
            return this.options.maxWidth = h, this._update(), this;
          }
          setDOMContent(h) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = ue.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(h), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(h) {
            return this._container && this._container.classList.add(h), this;
          }
          removeClassName(h) {
            return this._container && this._container.classList.remove(h), this;
          }
          setOffset(h) {
            return this.options.offset = h, this._update(), this;
          }
          toggleClassName(h) {
            if (this._container) return this._container.classList.toggle(h);
          }
          setSubpixelPositioning(h) {
            this.options.subpixelPositioning = h;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = ue.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const h = this._container.querySelector(Go);
            h && h.focus();
          }
        }, z.RasterDEMTileSource = kr, z.RasterTileSource = Wi, z.ScaleControl = class {
          constructor(h) {
            this._onMove = () => {
              Ta(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, Ta(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Uo), h);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(h) {
            return this._map = h, this._container = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", h.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            ue.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, z.ScrollZoomHandler = Yl, z.Style = _s, z.TerrainControl = class {
          constructor(h) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = h;
          }
          onAdd(h) {
            return this._map = h, this._container = ue.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = ue.create("button", "maplibregl-ctrl-terrain", this._container), ue.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            ue.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, z.TwoFingersTouchPitchHandler = Ro, z.TwoFingersTouchRotateHandler = Jl, z.TwoFingersTouchZoomHandler = Kl, z.TwoFingersTouchZoomRotateHandler = Oo, z.VectorTileSource = rn, z.VideoSource = Hi, z.addSourceType = (h, e) => c._(void 0, void 0, void 0, function* () {
          if (sn(h)) throw new Error(`A source type called "${h}" already exists.`);
          ((i, a) => {
            nn[i] = a;
          })(h, e);
        }), z.clearPrewarmedResources = function() {
          const h = Ri;
          h && (h.isPreloaded() && h.numActive() === 1 ? (h.release(En), Ri = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, z.createTileMesh = fs, z.getMaxParallelImageRequests = function() {
          return c.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, z.getRTLTextPluginStatus = function() {
          return gr().getRTLTextPluginStatus();
        }, z.getVersion = function() {
          return Ma;
        }, z.getWorkerCount = function() {
          return sr.workerCount;
        }, z.getWorkerUrl = function() {
          return c.a.WORKER_URL;
        }, z.importScriptInWorkers = function(h) {
          return en().broadcast("IS", h);
        }, z.prewarm = function() {
          Yr().acquire(En);
        }, z.setMaxParallelImageRequests = function(h) {
          c.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
        }, z.setRTLTextPlugin = function(h, e) {
          return gr().setRTLTextPlugin(h, e);
        }, z.setWorkerCount = function(h) {
          sr.workerCount = h;
        }, z.setWorkerUrl = function(h) {
          c.a.WORKER_URL = h;
        };
      });
      var qr = Ne;
      return qr;
    });
  }(Pc)), Pc.exports;
}
var bf = vf();
function Pf(Me = "standaard") {
  const Ee = gf(Me);
  return JSON.parse(
    '{"version":8,"name":"nlmaps","sources":{"bg_source":{"type":"raster","tileSize":256,"attribution":"' + Ee.attribution + '","tiles":["' + Ee.url + '"],"maxzoom":' + Ee.maxZoom + ',"minzoom":' + Ee.minZoom + '}},"layers":[{"id":"bg","type":"raster","source":"bg_source","paint":{}}]}'
  );
}
class Sf {
  addTo(Ee) {
    const Ne = () => {
      Ee.getLayer(this.layerId) && Ee.removeLayer(this.layerId), Ee.getSource(this.sourceId) && Ee.removeSource(this.sourceId), Ee.addSource(this.sourceId, this.sourceDef), Ee.addLayer(this.layer);
    };
    return this._map = Ee, Ne(), this;
  }
  remove() {
    this._map && (this._map.getLayer(this.layerId) && this._map.removeLayer(this.layerId), this._map.getSource(this.sourceId) && this._map.removeSource(this.sourceId));
  }
  constructor(Ee, Ne) {
    const et = yf(Ee, Ne);
    this.layerId = et.name, this.sourceId = et.name + "-source", this.sourceDef = {
      type: "raster",
      tiles: [
        et.url + "service=WMS&request=GetMap&version=1.3.0&crs=EPSG:3857&transparent=true&width=512&height=512&bbox={bbox-epsg-3857}&layers=" + et.layerName + "&styles=" + et.styleName + "&format=" + et.format + "&transparent=" + et.transparent
      ],
      maxzoom: et.maxZoom,
      minzoom: et.minZoom
    }, this.layer = {
      id: this.layerId,
      type: "raster",
      source: this.sourceId,
      paint: {}
    };
  }
}
function wf(Me) {
  const Ee = new Image(Me.iconSize[0], Me.iconSize[1]);
  return Ee.crossOrigin = "Anonymous", new Promise((Ne) => {
    Ee.onload = () => {
      Ee.decode().then(() => Ne(Ee));
    }, Ee.src = Me.url;
  });
}
class Mf {
  addTo(Ee) {
    const Ne = () => {
      Ee.getImage("nlmaps-marker") && Ee.removeImage("nlmaps-marker"), Ee.getLayer(this.layerId) && Ee.removeLayer(this.layerId), Ee.getSource(this.sourceId) && Ee.removeSource(this.sourceId);
      const et = _f(this.options);
      wf(et).then((mt) => Ee.addImage("nlmaps-marker", mt)).then(() => {
        Ee.addSource(this.sourceId, this.sourceDef);
        let mt = Ee.getCenter();
        this.options && this.options.longitude && this.options.latitude && (mt = {
          lng: this.options.longitude,
          lat: this.options.latitude
        }), Ee.getSource(this.sourceId).setData({
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: [mt.lng, mt.lat]
              }
            }
          ]
        }), Ee.addLayer(this.layer);
      });
    };
    return this._map = Ee, Ne(), this;
  }
  constructor(Ee) {
    this.options = Ee, this.layerId = "marker-layer", this.sourceId = "marker-source", this.sourceDef = {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: []
      }
    }, this.layer = {
      id: this.layerId,
      type: "symbol",
      source: this.sourceId,
      layout: {
        "icon-image": "nlmaps-marker",
        "icon-anchor": "bottom"
      }
    };
  }
}
class If extends bf.GeolocateControl {
  _onSuccess(Ee) {
    this.map.flyTo({
      center: [Ee.coords.longitude, Ee.coords.latitude],
      zoom: 18,
      bearing: 0,
      pitch: 0
    });
  }
  onAdd(Ee) {
    this.map = Ee, this.container = document.createElement("div"), this.container.className = "maplibregl-ctrl nlmaps-geolocator-control";
    const Ne = document.createElement("img");
    return this.container.appendChild(Ne), this.container.addEventListener("click", () => {
      this.trigger();
    }), this._setup = !0, this.container;
  }
}
function Tf(Me, Ee) {
  Ee.jumpTo({
    center: Me.coordinates,
    zoom: 18
  });
}
class Cf {
  onAdd(Ee) {
    this._map = Ee, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-geocoder";
    let Ne = $i.createControl(Tf, Ee);
    return this._container.appendChild(Ne), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
export {
  Pf as bgLayer,
  If as geoLocatorControl,
  Cf as geocoderControl,
  Mf as markerLayer,
  Sf as overlayLayer
};
